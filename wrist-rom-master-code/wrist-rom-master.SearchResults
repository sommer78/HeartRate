---- received_buffer Matches (35 in 1 files) ----
Bd_communicate_protocol.c (source\src):static uint8_t received_buffer[GLOBAL_RECEIVE_BUFFER_SIZE];
Bd_communicate_protocol.c (source\src):            memcpy(&received_buffer[received_content_length],data,length);
Bd_communicate_protocol.c (source\src):            length_to_receive = (received_buffer[L1_PAYLOAD_LENGTH_LOW_BYTE_POS] | (received_buffer[L1_PAYLOAD_LENGTH_HIGH_BYTE_POS] << 8)) + L1_HEADER_SIZE;
Bd_communicate_protocol.c (source\src):                inner_version.value = received_buffer[L1_HEADER_PROTOCOL_VERSION_POS];
Bd_communicate_protocol.c (source\src):                    response_package_handle((received_buffer[L1_HEADER_SEQ_ID_LOW_BYTE_POS] | (received_buffer[L1_HEADER_SEQ_ID_HIGH_BYTE_POS] << 8)),inner_version.version_def.err_flag);
Bd_communicate_protocol.c (source\src):                uint16_t crc16_value = (received_buffer[L1_HEADER_CRC16_HIGH_BYTE_POS] << 8 | received_buffer[L1_HEADER_CRC16_LOW_BYTE_POS]);
Bd_communicate_protocol.c (source\src):                if(L1_crc_check(crc16_value,received_buffer+L1_HEADER_SIZE,(received_buffer[L1_PAYLOAD_LENGTH_LOW_BYTE_POS] | (received_buffer[L1_PAYLOAD_LENGTH_HIGH_BYTE_POS] << 8))) == NRF_SUCCESS) { //check crc for received package
Bd_communicate_protocol.c (source\src):                    L1_receive_response((received_buffer[L1_HEADER_SEQ_ID_LOW_BYTE_POS] | (received_buffer[L1_HEADER_SEQ_ID_HIGH_BYTE_POS] << 8)),true);
Bd_communicate_protocol.c (source\src):                    L2_frame_resolve(received_buffer+L1_HEADER_SIZE,(received_buffer[L1_PAYLOAD_LENGTH_LOW_BYTE_POS] | (received_buffer[L1_PAYLOAD_LENGTH_HIGH_BYTE_POS] << 8)),&receive_state);
Bd_communicate_protocol.c (source\src):                    L1_receive_response((received_buffer[L1_HEADER_SEQ_ID_LOW_BYTE_POS] | (received_buffer[L1_HEADER_SEQ_ID_HIGH_BYTE_POS] << 8)),false);
Bd_communicate_protocol.c (source\src):            memcpy(&received_buffer[received_content_length],data,length);
Bd_communicate_protocol.c (source\src):                inner_version.value = received_buffer[L1_HEADER_PROTOCOL_VERSION_POS];
Bd_communicate_protocol.c (source\src):                    response_package_handle((received_buffer[L1_HEADER_SEQ_ID_LOW_BYTE_POS] | (received_buffer[L1_HEADER_SEQ_ID_HIGH_BYTE_POS] << 8)),inner_version.version_def.err_flag);
Bd_communicate_protocol.c (source\src):                uint16_t crc16_value = (received_buffer[L1_HEADER_CRC16_HIGH_BYTE_POS] << 8 | received_buffer[L1_HEADER_CRC16_LOW_BYTE_POS]);
Bd_communicate_protocol.c (source\src):                if(L1_crc_check(crc16_value,received_buffer+L1_HEADER_SIZE,(received_buffer[L1_PAYLOAD_LENGTH_LOW_BYTE_POS] | (received_buffer[L1_PAYLOAD_LENGTH_HIGH_BYTE_POS] << 8))) == NRF_SUCCESS) { //check crc for received package
Bd_communicate_protocol.c (source\src):                    L1_receive_response((received_buffer[L1_HEADER_SEQ_ID_LOW_BYTE_POS] | (received_buffer[L1_HEADER_SEQ_ID_HIGH_BYTE_POS] << 8)),true);
Bd_communicate_protocol.c (source\src):                    L2_frame_resolve(received_buffer+L1_HEADER_SIZE,(received_buffer[L1_PAYLOAD_LENGTH_LOW_BYTE_POS] | (received_buffer[L1_PAYLOAD_LENGTH_HIGH_BYTE_POS] << 8)),&receive_state);
Bd_communicate_protocol.c (source\src):                    L1_receive_response((received_buffer[L1_HEADER_SEQ_ID_LOW_BYTE_POS] | (received_buffer[L1_HEADER_SEQ_ID_HIGH_BYTE_POS] << 8)),false);
---- L1_receive_data Matches (3 in 3 files) ----
Bd_communicate_protocol.c (source\src):void L1_receive_data(ble_nus_t * p_nus, uint8_t * data, uint16_t length)
Bd_communicate_protocol.h (source\inc):void L1_receive_data(ble_nus_t * p_nus, uint8_t * data, uint16_t length);
Main.c (source\src):    nus_init.data_handler = L1_receive_data;
---- ble_gatts_characteristic_add Matches (0 in 0 files) ----
---- 6e400002 Matches (0 in 0 files) ----
---- uuid Matches (1063 in 36 files) ----
Bd_ble_nus.c (source\src):    ble_uuid_t          ble_uuid;
Bd_ble_nus.c (source\src):    ble_uuid.type = p_nus->uuid_type;
Bd_ble_nus.c (source\src):    ble_uuid.uuid = BLE_UUID_NUS_RX_CHARACTERISTIC;
Bd_ble_nus.c (source\src):    attr_char_value.p_uuid       = &ble_uuid;
Bd_ble_nus.c (source\src):    ble_uuid_t          ble_uuid;
Bd_ble_nus.c (source\src):    ble_uuid.type = p_nus->uuid_type;
Bd_ble_nus.c (source\src):    ble_uuid.uuid = BLE_UUID_NUS_TX_CHARACTERISTIC;
Bd_ble_nus.c (source\src):    attr_char_value.p_uuid       = &ble_uuid;
Bd_ble_nus.c (source\src):    ble_uuid_t ble_uuid;
Bd_ble_nus.c (source\src):    ble_uuid128_t nus_base_uuid = {0x9E, 0xCA, 0xDC, 0x24, 0x0E, 0xE5, 0xA9, 0xE0, 0x93, 0xF3, 0xA3, 0xB5, 0x00, 0x00, 0x40, 0x6E};
Bd_ble_nus.c (source\src):    // Add custom base UUID
Bd_ble_nus.c (source\src):    err_code = sd_ble_uuid_vs_add(&nus_base_uuid, &p_nus->uuid_type);
Bd_ble_nus.c (source\src):    ble_uuid.type = p_nus->uuid_type;
Bd_ble_nus.c (source\src):    ble_uuid.uuid = BLE_UUID_NUS_SERVICE;
Bd_ble_nus.c (source\src):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_nus->service_handle);
Bd_ble_nus.h (source\inc):#define BLE_UUID_NUS_SERVICE 0x0001
Bd_ble_nus.h (source\inc):#define BLE_UUID_NUS_TX_CHARACTERISTIC 0x0002
Bd_ble_nus.h (source\inc):#define BLE_UUID_NUS_RX_CHARACTERISTIC 0x0003
Bd_ble_nus.h (source\inc):    uint8_t                  uuid_type;               /**< UUID type for Nordic UART Service Base UUID. */
Ble.h (nrf51822\include\ble\softdevice):  SD_BLE_UUID_VS_ADD,                   /**< Add a Vendor Specific UUID. */
Ble.h (nrf51822\include\ble\softdevice):  SD_BLE_UUID_DECODE,                   /**< Decode UUID bytes. */
Ble.h (nrf51822\include\ble\softdevice):  SD_BLE_UUID_ENCODE,                   /**< Encode UUID bytes. */
Ble.h (nrf51822\include\ble\softdevice):/**@brief Add a Vendor Specific UUID.
Ble.h (nrf51822\include\ble\softdevice): * @details This call enables the application to add a vendor specific UUID to the BLE stack's table,
Ble.h (nrf51822\include\ble\softdevice): *          24-bit @ref ble_uuid_t format when dealing with both 16-bit and 128-bit UUIDs without having to
Ble.h (nrf51822\include\ble\softdevice): *          grouping mechanism that the Bluetooth SIG standard base UUID uses for all other 128-bit UUIDs. The 
Ble.h (nrf51822\include\ble\softdevice): *          type field in the @ref ble_uuid_t structure is an index (relative to @ref BLE_UUID_TYPE_VENDOR_BEGIN) 
Ble.h (nrf51822\include\ble\softdevice): *          to the table populated by multiple calls to this function, and the uuid field in the same structure contains the 2 bytes 
Ble.h (nrf51822\include\ble\softdevice): *          (byte 12 and byte 13) corresponding to the TimeLow portion of the UUID. The number of possible 128-bit 
Ble.h (nrf51822\include\ble\softdevice): *          UUIDs available to the application is therefore the number of Vendor Specific UUIDs added with the help
Ble.h (nrf51822\include\ble\softdevice): * @note Bytes 12 and 13 of the provided UUID will not be used internally, since those are always replaced by 
Ble.h (nrf51822\include\ble\softdevice): * the 16-bit uuid field in @ref ble_uuid_t.
Ble.h (nrf51822\include\ble\softdevice): * @param[in]  p_vs_uuid    Pointer to a 16-octet (128-bit) little endian Vendor Specific UUID disregarding
Ble.h (nrf51822\include\ble\softdevice): * @param[out] p_uuid_type  Pointer where the type field in @ref ble_uuid_t corresponding to this UUID will be stored.
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS Successfully added the Vendor Specific UUID.
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_NO_MEM If the size exceeds the number of free slots for VS UUIDs.
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_LENGTH If vs_uuid_count is 0.
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR if p_vs_uuids is NULL or invalid.
Ble.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_UUID_VS_ADD, uint32_t, sd_ble_uuid_vs_add(ble_uuid128_t const * const p_vs_uuid, uint8_t * const p_uuid_type));
Ble.h (nrf51822\include\ble\softdevice):/** @brief Decode little endian raw UUID bytes (16-bit or 128-bit) into a 24 bit @ref ble_uuid_t structure.
Ble.h (nrf51822\include\ble\softdevice): * @details The raw UUID bytes excluding the TimeLow portion (i.e. bytes 0-11 and 14-15) of p_uuid_le are compared 
Ble.h (nrf51822\include\ble\softdevice): * to the corresponding ones in each entry of the table of vendor specific UUIDs pouplated with @ref sd_ble_uuid_vs_add 
Ble.h (nrf51822\include\ble\softdevice): * to look for a match. If there is such a match, bytes 12 and 13 are returned as p_uuid->uuid and the index 
Ble.h (nrf51822\include\ble\softdevice): * relative to @ref BLE_UUID_TYPE_VENDOR_BEGIN as p_uuid->type. 
Ble.h (nrf51822\include\ble\softdevice): * @note If the UUID length supplied is 2, then the type set by this call will always be @ref BLE_UUID_TYPE_BLE.
Ble.h (nrf51822\include\ble\softdevice): * @param[in]      uuid_le_len Length in bytes of the buffer pointed to by p_uuid_le (must be 2 or 16 bytes).
Ble.h (nrf51822\include\ble\softdevice): * @param[in]      p_uuid_le   Pointer pointing to little endian raw UUID bytes.
Ble.h (nrf51822\include\ble\softdevice): * @param[in,out]  p_uuid      Pointer to a @ref ble_uuid_t structure to be filled in.
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS Successfully decoded into the @ref ble_uuid_t structure.
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_LENGTH Invalid UUID length.
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_NOT_FOUND For a 128-bit UUID, no match in the populated table of UUIDs.
Ble.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_UUID_DECODE, uint32_t, sd_ble_uuid_decode(uint8_t uuid_le_len, uint8_t const * const p_uuid_le, ble_uuid_t * const p_uuid));
Ble.h (nrf51822\include\ble\softdevice):/** @brief Encode a @ref ble_uuid_t structure into little endian raw UUID bytes (16-bit or 128-bit).
Ble.h (nrf51822\include\ble\softdevice): * @note The pointer to the destination buffer p_uuid_le may be NULL, in which case only the validitiy and size of p_uuid is computed.
Ble.h (nrf51822\include\ble\softdevice): * @param[in]      p_uuid        Pointer to a @ref ble_uuid_t structure that will be encoded into bytes.
Ble.h (nrf51822\include\ble\softdevice): * @param[out]     p_uuid_le_len Pointer to a uint8_t that will be filled with the encoded length (2 or 16 bytes).
Ble.h (nrf51822\include\ble\softdevice): * @param[out]     p_uuid_le     Pointer to a buffer where the little endian raw UUID bytes (2 or 16) will be stored.
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_PARAM Invalid UUID type.
Ble.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_UUID_ENCODE, uint32_t, sd_ble_uuid_encode(ble_uuid_t const * const p_uuid, uint8_t * const  p_uuid_le_len, uint8_t * const p_uuid_le));
Ble_advdata.c (nrf51822\source\ble):static uint32_t uuid_list_sized_encode(const ble_advdata_uuid_list_t * p_uuid_list,
Ble_advdata.c (nrf51822\source\ble):                                       uint8_t                         uuid_size,
Ble_advdata.c (nrf51822\source\ble):    for (i = 0; i < p_uuid_list->uuid_cnt; i++)
Ble_advdata.c (nrf51822\source\ble):        ble_uuid_t uuid = p_uuid_list->p_uuids[i];
Ble_advdata.c (nrf51822\source\ble):        // Find encoded uuid size.
Ble_advdata.c (nrf51822\source\ble):        err_code = sd_ble_uuid_encode(&uuid, &encoded_size, NULL);
Ble_advdata.c (nrf51822\source\ble):        if (encoded_size == uuid_size)
Ble_advdata.c (nrf51822\source\ble):            // Write UUID.
Ble_advdata.c (nrf51822\source\ble):            err_code = sd_ble_uuid_encode(&uuid, &encoded_size, &p_encoded_data[*p_len]);
Ble_advdata.c (nrf51822\source\ble):static uint32_t uuid_list_encode(const ble_advdata_uuid_list_t * p_uuid_list,
Ble_advdata.c (nrf51822\source\ble):    // Encode 16 bit UUIDs.
Ble_advdata.c (nrf51822\source\ble):    err_code = uuid_list_sized_encode(p_uuid_list,
Ble_advdata.c (nrf51822\source\ble):    // Encode 128 bit UUIDs.
Ble_advdata.c (nrf51822\source\ble):    err_code = uuid_list_sized_encode(p_uuid_list,
Ble_advdata.c (nrf51822\source\ble):                                      sizeof(ble_uuid128_t),
Ble_advdata.c (nrf51822\source\ble):        // Encode service UUID.
Ble_advdata.c (nrf51822\source\ble):        (*p_len) += uint16_encode(p_service_data->service_uuid, &p_encoded_data[*p_len]);
Ble_advdata.c (nrf51822\source\ble):    // Encode 'more available' uuid list.
Ble_advdata.c (nrf51822\source\ble):    if (p_advdata->uuids_more_available.uuid_cnt > 0)
Ble_advdata.c (nrf51822\source\ble):        err_code = uuid_list_encode(&p_advdata->uuids_more_available,
Ble_advdata.c (nrf51822\source\ble):                                    BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE,
Ble_advdata.c (nrf51822\source\ble):                                    BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE,
Ble_advdata.c (nrf51822\source\ble):    // Encode 'complete' uuid list.
Ble_advdata.c (nrf51822\source\ble):    if (p_advdata->uuids_complete.uuid_cnt > 0)
Ble_advdata.c (nrf51822\source\ble):        err_code = uuid_list_encode(&p_advdata->uuids_complete,
Ble_advdata.c (nrf51822\source\ble):                                    BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE,
Ble_advdata.c (nrf51822\source\ble):                                    BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE,
Ble_advdata.c (nrf51822\source\ble):    // Encode 'solicited service' uuid list.
Ble_advdata.c (nrf51822\source\ble):    if (p_advdata->uuids_solicited.uuid_cnt > 0)
Ble_advdata.c (nrf51822\source\ble):        err_code = uuid_list_encode(&p_advdata->uuids_solicited,
Ble_advdata.c (nrf51822\source\ble):                                    BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT,
Ble_advdata.c (nrf51822\source\ble):                                    BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT,
Ble_advdata.h (nrf51822\include\ble):/**@brief UUID list type. */
Ble_advdata.h (nrf51822\include\ble):    uint16_t                     uuid_cnt;                            /**< Number of UUID entries. */
Ble_advdata.h (nrf51822\include\ble):    ble_uuid_t *                 p_uuids;                             /**< Pointer to UUID array entries. */
Ble_advdata.h (nrf51822\include\ble):} ble_advdata_uuid_list_t;
Ble_advdata.h (nrf51822\include\ble):    uint16_t                     service_uuid;                        /**< Service UUID. */
Ble_advdata.h (nrf51822\include\ble):    ble_advdata_uuid_list_t      uuids_more_available;                /**< List of UUIDs in the 'More Available' list. */
Ble_advdata.h (nrf51822\include\ble):    ble_advdata_uuid_list_t      uuids_complete;                      /**< List of UUIDs in the 'Complete' list. */
Ble_advdata.h (nrf51822\include\ble):    ble_advdata_uuid_list_t      uuids_solicited;                     /**< List of solcited UUIDs. */
Ble_ans_c.c (nrf51822\source\ble\ble_services):    ble_uuid_t               uuid;                                                         /**< UUID identifying this characteristic. */
Ble_ans_c.c (nrf51822\source\ble\ble_services):    ble_uuid_t ans_uuid;
Ble_ans_c.c (nrf51822\source\ble\ble_services):    // Discover services on uuid Alert Notification.
Ble_ans_c.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ans_uuid, BLE_UUID_ALERT_NOTIFICATION_SERVICE);
Ble_ans_c.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gattc_primary_services_discover(p_ans->conn_handle, handle, &ans_uuid);
Ble_ans_c.c (nrf51822\source\ble\ble_services):    // If we are setting up a bonded connection and the UUID of the service
Ble_ans_c.c (nrf51822\source\ble\ble_services):    if (m_service.service.uuid.uuid != BLE_UUID_ALERT_NOTIFICATION_SERVICE)
Ble_ans_c.c (nrf51822\source\ble\ble_services):        BLE_UUID_COPY_INST(m_service.service.uuid,
Ble_ans_c.c (nrf51822\source\ble\ble_services):                           p_ble_evt->evt.gattc_evt.params.prim_srvc_disc_rsp.services[0].uuid);
Ble_ans_c.c (nrf51822\source\ble\ble_services):    BLE_UUID_COPY_INST(p_characteristic->uuid, p_char_resp->uuid);
Ble_ans_c.c (nrf51822\source\ble\ble_services):            switch (p_char_resp->uuid.uuid)
Ble_ans_c.c (nrf51822\source\ble\ble_services):                case BLE_UUID_ALERT_NOTIFICATION_CONTROL_POINT_CHAR:
Ble_ans_c.c (nrf51822\source\ble\ble_services):                case BLE_UUID_UNREAD_ALERT_CHAR:
Ble_ans_c.c (nrf51822\source\ble\ble_services):                case BLE_UUID_NEW_ALERT_CHAR:
Ble_ans_c.c (nrf51822\source\ble\ble_services):                case BLE_UUID_SUPPORTED_UNREAD_ALERT_CATEGORY_CHAR:
Ble_ans_c.c (nrf51822\source\ble\ble_services):                case BLE_UUID_SUPPORTED_NEW_ALERT_CATEGORY_CHAR:
Ble_ans_c.c (nrf51822\source\ble\ble_services):        p_desc_resp->uuid.uuid == BLE_UUID_DESCRIPTOR_CLIENT_CHAR_CONFIG)
Ble_ans_c.c (nrf51822\source\ble\ble_services):             p_desc_resp->uuid.uuid == BLE_UUID_DESCRIPTOR_CLIENT_CHAR_CONFIG)
Ble_ans_c.c (nrf51822\source\ble\ble_services):        BLE_UUID_COPY_INST(event.uuid, m_service.new_alert.uuid);
Ble_ans_c.c (nrf51822\source\ble\ble_services):        BLE_UUID_COPY_INST(event.uuid, m_service.unread_alert_status.uuid);
Ble_ans_c.c (nrf51822\source\ble\ble_services):        BLE_UUID_COPY_INST(event.uuid, m_service.suported_new_alert_cat.uuid);
Ble_ans_c.c (nrf51822\source\ble\ble_services):        BLE_UUID_COPY_INST(event.uuid, m_service.suported_unread_alert_cat.uuid);
Ble_ans_c.h (nrf51822\include\ble\ble_services):/** Alerts types as defined in the alert category id; UUID: 0x2A43. */
Ble_ans_c.h (nrf51822\include\ble\ble_services): * UUID: 0x2A44.
Ble_ans_c.h (nrf51822\include\ble\ble_services):    ble_uuid_t                          uuid;                                             /**< UUID of the event in case of an alert or notification. */
Ble_ans_c.h (nrf51822\include\ble\ble_services): *                             Point, UUID 0x2A44.
Ble_bas.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_bas.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_BATTERY_LEVEL_CHAR);
Ble_bas.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_bas.c (nrf51822\source\ble\ble_services):        BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_REPORT_REF_DESCR);
Ble_bas.c (nrf51822\source\ble\ble_services):        attr_char_value.p_uuid       = &ble_uuid;
Ble_bas.c (nrf51822\source\ble\ble_services):    ble_uuid_t ble_uuid;
Ble_bas.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_BATTERY_SERVICE);
Ble_bas.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_bas->service_handle);
Ble_bps.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_bps.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_BLOOD_PRESSURE_MEASUREMENT_CHAR);
Ble_bps.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_bps.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_bps.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_BLOOD_PRESSURE_FEATURE_CHAR);
Ble_bps.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_bps.c (nrf51822\source\ble\ble_services):    ble_uuid_t ble_uuid;
Ble_bps.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_BLOOD_PRESSURE_SERVICE);
Ble_bps.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_bps->service_handle);
Ble_cscs.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_cscs.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_CSC_MEASUREMENT_CHAR);
Ble_cscs.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_cscs.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_cscs.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_CSC_FEATURE_CHAR);
Ble_cscs.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_cscs.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_cscs.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_SENSOR_LOCATION_CHAR);
Ble_cscs.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_cscs.c (nrf51822\source\ble\ble_services):    ble_uuid_t ble_uuid;
Ble_cscs.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_CYCLING_SPEED_AND_CADENCE);
Ble_cscs.c (nrf51822\source\ble\ble_services):                                        &ble_uuid,
Ble_dfu.c (nrf51822\source\ble\ble_services):    ble_uuid_t          char_uuid;
Ble_dfu.c (nrf51822\source\ble\ble_services):    char_uuid.type = p_dfu->uuid_type;
Ble_dfu.c (nrf51822\source\ble\ble_services):    char_uuid.uuid = BLE_DFU_PKT_CHAR_UUID;
Ble_dfu.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid    = &char_uuid;
Ble_dfu.c (nrf51822\source\ble\ble_services):    ble_uuid_t          char_uuid;
Ble_dfu.c (nrf51822\source\ble\ble_services):    char_uuid.type = p_dfu->uuid_type;
Ble_dfu.c (nrf51822\source\ble\ble_services):    char_uuid.uuid = BLE_DFU_CTRL_PT_UUID;
Ble_dfu.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &char_uuid;
Ble_dfu.c (nrf51822\source\ble\ble_services):    ble_uuid_t  service_uuid;
Ble_dfu.c (nrf51822\source\ble\ble_services):    const ble_uuid128_t base_uuid128 =
Ble_dfu.c (nrf51822\source\ble\ble_services):    service_uuid.uuid = BLE_DFU_SERVICE_UUID;
Ble_dfu.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_uuid_vs_add(&base_uuid128, &(service_uuid.type));
Ble_dfu.c (nrf51822\source\ble\ble_services):                                        &service_uuid,
Ble_dfu.c (nrf51822\source\ble\ble_services):    p_dfu->uuid_type = service_uuid.type;
Ble_dfu.h (nrf51822\include\ble\ble_services): *           specific UUIDs for service and characteristics and is intended to demonstrate the
Ble_dfu.h (nrf51822\include\ble\ble_services):#define BLE_DFU_SERVICE_UUID     0x1530                                 /**< The UUID of the DFU Service. */
Ble_dfu.h (nrf51822\include\ble\ble_services):#define BLE_DFU_PKT_CHAR_UUID    0x1532                                 /**< The UUID of the DFU Packet Characteristic. */
Ble_dfu.h (nrf51822\include\ble\ble_services):#define BLE_DFU_CTRL_PT_UUID     0x1531                                 /**< The UUID of the DFU Control Point. */
Ble_dfu.h (nrf51822\include\ble\ble_services):#define BLE_DFU_STATUS_REP_UUID  0x1533                                 /**< The UUID of the DFU Status Report Characteristic. */
Ble_dfu.h (nrf51822\include\ble\ble_services):    uint8_t                      uuid_type;                             /**< UUID type assigned for DFU Service by the BLE stack. */
Ble_dis.c (nrf51822\source\ble\ble_services): * @param[in]   uuid           UUID of characteristic to be added.
Ble_dis.c (nrf51822\source\ble\ble_services):static uint32_t char_add(uint16_t                        uuid,
Ble_dis.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_dis.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, uuid);
Ble_dis.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_dis.c (nrf51822\source\ble\ble_services):    ble_uuid_t ble_uuid;
Ble_dis.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_DEVICE_INFORMATION_SERVICE);
Ble_dis.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &service_handle);
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_MANUFACTURER_NAME_STRING_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_MODEL_NUMBER_STRING_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_SERIAL_NUMBER_STRING_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_HARDWARE_REVISION_STRING_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_FIRMWARE_REVISION_STRING_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_SOFTWARE_REVISION_STRING_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_SYSTEM_ID_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_IEEE_REGULATORY_CERTIFICATION_DATA_LIST_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_PNP_ID_CHAR,
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_ERROR_GAP_UUID_LIST_MISMATCH            (NRF_GAP_ERR_BASE + 0x000)  /**< UUID list does not contain an integral number of UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE   0x02 /**< Partial list of 16 bit service UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE         0x03 /**< Complete list of 16 bit service UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_MORE_AVAILABLE   0x04 /**< Partial list of 32 bit service UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_COMPLETE         0x05 /**< Complete list of 32 bit service UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE  0x06 /**< Partial list of 128 bit service UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE        0x07 /**< Complete list of 128 bit service UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT       0x14 /**< List of 16-bit Service Solicitation UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT      0x15 /**< List of 128-bit Service Solicitation UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref BLE_ERROR_GAP_UUID_LIST_MISMATCH Invalid UUID list supplied.
Ble_gattc.h (nrf51822\include\ble\softdevice):  SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ,                        /**< Read Characteristic Value by UUID. */
Ble_gattc.h (nrf51822\include\ble\softdevice):  ble_uuid_t               uuid;          /**< Service UUID. */
Ble_gattc.h (nrf51822\include\ble\softdevice):  ble_uuid_t              uuid;                 /**< Characteristic UUID. */
Ble_gattc.h (nrf51822\include\ble\softdevice):  ble_uuid_t        uuid;           /**< Descriptor UUID. */
Ble_gattc.h (nrf51822\include\ble\softdevice):  BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP,                /**< Read By UUID Response event. */
Ble_gattc.h (nrf51822\include\ble\softdevice):/**@brief GATT read by UUID handle value pair. */
Ble_gattc.h (nrf51822\include\ble\softdevice):  uint8_t             *p_value;        /**< Pointer to value, variable length (length available as value_len in ble_gattc_evt_read_by_uuid_rsp_t). 
Ble_gattc.h (nrf51822\include\ble\softdevice):/**@brief Event structure for BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP. */
Ble_gattc.h (nrf51822\include\ble\softdevice):} ble_gattc_evt_char_val_by_uuid_read_rsp_t;
Ble_gattc.h (nrf51822\include\ble\softdevice):    ble_gattc_evt_char_val_by_uuid_read_rsp_t   char_val_by_uuid_read_rsp;  /**< Characteristic Value Read by UUID Response Event Parameters. */
Ble_gattc.h (nrf51822\include\ble\softdevice): * @note If any of the discovered services have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with
Ble_gattc.h (nrf51822\include\ble\softdevice): *       type BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @param[in] p_srvc_uuid Pointer to the service UUID to be found. If it is NULL, all primary services will be returned.
Ble_gattc.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER, uint32_t, sd_ble_gattc_primary_services_discover(uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const * const p_srvc_uuid));
Ble_gattc.h (nrf51822\include\ble\softdevice): * @note If any of the discovered characteristics have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with
Ble_gattc.h (nrf51822\include\ble\softdevice): *       type BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event.
Ble_gattc.h (nrf51822\include\ble\softdevice):/**@brief Initiate or continue a GATT Read using Characteristic UUID procedure.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @details This function initiates the Read using Characteristic UUID procedure. If the last Characteristic has not been reached,
Ble_gattc.h (nrf51822\include\ble\softdevice): * @param[in] p_uuid Pointer to a Characteristic value UUID to read.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS Successfully started or resumed the Read using Characteristic UUID procedure.
Ble_gattc.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ, uint32_t, sd_ble_gattc_char_value_by_uuid_read(uint16_t conn_handle, ble_uuid_t const * const p_uuid, ble_gattc_handle_range_t const * const p_handle_range));
Ble_gatts.h (nrf51822\include\ble\softdevice):  ble_uuid_t*          p_uuid;          /**< Pointer to the attribute UUID. */
Ble_gatts.h (nrf51822\include\ble\softdevice):  ble_uuid_t           srvc_uuid;       /**< Service UUID. */
Ble_gatts.h (nrf51822\include\ble\softdevice):  ble_uuid_t           char_uuid;       /**< Characteristic UUID if applicable (BLE_UUID_TYPE_UNKNOWN if N/A). */
Ble_gatts.h (nrf51822\include\ble\softdevice):  ble_uuid_t           desc_uuid;       /**< Descriptor UUID if applicable (BLE_UUID_TYPE_UNKNOWN if N/A). */
Ble_gatts.h (nrf51822\include\ble\softdevice):  uint16_t         unit;        /**< UUID from Bluetooth Assigned Numbers. */
Ble_gatts.h (nrf51822\include\ble\softdevice): * @param[in] p_uuid    Pointer to service UUID.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, Vendor Specific UUIDs need to be present in the table.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
Ble_gatts.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_GATTS_SERVICE_ADD, uint32_t, sd_ble_gatts_service_add(uint8_t type, ble_uuid_t const*const p_uuid, uint16_t *const p_handle));
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, service handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, characteristic handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
Ble_gls.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_gls.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_GLUCOSE_MEASUREMENT_CHAR);
Ble_gls.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_gls.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_gls.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_GLUCOSE_FEATURE_CHAR);
Ble_gls.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_gls.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_gls.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_RECORD_ACCESS_CONTROL_POINT_CHAR);
Ble_gls.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_gls.c (nrf51822\source\ble\ble_services):    ble_uuid_t ble_uuid;
Ble_gls.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_GLUCOSE_SERVICE);
Ble_gls.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_gls->service_handle);
Ble_hids.c (nrf51822\source\ble\ble_services): * @param[in]   uuid        UUID of characteristic.
Ble_hids.c (nrf51822\source\ble\ble_services):static ble_hids_char_id_t make_char_id(uint16_t uuid, uint8_t rep_type, uint8_t rep_index)
Ble_hids.c (nrf51822\source\ble\ble_services):    char_id.uuid      = uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):            *p_char_id = make_char_id(BLE_UUID_REPORT_CHAR, BLE_HIDS_REP_TYPE_INPUT, i);
Ble_hids.c (nrf51822\source\ble\ble_services):            *p_char_id = make_char_id(BLE_UUID_REPORT_CHAR, BLE_HIDS_REP_TYPE_INPUT, i);
Ble_hids.c (nrf51822\source\ble\ble_services):            *p_char_id = make_char_id(BLE_UUID_REPORT_CHAR, BLE_HIDS_REP_TYPE_OUTPUT, i);
Ble_hids.c (nrf51822\source\ble\ble_services):            *p_char_id = make_char_id(BLE_UUID_REPORT_CHAR, BLE_HIDS_REP_TYPE_FEATURE, i);
Ble_hids.c (nrf51822\source\ble\ble_services):        char_id = make_char_id(BLE_UUID_BOOT_KEYBOARD_INPUT_REPORT_CHAR, 0, 0);
Ble_hids.c (nrf51822\source\ble\ble_services):        char_id = make_char_id(BLE_UUID_BOOT_KEYBOARD_INPUT_REPORT_CHAR, 0, 0);
Ble_hids.c (nrf51822\source\ble\ble_services):        char_id = make_char_id(BLE_UUID_BOOT_MOUSE_INPUT_REPORT_CHAR, 0, 0);
Ble_hids.c (nrf51822\source\ble\ble_services):        char_id = make_char_id(BLE_UUID_BOOT_MOUSE_INPUT_REPORT_CHAR, 0, 0);
Ble_hids.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_PROTOCOL_MODE_CHAR);
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_REPORT_CHAR);
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid    = &ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_REPORT_REF_DESCR);
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid    = &ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_REPORT_MAP_CHAR);
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid    = &ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):        uint8_t encoded_rep_ref[sizeof(ble_uuid128_t)];
Ble_hids.c (nrf51822\source\ble\ble_services):        BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_EXTERNAL_REPORT_REF_DESCR);
Ble_hids.c (nrf51822\source\ble\ble_services):        err_code = sd_ble_uuid_encode(p_hids_init->rep_map.p_ext_rep_ref,
Ble_hids.c (nrf51822\source\ble\ble_services):        attr_char_value.p_uuid    = &ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services): * @param[in]   uuid             UUID of report characteristic to be added.
Ble_hids.c (nrf51822\source\ble\ble_services):                                      uint16_t                             uuid,
Ble_hids.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, uuid);
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid    = &ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_BOOT_KEYBOARD_OUTPUT_REPORT_CHAR);
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid    = &ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_HID_INFORMATION_CHAR);
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid    = &ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_HID_CONTROL_POINT_CHAR);
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid    = &ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):    ble_uuid_t ble_uuid;
Ble_hids.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_HUMAN_INTERFACE_DEVICE_SERVICE);
Ble_hids.c (nrf51822\source\ble\ble_services):                                        &ble_uuid,
Ble_hids.c (nrf51822\source\ble\ble_services):                                         BLE_UUID_BOOT_KEYBOARD_INPUT_REPORT_CHAR,
Ble_hids.c (nrf51822\source\ble\ble_services):                                         BLE_UUID_BOOT_MOUSE_INPUT_REPORT_CHAR,
Ble_hids.h (nrf51822\include\ble\ble_services):    uint16_t uuid;                                  /**< UUID of characteristic. */
Ble_hids.h (nrf51822\include\ble\ble_services):    uint8_t  rep_type;                              /**< Type of report (only used for BLE_UUID_REPORT_CHAR, see @ref BLE_HIDS_REPORT_TYPE). */
Ble_hids.h (nrf51822\include\ble\ble_services):    uint8_t  rep_index;                             /**< Index of the characteristic (only used for BLE_UUID_REPORT_CHAR). */
Ble_hids.h (nrf51822\include\ble\ble_services):    ble_uuid_t *                  p_ext_rep_ref;    /**< Optional External Report Reference descriptor (will be added if != NULL). */
Ble_hrs.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_hrs.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_HEART_RATE_MEASUREMENT_CHAR);
Ble_hrs.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_hrs.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_hrs.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_BODY_SENSOR_LOCATION_CHAR);
Ble_hrs.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_hrs.c (nrf51822\source\ble\ble_services):    ble_uuid_t ble_uuid;
Ble_hrs.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_HEART_RATE_SERVICE);
Ble_hrs.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_hrs->service_handle);
Ble_hts.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_hts.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_TEMPERATURE_MEASUREMENT_CHAR);
Ble_hts.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_hts.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_hts.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_TEMPERATURE_TYPE_CHAR);
Ble_hts.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_hts.c (nrf51822\source\ble\ble_services):    ble_uuid_t ble_uuid;
Ble_hts.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_HEALTH_THERMOMETER_SERVICE);
Ble_hts.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_hts->service_handle);
Ble_ias.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_ias.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_ALERT_LEVEL_CHAR);
Ble_ias.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_ias.c (nrf51822\source\ble\ble_services):    ble_uuid_t ble_uuid;
Ble_ias.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_IMMEDIATE_ALERT_SERVICE);
Ble_ias.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_ias->service_handle);
Ble_ias_c.c (nrf51822\source\ble\ble_services):static ble_uuid_t m_alert_level_uuid;       /**< Structure to store the UUID of Alert Level characteristic. */
Ble_ias_c.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(m_alert_level_uuid, BLE_UUID_ALERT_LEVEL_CHAR);
Ble_ias_c.c (nrf51822\source\ble\ble_services):    ble_uuid_t ias_uuid;
Ble_ias_c.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ias_uuid, BLE_UUID_IMMEDIATE_ALERT_SERVICE);
Ble_ias_c.c (nrf51822\source\ble\ble_services):    return sd_ble_gattc_primary_services_discover(p_ias_c->conn_handle, START_HANDLE, &ias_uuid);
Ble_ias_c.c (nrf51822\source\ble\ble_services):            if (BLE_UUID_EQ(&m_alert_level_uuid, &(p_char_disc_rsp->chars[i].uuid)))
Ble_lls.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_lls.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_ALERT_LEVEL_CHAR);
Ble_lls.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_lls.c (nrf51822\source\ble\ble_services):    ble_uuid_t ble_uuid;
Ble_lls.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_LINK_LOSS_SERVICE);
Ble_lls.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_lls->service_handle);
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):/**@brief Function for decoding a command packet with RPC_SD_BLE_UUID_ENCODE opcode.
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):static uint32_t uuid_encode_handle(uint8_t * p_command, uint32_t command_len)
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):    ble_uuid_t uuid_data;
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):    // uuid can be up to 16 bytes, and 1 byte length field
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):    uint8_t      response_buffer[sizeof(ble_uuid128_t) + sizeof(uint8_t)];
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):    ble_uuid_t * p_uuid_data     = &uuid_data;
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):    // UUID field present.
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):        RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_UUID_ENCODE);
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):        uuid_data.uuid  = uint16_decode(&(p_command[index]));
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):        RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_UUID_ENCODE);
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):        uuid_data.type  = p_command[index++];
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):        RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_UUID_ENCODE);
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):        p_uuid_data = NULL;
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):        RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_UUID_ENCODE);
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):    RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_UUID_ENCODE);
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):    err_code = sd_ble_uuid_encode(p_uuid_data, p_length, p_result_buffer);
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):        return ble_rpc_cmd_resp_data_send(SD_BLE_UUID_ENCODE,
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):    return ble_rpc_cmd_resp_send(SD_BLE_UUID_ENCODE, err_code);
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):        case SD_BLE_UUID_ENCODE:
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):            err_code = uuid_encode_handle(p_command, command_len);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    ble_uuid_t   uuid;
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    ble_uuid_t * p_uuid;
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    // Service UUID field is present.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        uuid.uuid = uint16_decode(&p_command[index]);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        uuid.type = p_command[index++];
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        p_uuid    = &uuid;
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        p_uuid = NULL;
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    err_code = sd_ble_gatts_service_add(type, p_uuid, p_handle);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    ble_uuid_t                 attr_char_value_uuid;
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        // UUID present.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):            attr_char_value_uuid.uuid  = uint16_decode(&p_command[index]);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):            attr_char_value_uuid.type = p_command[index++];
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):            attr_char_value.p_uuid    = &attr_char_value_uuid;
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):            attr_char_value.p_uuid = NULL;
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):uint32_t sd_ble_uuid_encode(ble_uuid_t const * const p_uuid,
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):                            uint8_t          * const p_uuid_le_len,
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):                            uint8_t          * const p_uuid_le)
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):    g_cmd_buffer[index++] = SD_BLE_UUID_ENCODE;
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):    if (p_uuid != NULL)
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):        index                += uint16_encode(p_uuid->uuid, &g_cmd_buffer[index]);
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):        g_cmd_buffer[index++] = p_uuid->type;
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):    if (p_uuid_le_len != NULL)
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):    if (p_uuid_le != NULL)
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):    err_code = ble_rpc_cmd_resp_wait(SD_BLE_UUID_ENCODE);
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):    if (p_uuid_le_len != NULL)
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):        *p_uuid_le_len = g_cmd_response_buf[BLE_OP_CODE_SIZE  +
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):    if ((p_uuid_le != NULL) && (p_uuid_le_len != NULL))
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):        memcpy(p_uuid_le, 
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):                                    sizeof(*p_uuid_le_len)]),
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc):               *p_uuid_le_len);
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):                                  ble_uuid_t const * const p_uuid,
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):    if (p_uuid != NULL)
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):        index                += uint16_encode(p_uuid->uuid, &g_cmd_buffer[index]);
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):        g_cmd_buffer[index++] = p_uuid->type;
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):        if (p_attr_char_value->p_uuid != NULL)
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):            index                += uint16_encode(p_attr_char_value->p_uuid->uuid, 
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):            g_cmd_buffer[index++] = p_attr_char_value->p_uuid->type;
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc):    p_decoded_evt->context.srvc_uuid.uuid = uint16_decode(&p_evt_data[index]);
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc):    p_decoded_evt->context.srvc_uuid.type = p_evt_data[index++];
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc):    p_decoded_evt->context.char_uuid.uuid = uint16_decode(&p_evt_data[index]);
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc):    p_decoded_evt->context.char_uuid.type = p_evt_data[index++];
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc):    p_decoded_evt->context.desc_uuid.uuid = uint16_decode(&p_evt_data[index]);
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc):    p_decoded_evt->context.desc_uuid.type = p_evt_data[index++];
Ble_rpc_event_encoder_gatts.c (nrf51822\source\ble\rpc):    index            += uint16_encode(p_evt_write->context.srvc_uuid.uuid, &p_buffer[index]);
Ble_rpc_event_encoder_gatts.c (nrf51822\source\ble\rpc):    p_buffer[index++] = p_evt_write->context.srvc_uuid.type;
Ble_rpc_event_encoder_gatts.c (nrf51822\source\ble\rpc):    index            += uint16_encode(p_evt_write->context.char_uuid.uuid, &p_buffer[index]);
Ble_rpc_event_encoder_gatts.c (nrf51822\source\ble\rpc):    p_buffer[index++] = p_evt_write->context.char_uuid.type;
Ble_rpc_event_encoder_gatts.c (nrf51822\source\ble\rpc):    index            += uint16_encode(p_evt_write->context.desc_uuid.uuid, &p_buffer[index]);
Ble_rpc_event_encoder_gatts.c (nrf51822\source\ble\rpc):    p_buffer[index++] = p_evt_write->context.desc_uuid.type;
Ble_rscs.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_rscs.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_RSC_MEASUREMENT_CHAR);
Ble_rscs.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_rscs.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_rscs.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_RSC_FEATURE_CHAR);
Ble_rscs.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_rscs.c (nrf51822\source\ble\ble_services):    ble_uuid_t ble_uuid;
Ble_rscs.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_RUNNING_SPEED_AND_CADENCE);
Ble_rscs.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_rscs->service_handle);
Ble_sc_ctrlpt.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_sc_ctrlpt.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_SC_CTRLPT_CHAR);
Ble_sc_ctrlpt.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_srv_common.h (nrf51822\include\ble\ble_services):/** @defgroup UUID_SERVICES Service UUID definitions
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_ALERT_NOTIFICATION_SERVICE                      0x1811     /**< Alert Notification service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_BATTERY_SERVICE                                 0x180F     /**< Battery service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_BLOOD_PRESSURE_SERVICE                          0x1810     /**< Blood Pressure service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_CURRENT_TIME_SERVICE                            0x1805     /**< Current Time service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_CYCLING_SPEED_AND_CADENCE                       0x1816     /**< Cycling Speed and Cadence service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_DEVICE_INFORMATION_SERVICE                      0x180A     /**< Device Information service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_GLUCOSE_SERVICE                                 0x1808     /**< Glucose service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_HEALTH_THERMOMETER_SERVICE                      0x1809     /**< Health Thermometer service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_HEART_RATE_SERVICE                              0x180D     /**< Heart Rate service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_HUMAN_INTERFACE_DEVICE_SERVICE                  0x1812     /**< Human Interface Device service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_IMMEDIATE_ALERT_SERVICE                         0x1802     /**< Immediate Alert service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_LINK_LOSS_SERVICE                               0x1803     /**< Link Loss service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_NEXT_DST_CHANGE_SERVICE                         0x1807     /**< Next Dst Change service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_PHONE_ALERT_STATUS_SERVICE                      0x180E     /**< Phone Alert Status service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_REFERENCE_TIME_UPDATE_SERVICE                   0x1806     /**< Reference Time Update service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_RUNNING_SPEED_AND_CADENCE                       0x1814     /**< Running Speed and Cadence service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_SCAN_PARAMETERS_SERVICE                         0x1813     /**< Scan Parameters service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_TX_POWER_SERVICE                                0x1804     /**< TX Power service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):/** @defgroup UUID_CHARACTERISTICS Characteristic UUID definitions
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_BATTERY_LEVEL_STATE_CHAR                        0x2A1B     /**< Battery Level State characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_BATTERY_POWER_STATE_CHAR                        0x2A1A     /**< Battery Power State characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_REMOVABLE_CHAR                                  0x2A3A     /**< Removable characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_SERVICE_REQUIRED_CHAR                           0x2A3B     /**< Service Required characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_ALERT_CATEGORY_ID_CHAR                          0x2A43     /**< Alert Category Id characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_ALERT_CATEGORY_ID_BIT_MASK_CHAR                 0x2A42     /**< Alert Category Id Bit Mask characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_ALERT_LEVEL_CHAR                                0x2A06     /**< Alert Level characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_ALERT_NOTIFICATION_CONTROL_POINT_CHAR           0x2A44     /**< Alert Notification Control Point characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_ALERT_STATUS_CHAR                               0x2A3F     /**< Alert Status characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_BATTERY_LEVEL_CHAR                              0x2A19     /**< Battery Level characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_BLOOD_PRESSURE_FEATURE_CHAR                     0x2A49     /**< Blood Pressure Feature characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_BLOOD_PRESSURE_MEASUREMENT_CHAR                 0x2A35     /**< Blood Pressure Measurement characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_BODY_SENSOR_LOCATION_CHAR                       0x2A38     /**< Body Sensor Location characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_BOOT_KEYBOARD_INPUT_REPORT_CHAR                 0x2A22     /**< Boot Keyboard Input Report characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_BOOT_KEYBOARD_OUTPUT_REPORT_CHAR                0x2A32     /**< Boot Keyboard Output Report characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_BOOT_MOUSE_INPUT_REPORT_CHAR                    0x2A33     /**< Boot Mouse Input Report characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_CURRENT_TIME_CHAR                               0x2A2B     /**< Current Time characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_DATE_TIME_CHAR                                  0x2A08     /**< Date Time characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_DAY_DATE_TIME_CHAR                              0x2A0A     /**< Day Date Time characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_DAY_OF_WEEK_CHAR                                0x2A09     /**< Day Of Week characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_DST_OFFSET_CHAR                                 0x2A0D     /**< Dst Offset characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_EXACT_TIME_256_CHAR                             0x2A0C     /**< Exact Time 256 characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_FIRMWARE_REVISION_STRING_CHAR                   0x2A26     /**< Firmware Revision String characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_GLUCOSE_FEATURE_CHAR                            0x2A51     /**< Glucose Feature characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_GLUCOSE_MEASUREMENT_CHAR                        0x2A18     /**< Glucose Measurement characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_GLUCOSE_MEASUREMENT_CONTEXT_CHAR                0x2A34     /**< Glucose Measurement Context characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_HARDWARE_REVISION_STRING_CHAR                   0x2A27     /**< Hardware Revision String characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_HEART_RATE_CONTROL_POINT_CHAR                   0x2A39     /**< Heart Rate Control Point characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_HEART_RATE_MEASUREMENT_CHAR                     0x2A37     /**< Heart Rate Measurement characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_HID_CONTROL_POINT_CHAR                          0x2A4C     /**< Hid Control Point characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_HID_INFORMATION_CHAR                            0x2A4A     /**< Hid Information characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_IEEE_REGULATORY_CERTIFICATION_DATA_LIST_CHAR    0x2A2A     /**< IEEE Regulatory Certification Data List characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_INTERMEDIATE_CUFF_PRESSURE_CHAR                 0x2A36     /**< Intermediate Cuff Pressure characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_INTERMEDIATE_TEMPERATURE_CHAR                   0x2A1E     /**< Intermediate Temperature characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_LOCAL_TIME_INFORMATION_CHAR                     0x2A0F     /**< Local Time Information characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_MANUFACTURER_NAME_STRING_CHAR                   0x2A29     /**< Manufacturer Name String characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_MEASUREMENT_INTERVAL_CHAR                       0x2A21     /**< Measurement Interval characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_MODEL_NUMBER_STRING_CHAR                        0x2A24     /**< Model Number String characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_UNREAD_ALERT_CHAR                               0x2A45     /**< Unread Alert characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_NEW_ALERT_CHAR                                  0x2A46     /**< New Alert characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_PNP_ID_CHAR                                     0x2A50     /**< PNP Id characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_PROTOCOL_MODE_CHAR                              0x2A4E     /**< Protocol Mode characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_RECORD_ACCESS_CONTROL_POINT_CHAR                0x2A52     /**< Record Access Control Point characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_REFERENCE_TIME_INFORMATION_CHAR                 0x2A14     /**< Reference Time Information characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_REPORT_CHAR                                     0x2A4D     /**< Report characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_REPORT_MAP_CHAR                                 0x2A4B     /**< Report Map characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_RINGER_CONTROL_POINT_CHAR                       0x2A40     /**< Ringer Control Point characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_RINGER_SETTING_CHAR                             0x2A41     /**< Ringer Setting characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_SCAN_INTERVAL_WINDOW_CHAR                       0x2A4F     /**< Scan Interval Window characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_SCAN_REFRESH_CHAR                               0x2A31     /**< Scan Refresh characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_SERIAL_NUMBER_STRING_CHAR                       0x2A25     /**< Serial Number String characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_SOFTWARE_REVISION_STRING_CHAR                   0x2A28     /**< Software Revision String characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_SUPPORTED_NEW_ALERT_CATEGORY_CHAR               0x2A47     /**< Supported New Alert Category characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_SUPPORTED_UNREAD_ALERT_CATEGORY_CHAR            0x2A48     /**< Supported Unread Alert Category characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_SYSTEM_ID_CHAR                                  0x2A23     /**< System Id characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_TEMPERATURE_MEASUREMENT_CHAR                    0x2A1C     /**< Temperature Measurement characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_TEMPERATURE_TYPE_CHAR                           0x2A1D     /**< Temperature Type characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_TIME_ACCURACY_CHAR                              0x2A12     /**< Time Accuracy characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_TIME_SOURCE_CHAR                                0x2A13     /**< Time Source characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_TIME_UPDATE_CONTROL_POINT_CHAR                  0x2A16     /**< Time Update Control Point characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_TIME_UPDATE_STATE_CHAR                          0x2A17     /**< Time Update State characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_TIME_WITH_DST_CHAR                              0x2A11     /**< Time With Dst characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_TIME_ZONE_CHAR                                  0x2A0E     /**< Time Zone characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_TX_POWER_LEVEL_CHAR                             0x2A07     /**< TX Power Level characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_CSC_FEATURE_CHAR                                0x2A5C     /**< Cycling Speed and Cadence Feature characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_CSC_MEASUREMENT_CHAR                            0x2A5B     /**< Cycling Speed and Cadence Measurement characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_RSC_FEATURE_CHAR                                0x2A54     /**< Running Speed and Cadence Feature characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_SC_CTRLPT_CHAR                                  0x2A55     /**< Speed and Cadence Control Point UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_RSC_MEASUREMENT_CHAR                            0x2A53     /**< Running Speed and Cadence Measurement characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_SENSOR_LOCATION_CHAR                            0x2A5D     /**< Sensor Location characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):/** @defgroup UUID_CHARACTERISTICS Characteristic UUID definitions
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_EXTERNAL_REPORT_REF_DESCR                       0x2907     /**< External Report Reference descriptor UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_REPORT_REF_DESCR                                0x2908     /**< Report Reference descriptor UUID. */
Ble_tps.c (nrf51822\source\ble\ble_services):    ble_uuid_t          ble_uuid;
Ble_tps.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_TX_POWER_LEVEL_CHAR);
Ble_tps.c (nrf51822\source\ble\ble_services):    attr_char_value.p_uuid       = &ble_uuid;
Ble_tps.c (nrf51822\source\ble\ble_services):    ble_uuid_t ble_uuid;
Ble_tps.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_TX_POWER_SERVICE);
Ble_tps.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_tps->service_handle);
Ble_types.h (nrf51822\include\ble\softdevice):/** @defgroup BLE_UUID_VALUES Assigned Values for BLE UUIDs
Ble_types.h (nrf51822\include\ble\softdevice):/* Generic UUIDs, applicable to all services */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_UNKNOWN                              0x0000 /**< Reserved UUID. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_SERVICE_PRIMARY                      0x2800 /**< Primary Service. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_SERVICE_SECONDARY                    0x2801 /**< Secondary Service. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_SERVICE_INCLUDE                      0x2802 /**< Include. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_CHARACTERISTIC                       0x2803 /**< Characteristic. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_DESCRIPTOR_CHAR_EXT_PROP             0x2900 /**< Characteristic Extended Properties Descriptor. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_DESCRIPTOR_CHAR_USER_DESC            0x2901 /**< Characteristic User Description Descriptor. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_DESCRIPTOR_CLIENT_CHAR_CONFIG        0x2902 /**< Client Characteristic Configuration Descriptor. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_DESCRIPTOR_SERVER_CHAR_CONFIG        0x2903 /**< Server Characteristic Configuration Descriptor. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_DESCRIPTOR_CHAR_PRESENTATION_FORMAT  0x2904 /**< Characteristic Presentation Format Descriptor. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_DESCRIPTOR_CHAR_AGGREGATE_FORMAT     0x2905 /**< Characteristic Aggregate Format Descriptor. */
Ble_types.h (nrf51822\include\ble\softdevice):/* GATT specific UUIDs */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_GATT                                 0x1801 /**< Generic Attribute Profile. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_GATT_CHARACTERISTIC_SERVICE_CHANGED  0x2A05 /**< Service Changed Characteristic. */
Ble_types.h (nrf51822\include\ble\softdevice):/* GAP specific UUIDs */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_GAP                                  0x1800 /**< Generic Access Profile. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_GAP_CHARACTERISTIC_DEVICE_NAME       0x2A00 /**< Device Name Characteristic. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_GAP_CHARACTERISTIC_APPEARANCE        0x2A01 /**< Appearance Characteristic. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_GAP_CHARACTERISTIC_PPF               0x2A02 /**< Peripheral Privacy Flag Characteristic. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_GAP_CHARACTERISTIC_RECONN_ADDR       0x2A03 /**< Reconnection Address Characteristic. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_GAP_CHARACTERISTIC_PPCP              0x2A04 /**< Peripheral Preferred Connection Parameters Characteristic. */
Ble_types.h (nrf51822\include\ble\softdevice):/** @defgroup BLE_UUID_TYPES Types of UUID
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_TYPE_UNKNOWN       0x00 /**< Invalid UUID type. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_TYPE_BLE           0x01 /**< Bluetooth SIG UUID (16-bit). */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_TYPE_VENDOR_BEGIN  0x02 /**< Vendor UUID types start at this index (128-bit). */
Ble_types.h (nrf51822\include\ble\softdevice):/** @brief Set .type and .uuid fields of ble_uuid_struct to specified uuid value. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_BLE_ASSIGN(instance, value) do {\
Ble_types.h (nrf51822\include\ble\softdevice):            instance.type = BLE_UUID_TYPE_BLE; \
Ble_types.h (nrf51822\include\ble\softdevice):            instance.uuid = value;} while(0)
Ble_types.h (nrf51822\include\ble\softdevice):/** @brief Copy type and uuid members from src to dst ble_uuid_t pointer. Both pointers must be valid/non-null. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_COPY_PTR(dst, src) do {\
Ble_types.h (nrf51822\include\ble\softdevice):            (dst)->uuid = (src)->uuid;} while(0)
Ble_types.h (nrf51822\include\ble\softdevice):/** @brief Copy type and uuid members from src to dst ble_uuid_t struct. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_COPY_INST(dst, src) do {\
Ble_types.h (nrf51822\include\ble\softdevice):            (dst).uuid = (src).uuid;} while(0)
Ble_types.h (nrf51822\include\ble\softdevice):/** @brief Compare for equality both type and uuid members of two (valid, non-null) ble_uuid_t pointers. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_EQ(p_uuid1, p_uuid2) \
Ble_types.h (nrf51822\include\ble\softdevice):            (((p_uuid1)->type == (p_uuid2)->type) && ((p_uuid1)->uuid == (p_uuid2)->uuid))
Ble_types.h (nrf51822\include\ble\softdevice):/** @brief Compare for difference both type and uuid members of two (valid, non-null) ble_uuid_t pointers. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_NEQ(p_uuid1, p_uuid2) \
Ble_types.h (nrf51822\include\ble\softdevice):            (((p_uuid1)->type != (p_uuid2)->type) || ((p_uuid1)->uuid != (p_uuid2)->uuid))
Ble_types.h (nrf51822\include\ble\softdevice):/** @brief 128 bit UUID values. */
Ble_types.h (nrf51822\include\ble\softdevice):    unsigned char uuid128[16];
Ble_types.h (nrf51822\include\ble\softdevice):} ble_uuid128_t;
Ble_types.h (nrf51822\include\ble\softdevice):/** @brief  Bluetooth Low Energy UUID type, encapsulates both 16-bit and 128-bit UUIDs. */
Ble_types.h (nrf51822\include\ble\softdevice):    uint16_t    uuid; /**< 16-bit UUID value or octets 12-13 of 128-bit UUID. */
Ble_types.h (nrf51822\include\ble\softdevice):    uint8_t     type; /**< UUID type, see @ref BLE_UUID_TYPES. */
Ble_types.h (nrf51822\include\ble\softdevice):} ble_uuid_t;
Main.c (source\src):    advdata.uuids_complete.uuid_cnt = 0;
Main.c (source\src):    advdata.uuids_complete.p_uuids  = NULL;
Main.c (source\src):    advdata.uuids_more_available.uuid_cnt = 0;
Main.c (source\src):    advdata.uuids_solicited.uuid_cnt = 0;
---- ble_nus_send_string Matches (5 in 4 files) ----
Bd_ble_nus.c (source\src):uint32_t ble_nus_send_string(ble_nus_t * p_nus, uint8_t * string, uint16_t *length)
Bd_ble_nus.h (source\inc):uint32_t ble_nus_send_string(ble_nus_t * p_nus, uint8_t * string, uint16_t *length);
Bd_communicate_protocol.c (source\src):            error_code = ble_nus_send_string(&m_nus,currentSendPointer,&sendLen);
Bd_communicate_protocol.c (source\src):        error_code = ble_nus_send_string(&m_nus,currentSendPointer,&sendLen);
Bd_sync_data.c (source\src):        //ble_nus_send_string(&m_nus,(uint8_t *) p_address,&len);
---- BLUETOOTH_DEV_CLASS Matches (2 in 1 files) ----
Ble_advdata.c (nrf51822\source\ble):#define BLUETOOTH_DEV_CLASS (0x704)
Ble_advdata.c (nrf51822\source\ble):    (*p_len) += uint16_encode(BLUETOOTH_DEV_CLASS, &p_encoded_data[*p_len]);
---- global_dev_loss_control.controller.alert_level Matches (2 in 1 files) ----
Bd_data_manager.c (source\src):    global_dev_loss_control.controller.alert_level = (uint8_t) alert_level;
Bd_data_manager.c (source\src):    return (DEV_LOSS_ALERT_LEVEL)global_dev_loss_control.controller.alert_level;
---- ad Matches (7047 in 224 files) ----
Adns2080.c (nrf51822\source\ext_sensors\adns2080): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Adns2080.c (nrf51822\source\ext_sensors\adns2080):#include "adns2080.h"
Adns2080.c (nrf51822\source\ext_sensors\adns2080):#define ADNS2080_PRODUCT_ID (0x2AU) /*!< ADNS2080 product id */
Adns2080.c (nrf51822\source\ext_sensors\adns2080):#define ADNS2080_RESET_NUMBER (0x5AU) /*!< ADNS2080 reset code */
Adns2080.c (nrf51822\source\ext_sensors\adns2080):/* ADNS2080 register addresses */
Adns2080.c (nrf51822\source\ext_sensors\adns2080):#define REG_BURST_READ_FIRST (0x42U) /*!< Burst Read Starting Register. Default value : 0x03 */
Adns2080.c (nrf51822\source\ext_sensors\adns2080):#define REG_BURST_READ_LAST (0x44U) /*!< Burst Read Ending Register. Default value : 0x09 */
Adns2080.c (nrf51822\source\ext_sensors\adns2080):#define REG_MOTION_BURST (0x63U) /*!< Burst Read. Default value : 0x00 */
Adns2080.c (nrf51822\source\ext_sensors\adns2080):/* ADNS2080 register bits */
Adns2080.c (nrf51822\source\ext_sensors\adns2080):void adns2080_movement_read(int16_t *deltaX, int16_t *deltaY)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  delta_x = sdio_read_byte(REG_DELTA_X);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  delta_y = sdio_read_byte(REG_DELTA_Y);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  if (adns2080_motion_bits_read() == ADNS2080_MOTION_BITS_12)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):    delta_xy_high = sdio_read_byte(REG_DELTA_XY_HIGH);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):adns2080_motion_bits_t adns2080_motion_bits_read(void)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  /* Read the most significant bit */
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  return (adns2080_motion_bits_t)((sdio_read_byte(REG_MOUSE_CTRL) >> 7) & 0x01);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):bool adns2080_is_motion_detected(void)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  return ((sdio_read_byte(REG_MOTION_ST) & 0x80) != 0);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):uint8_t adns2080_product_id_read(void)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  return sdio_read_byte(REG_PROD_ID);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):uint8_t adns2080_revision_id_read(void)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  return sdio_read_byte(REG_REV_ID);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):adns2080_status_t adns2080_init(void)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  adns2080_reset();
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  if (adns2080_product_id_read() != ADNS2080_PRODUCT_ID)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):    return ADNS2080_CHIP_NOT_DETECTED;
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  sdio_write_byte(REG_BURST_READ_FIRST, REG_DELTA_X);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  sdio_write_byte(REG_BURST_READ_LAST, REG_DELTA_Y);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  return ADNS2080_OK;
Adns2080.c (nrf51822\source\ext_sensors\adns2080):void adns2080_reset(void)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  sdio_write_byte(REG_RESET, ADNS2080_RESET_NUMBER);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):void adns2080_powerdown(void)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):void adns2080_wakeup(void)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  adns2080_reset();
Adns2080.c (nrf51822\source\ext_sensors\adns2080):adns2080_status_t adns2080_motion_interrupt_set(motion_output_polarity_t polarity, motion_output_sensitivity_t sensitivity)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  adns2080_status_t status = ADNS2080_OK;
Adns2080.c (nrf51822\source\ext_sensors\adns2080):    case ADNS2080_MOTION_OUTPUT_POLARITY_LOW:
Adns2080.c (nrf51822\source\ext_sensors\adns2080):    case ADNS2080_MOTION_OUTPUT_POLARITY_HIGH:
Adns2080.c (nrf51822\source\ext_sensors\adns2080):      status = ADNS2080_INVALID_PARAMETER;
Adns2080.c (nrf51822\source\ext_sensors\adns2080):    case ADNS2080_MOTION_OUTPUT_SENSITIVITY_LEVEL:
Adns2080.c (nrf51822\source\ext_sensors\adns2080):    case ADNS2080_MOTION_OUTPUT_SENSITIVITY_EDGE:
Adns2080.c (nrf51822\source\ext_sensors\adns2080):      status = ADNS2080_INVALID_PARAMETER;
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  if (status == ADNS2080_OK)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):adns2080_status_t adns2080_resolution_set(adns2080_resolution_t resolution)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  uint8_t databyte = sdio_read_byte(REG_MOUSE_CTRL);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  adns2080_status_t status = ADNS2080_OK;
Adns2080.c (nrf51822\source\ext_sensors\adns2080):    case ADNS2080_RESOLUTION_250DPI:
Adns2080.c (nrf51822\source\ext_sensors\adns2080):    case ADNS2080_RESOLUTION_500DPI:
Adns2080.c (nrf51822\source\ext_sensors\adns2080):    case ADNS2080_RESOLUTION_1000DPI:
Adns2080.c (nrf51822\source\ext_sensors\adns2080):    case ADNS2080_RESOLUTION_1250DPI:
Adns2080.c (nrf51822\source\ext_sensors\adns2080):    case ADNS2080_RESOLUTION_1500DPI:
Adns2080.c (nrf51822\source\ext_sensors\adns2080):    case ADNS2080_RESOLUTION_1750DPI:
Adns2080.c (nrf51822\source\ext_sensors\adns2080):    case ADNS2080_RESOLUTION_2000DPI:
Adns2080.c (nrf51822\source\ext_sensors\adns2080):      status = ADNS2080_INVALID_PARAMETER;
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  if (status == ADNS2080_OK)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):adns2080_status_t adns2080_motion_bits_set(adns2080_motion_bits_t motion_bits)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  uint8_t databyte = sdio_read_byte(REG_MOUSE_CTRL);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  adns2080_status_t status = ADNS2080_OK;
Adns2080.c (nrf51822\source\ext_sensors\adns2080):    case ADNS2080_MOTION_BITS_8:
Adns2080.c (nrf51822\source\ext_sensors\adns2080):    case ADNS2080_MOTION_BITS_12:
Adns2080.c (nrf51822\source\ext_sensors\adns2080):      status = ADNS2080_INVALID_PARAMETER;
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  if (status == ADNS2080_OK)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):void adns2080_rest_periods_set(uint8_t rest1_period, uint8_t rest2_period, uint8_t rest3_period)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  adns2080_mode_t current_mode = adns2080_force_mode_read();
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  adns2080_force_mode_set(ADNS2080_MODE_RUN1);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  adns2080_force_mode_set(current_mode);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):void adns2080_downshift_times_set(uint8_t run_to_rest1_mode_time, uint8_t rest1_to_rest2_mode_time, uint8_t rest2_to_rest3_mode_time)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  adns2080_mode_t current_mode = adns2080_force_mode_read();
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  adns2080_force_mode_set(ADNS2080_MODE_RUN1);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  adns2080_force_mode_set(current_mode);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):adns2080_mode_t adns2080_force_mode_read(void)
Adns2080.c (nrf51822\source\ext_sensors\adns2080):  return (adns2080_mode_t)((sdio_read_byte(REG_PERFORMANCE) >> 4) & 0x07);
Adns2080.c (nrf51822\source\ext_sensors\adns2080):void adns2080_force_mode_set(adns2080_mode_t mode)
Adns2080.h (nrf51822\include\ext_sensors): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Adns2080.h (nrf51822\include\ext_sensors):#ifndef ADNS2080_H
Adns2080.h (nrf51822\include\ext_sensors):#define ADNS2080_H
Adns2080.h (nrf51822\include\ext_sensors):* @brief ADNS2080 mouse sensor driver
Adns2080.h (nrf51822\include\ext_sensors):* @defgroup nrf_drivers_adns2080 ADNS2080 driver
Adns2080.h (nrf51822\include\ext_sensors):* @brief ADNS2080 mouse sensor driver.
Adns2080.h (nrf51822\include\ext_sensors): * Describes return values for @ref adns2080_init.
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_OK, /*!< Operation was succesful */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_SERIAL_COMM_FAILURE, /*!< Serial communication failed */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_CHIP_NOT_DETECTED, /*!< Product/Revision ID was not what was expected */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_INVALID_PARAMETER /*!< Given parameters were not valid */
Adns2080.h (nrf51822\include\ext_sensors):} adns2080_status_t;
Adns2080.h (nrf51822\include\ext_sensors): * ADNS2080 motion output pin polarity values.
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_MOTION_OUTPUT_POLARITY_LOW = 0,  /*!< Motion output polarity active low */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_MOTION_OUTPUT_POLARITY_HIGH = 1  /*!< Motion output polarity active high */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_MOTION_OUTPUT_SENSITIVITY_LEVEL = 0,  /*!< Motion output pin will be driven low/high (depending on the polarity setting) as long as there is motion data in DELTA registers */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_MOTION_OUTPUT_SENSITIVITY_EDGE = 1  /*!< Motion output pin will be driven low/high (depending on the polarity setting) for 380 ns when motion is detected during rest modes */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_RESOLUTION_250DPI = 1, /*!< 250 dpi resolution */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_RESOLUTION_500DPI = 2, /*!< 500 dpi resolution */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_RESOLUTION_1000DPI = 0, /*!< 1000 dpi resolution */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_RESOLUTION_1250DPI = 3, /*!< 1250 dpi resolution */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_RESOLUTION_1500DPI = 4, /*!< 1500 dpi resolution */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_RESOLUTION_1750DPI = 5, /*!< 1750 dpi resolution */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_RESOLUTION_2000DPI = 6 /*!< 2000 dpi resolution */
Adns2080.h (nrf51822\include\ext_sensors):} adns2080_resolution_t;
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_MODE_NORMAL = 0, /*!< Normal operation mode */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_MODE_REST1 = 1, /*!< Rest1 operation mode */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_MODE_REST2 = 2, /*!< Rest2 operation mode */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_MODE_REST3 = 3, /*!< Rest3 operation mode */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_MODE_RUN1 = 4, /*!< Run1 operation mode */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_MODE_RUN2 = 5, /*!< Run2 operation mode */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_MODE_IDLE = 6 /*!< Idle operation mode */
Adns2080.h (nrf51822\include\ext_sensors):} adns2080_mode_t;
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_MOTION_BITS_8 = 0,  /*!< Motion reporting uses 8 bits */
Adns2080.h (nrf51822\include\ext_sensors):  ADNS2080_MOTION_BITS_12 = 1  /*!< Motion reporting uses 12 bits */
Adns2080.h (nrf51822\include\ext_sensors):} adns2080_motion_bits_t;
Adns2080.h (nrf51822\include\ext_sensors): * @retval ADNS2080_OK Mouse sensor was initialized succesfully.
Adns2080.h (nrf51822\include\ext_sensors): * @retval ADNS2080_SERIAL_COMM_FAILURE Serial communications failure.
Adns2080.h (nrf51822\include\ext_sensors): * @retval ADNS2080_CHIP_NOT_DETECTED Could not find revision 0 ADNS2080 chip.
Adns2080.h (nrf51822\include\ext_sensors):adns2080_status_t adns2080_init(void);
Adns2080.h (nrf51822\include\ext_sensors): * All register settings will be lost and need to be reloaded.
Adns2080.h (nrf51822\include\ext_sensors):void adns2080_reset(void);
Adns2080.h (nrf51822\include\ext_sensors): * @brief Function for reading mouse sensor product ID.
Adns2080.h (nrf51822\include\ext_sensors):uint8_t adns2080_product_id_read(void);
Adns2080.h (nrf51822\include\ext_sensors): * @brief Function for reading mouse sensor revision ID.
Adns2080.h (nrf51822\include\ext_sensors):uint8_t adns2080_revision_id_read(void); // also note there is "not rev id" register
Adns2080.h (nrf51822\include\ext_sensors): * down mode, @ref adns2080_wakeup must be called.
Adns2080.h (nrf51822\include\ext_sensors):void adns2080_powerdown(void);
Adns2080.h (nrf51822\include\ext_sensors): * After wakeup, all mouse sensor settings must be reloaded. Valid mouse sensor 
Adns2080.h (nrf51822\include\ext_sensors):void adns2080_wakeup(void);
Adns2080.h (nrf51822\include\ext_sensors): * @retval ADNS2080_OK Operation succeeded.
Adns2080.h (nrf51822\include\ext_sensors): * @retval ADNS2080_INVALID_PARAMETER One of the parameters was not within valid range.
Adns2080.h (nrf51822\include\ext_sensors):adns2080_status_t adns2080_motion_interrupt_set(motion_output_polarity_t polarity, motion_output_sensitivity_t sensitivity);
Adns2080.h (nrf51822\include\ext_sensors): * @retval ADNS2080_OK Operation succeeded.
Adns2080.h (nrf51822\include\ext_sensors): * @retval ADNS2080_INVALID_PARAMETER One of the parameters was not within valid range.
Adns2080.h (nrf51822\include\ext_sensors):adns2080_status_t adns2080_resolution_set(adns2080_resolution_t resolution);
Adns2080.h (nrf51822\include\ext_sensors): * @retval ADNS2080_OK Operation succeeded.
Adns2080.h (nrf51822\include\ext_sensors): * @retval ADNS2080_INVALID_PARAMETER One of the parameters was not within valid range.
Adns2080.h (nrf51822\include\ext_sensors):adns2080_status_t adns2080_motion_bits_set(adns2080_motion_bits_t motion_bits);
Adns2080.h (nrf51822\include\ext_sensors): * @brief Function for reading number of bits used for mouse sensor motion reporting.
Adns2080.h (nrf51822\include\ext_sensors):adns2080_motion_bits_t adns2080_motion_bits_read(void);
Adns2080.h (nrf51822\include\ext_sensors): * @brief Function for reading X- and Y-axis movement (in counts) since last report.
Adns2080.h (nrf51822\include\ext_sensors):void adns2080_movement_read(int16_t *p_delta_x, int16_t *p_delta_y);
Adns2080.h (nrf51822\include\ext_sensors):bool adns2080_is_motion_detected(void);
Adns2080.h (nrf51822\include\ext_sensors):void adns2080_rest_periods_set(uint8_t rest1_period, uint8_t rest2_period, uint8_t rest3_period);
Adns2080.h (nrf51822\include\ext_sensors):void adns2080_downshift_times_set(uint8_t run_to_rest1_mode_time, uint8_t rest1_to_rest2_mode_time, uint8_t rest2_to_rest3_mode_time);
Adns2080.h (nrf51822\include\ext_sensors): * Normal operation will not continue until this function is called with ADNS2080_MODE_NORMAL parameter.
Adns2080.h (nrf51822\include\ext_sensors):void adns2080_force_mode_set(adns2080_mode_t mode);
Adns2080.h (nrf51822\include\ext_sensors): * @brief Function for reading the current forced operating mode.
Adns2080.h (nrf51822\include\ext_sensors):adns2080_mode_t adns2080_force_mode_read(void);
App_button.c (nrf51822\source\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
App_button.c (nrf51822\source\app_common): * @details Saves the current status of the button pins, and starts a timer. If the timer is already
App_button.c (nrf51822\source\app_common): * @param[in]  event_pins_low_to_high   Mask telling which pin(s) had a low to high transition.
App_button.c (nrf51822\source\app_common): * @param[in]  event_pins_high_to_low   Mask telling which pin(s) had a high to low transition.
App_button.c (nrf51822\source\app_common):    // Start detection timer. If timer is already running, the detection period is restarted.
App_button.h (nrf51822\include\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
App_button.h (nrf51822\include\app_common): * @retval     NRF_SUCCESS               State successfully read.
App_error.h (nrf51822\include\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
App_fifo.c (nrf51822\source\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
App_fifo.c (nrf51822\source\app_common):#define FIFO_LENGTH (p_fifo->write_pos - p_fifo->read_pos)  /**< Macro for calculating the FIFO length. */
App_fifo.c (nrf51822\source\app_common):    p_fifo->read_pos      = 0;
App_fifo.c (nrf51822\source\app_common):        *p_byte = p_fifo->p_buf[p_fifo->read_pos & p_fifo->buf_size_mask];
App_fifo.c (nrf51822\source\app_common):        p_fifo->read_pos++;
App_fifo.c (nrf51822\source\app_common):    p_fifo->read_pos = p_fifo->write_pos;
App_fifo.h (nrf51822\include\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
App_fifo.h (nrf51822\include\app_common):/**@brief A FIFO instance structure. Keeps track of which bytes to read and write next.
App_fifo.h (nrf51822\include\app_common):    uint16_t           buf_size_mask;   /**< Read/write index mask. Also used for size checking. */
App_fifo.h (nrf51822\include\app_common):    volatile uint32_t  read_pos;        /**< Next read position in the FIFO buffer.              */
App_fifo.h (nrf51822\include\app_common):/**@brief Function for adding an element to the FIFO.
App_fifo.h (nrf51822\include\app_common): * @param[in]  byte     Data byte to add to the FIFO.
App_fifo.h (nrf51822\include\app_common): * @retval     NRF_SUCCESS              If an element has been successfully added to the FIFO.
App_gpiote.c (nrf51822\source\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
App_gpiote.h (nrf51822\include\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
App_scheduler.c (nrf51822\source\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
App_scheduler.c (nrf51822\source\app_common):/**@brief Structure for holding a scheduled event header. */
App_scheduler.c (nrf51822\source\app_common):} event_header_t;
App_scheduler.c (nrf51822\source\app_common):STATIC_ASSERT(sizeof(event_header_t) <= APP_SCHED_EVENT_HEADER_SIZE);
App_scheduler.c (nrf51822\source\app_common):static event_header_t * m_queue_event_headers;              /**< Array for holding the queue event headers. */
App_scheduler.c (nrf51822\source\app_common):    uint16_t data_start_index = (queue_size + 1) * sizeof(event_header_t);
App_scheduler.c (nrf51822\source\app_common):    m_queue_event_headers = p_event_buffer;
App_scheduler.c (nrf51822\source\app_common):            m_queue_event_headers[event_index].handler = handler;
App_scheduler.c (nrf51822\source\app_common):                m_queue_event_headers[event_index].event_data_size = event_data_size;
App_scheduler.c (nrf51822\source\app_common):                m_queue_event_headers[event_index].event_data_size = 0;
App_scheduler.c (nrf51822\source\app_common):/**@brief Function for reading the next event from specified event queue.
App_scheduler.c (nrf51822\source\app_common):        *p_event_data_size = m_queue_event_headers[event_index].event_data_size;
App_scheduler.c (nrf51822\source\app_common):        *p_event_handler   = m_queue_event_headers[event_index].handler;
App_scheduler.h (nrf51822\include\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
App_scheduler.h (nrf51822\include\app_common):#define APP_SCHED_EVENT_HEADER_SIZE 8       /**< Size of app_scheduler.event_header_t (only for use inside APP_SCHED_BUF_SIZE()). */
App_scheduler.h (nrf51822\include\app_common):            (((EVENT_SIZE) + APP_SCHED_EVENT_HEADER_SIZE) * ((QUEUE_SIZE) + 1))
App_timer.c (nrf51822\source\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
App_timer.c (nrf51822\source\app_common):// If this is to be changed, protection must be added to prevent them from interrupting each other
App_timer.c (nrf51822\source\app_common):#define THREAD_MODE_USER_ID     2                                           /**< User Id for the Thread Mode "user". */
App_timer.c (nrf51822\source\app_common): *          each interrupt level available to the application (APP_HIGH, APP_LOW and THREAD_MODE),
App_timer.c (nrf51822\source\app_common):static app_timer_id_t                m_timer_id_head;                           /**< First timer in list of running timers. */
App_timer.c (nrf51822\source\app_common):static uint8_t                       m_ticks_elapsed_q_read_ind;                /**< Timer internal elapsed ticks queue read index. */
App_timer.c (nrf51822\source\app_common):    if (m_timer_id_head == TIMER_NULL)
App_timer.c (nrf51822\source\app_common):        m_timer_id_head = timer_id;
App_timer.c (nrf51822\source\app_common):        if (p_timer->ticks_to_expire <= mp_nodes[m_timer_id_head].ticks_to_expire)
App_timer.c (nrf51822\source\app_common):            mp_nodes[m_timer_id_head].ticks_to_expire -= p_timer->ticks_to_expire;
App_timer.c (nrf51822\source\app_common):            p_timer->next   = m_timer_id_head;
App_timer.c (nrf51822\source\app_common):            m_timer_id_head = timer_id;
App_timer.c (nrf51822\source\app_common):            previous        = m_timer_id_head;
App_timer.c (nrf51822\source\app_common):            current         = m_timer_id_head;
App_timer.c (nrf51822\source\app_common):    previous = m_timer_id_head;
App_timer.c (nrf51822\source\app_common):        m_timer_id_head = mp_nodes[m_timer_id_head].next;
App_timer.c (nrf51822\source\app_common):    if (m_timer_id_head != TIMER_NULL)
App_timer.c (nrf51822\source\app_common):        // Auto variable containing the head of timers expiring 
App_timer.c (nrf51822\source\app_common):        timer_id = m_timer_id_head;
App_timer.c (nrf51822\source\app_common):        if (m_ticks_elapsed_q_read_ind == m_ticks_elapsed_q_write_ind)
App_timer.c (nrf51822\source\app_common):            // The read index of the queue is equal to the write index. This means the new
App_timer.c (nrf51822\source\app_common): * @return     TRUE if elapsed ticks was read from queue, FALSE otherwise.
App_timer.c (nrf51822\source\app_common):    if (m_ticks_elapsed_q_read_ind != m_ticks_elapsed_q_write_ind)
App_timer.c (nrf51822\source\app_common):        m_ticks_elapsed_q_read_ind++;
App_timer.c (nrf51822\source\app_common):        if (m_ticks_elapsed_q_read_ind == CONTEXT_QUEUE_SIZE_MAX)
App_timer.c (nrf51822\source\app_common):            m_ticks_elapsed_q_read_ind = 0;
App_timer.c (nrf51822\source\app_common):        *p_ticks_elapsed = m_ticks_elapsed[m_ticks_elapsed_q_read_ind];
App_timer.c (nrf51822\source\app_common):    app_timer_id_t timer_id_old_head;
App_timer.c (nrf51822\source\app_common):    // Remember the old head, so as to decide if new compare needs to be set
App_timer.c (nrf51822\source\app_common):    timer_id_old_head = m_timer_id_head;
App_timer.c (nrf51822\source\app_common):                    while (m_timer_id_head != TIMER_NULL)
App_timer.c (nrf51822\source\app_common):                        timer_node_t * p_head = &mp_nodes[m_timer_id_head];
App_timer.c (nrf51822\source\app_common):                        p_head->is_running = false;
App_timer.c (nrf51822\source\app_common):                        m_timer_id_head    = p_head->next;
App_timer.c (nrf51822\source\app_common):    // Detect change in head of the list
App_timer.c (nrf51822\source\app_common):    return (m_timer_id_head != timer_id_old_head);
App_timer.c (nrf51822\source\app_common): * @param[out] p_restart_list_head   List of repeating timers to be restarted.
App_timer.c (nrf51822\source\app_common):                                   app_timer_id_t * p_restart_list_head)
App_timer.c (nrf51822\source\app_common):    while (m_timer_id_head != TIMER_NULL)
App_timer.c (nrf51822\source\app_common):        p_timer = &mp_nodes[m_timer_id_head];
App_timer.c (nrf51822\source\app_common):        // Remove the expired timer from head 
App_timer.c (nrf51822\source\app_common):        id_expired      = m_timer_id_head;
App_timer.c (nrf51822\source\app_common):        m_timer_id_head = p_timer->next;
App_timer.c (nrf51822\source\app_common):            p_timer->next                 = *p_restart_list_head;
App_timer.c (nrf51822\source\app_common):            *p_restart_list_head          = id_expired;
App_timer.c (nrf51822\source\app_common): * @param[in]  p_restart_list_head   List of repeating timers to be restarted.
App_timer.c (nrf51822\source\app_common):static bool list_insertions_handler(app_timer_id_t restart_list_head)
App_timer.c (nrf51822\source\app_common):    app_timer_id_t timer_id_old_head;
App_timer.c (nrf51822\source\app_common):    // Remember the old head, so as to decide if new compare needs to be set
App_timer.c (nrf51822\source\app_common):    timer_id_old_head = m_timer_id_head;
App_timer.c (nrf51822\source\app_common):        while ((restart_list_head != TIMER_NULL) || (p_user->first != p_user->last))
App_timer.c (nrf51822\source\app_common):            if (restart_list_head != TIMER_NULL)
App_timer.c (nrf51822\source\app_common):                id_start          = restart_list_head;
App_timer.c (nrf51822\source\app_common):                restart_list_head = p_timer->next;
App_timer.c (nrf51822\source\app_common):    return (m_timer_id_head != timer_id_old_head);
App_timer.c (nrf51822\source\app_common):static void compare_reg_update(app_timer_id_t timer_id_head_old)
App_timer.c (nrf51822\source\app_common):    // Setup the timeout for timers on the head of the list 
App_timer.c (nrf51822\source\app_common):    if (m_timer_id_head != TIMER_NULL)
App_timer.c (nrf51822\source\app_common):        uint32_t ticks_to_expire = mp_nodes[m_timer_id_head].ticks_to_expire;
App_timer.c (nrf51822\source\app_common):        if (timer_id_head_old == TIMER_NULL)
App_timer.c (nrf51822\source\app_common):            // No timers were already running, start RTC
App_timer.c (nrf51822\source\app_common):    app_timer_id_t restart_list_head = TIMER_NULL;
App_timer.c (nrf51822\source\app_common):    app_timer_id_t timer_id_head_old;
App_timer.c (nrf51822\source\app_common):    // Back up the previous known tick and previous list head
App_timer.c (nrf51822\source\app_common):    timer_id_head_old = m_timer_id_head;
App_timer.c (nrf51822\source\app_common):        expired_timers_handler(ticks_elapsed, ticks_previous, &restart_list_head);
App_timer.c (nrf51822\source\app_common):    if (list_insertions_handler(restart_list_head))
App_timer.c (nrf51822\source\app_common):        compare_reg_update(timer_id_head_old);
App_timer.c (nrf51822\source\app_common):    m_timer_id_head             = TIMER_NULL;
App_timer.c (nrf51822\source\app_common):    m_ticks_elapsed_q_read_ind  = 0;
App_timer.c (nrf51822\source\app_common):            ret = THREAD_MODE_USER_ID;
App_timer.h (nrf51822\include\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
App_timer.h (nrf51822\include\app_common): * @retval     NRF_ERROR_NO_MEM          Maximum number of timers has already been reached.
App_timer.h (nrf51822\include\app_common): * @note When calling this method on a timer which is already running, the second start operation
App_timer.h (nrf51822\include\app_common): * @retval     NRF_SUCCESS   Counter was successfully read.
App_uart.c (nrf51822\source\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
App_uart.c (nrf51822\source\app_common):#define FIFO_LENGTH(F)             (F.write_pos - F.read_pos)               /**< Macro to calculate length of a FIFO. */
App_uart.c (nrf51822\source\app_common):#define UART_INSTANCE_GPIOTE_BASE  0x00FF                                   /**< Define the base for UART instance ID when flow control is used. The userid from GPIOTE will be used with padded 0xFF at LSB for easy converting the instance id to GPIOTE id. */
App_uart.c (nrf51822\source\app_common):    UART_READY,                                                             /**< app_uart state ON, indicating CTS is high. */
App_uart.c (nrf51822\source\app_common):    ON_TX_READY,                                                            /**< Event: Data has been transmitted on the uart and line is available. */
App_uart.c (nrf51822\source\app_common):    m_current_state         = UART_READY;
App_uart.c (nrf51822\source\app_common): *       If no more data is available in the TX buffer, the state machine will enter UART_READY state.
App_uart.c (nrf51822\source\app_common):static void action_tx_ready()
App_uart.c (nrf51822\source\app_common):        case UART_READY:
App_uart.c (nrf51822\source\app_common):            m_current_state = UART_READY;
App_uart.c (nrf51822\source\app_common):/**@brief Function for the handling of the ON_TX_READY event.
App_uart.c (nrf51822\source\app_common):static void on_tx_ready(void)
App_uart.c (nrf51822\source\app_common):        case UART_READY:
App_uart.c (nrf51822\source\app_common):            action_tx_ready();
App_uart.c (nrf51822\source\app_common):    if (m_current_state == UART_READY)
App_uart.c (nrf51822\source\app_common):        case ON_TX_READY:
App_uart.c (nrf51822\source\app_common):            on_tx_ready();
App_uart.c (nrf51822\source\app_common):        // If this occurs, we must read the active pins in the GPIOTE module ourself.
App_uart.c (nrf51822\source\app_common):            // Pin reading was not possible, even though an event from GPIOTE was received that the
App_uart.c (nrf51822\source\app_common): * @details UART interrupt handler to process TX Ready when TXD is available, RX Ready when a byte
App_uart.c (nrf51822\source\app_common):        on_uart_event(ON_TX_READY);
App_uart.c (nrf51822\source\app_common):        m_current_state = UART_READY;
App_uart.c (nrf51822\source\app_common):        m_current_state = UART_READY;
App_uart.c (nrf51822\source\app_common):    if (m_current_state != UART_READY)
App_uart.h (nrf51822\include\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
App_uart.h (nrf51822\include\app_common): *          trigger an APP_UART_DATA_READY event. 
App_uart.h (nrf51822\include\app_common):    APP_UART_CONNECTED                      /**< State indicating that the UART is connected and ready to receive or transmit bytes. If flow control is disabled, the state will always be connected. */
App_uart.h (nrf51822\include\app_common): * @details The event type is used to indicate the type of additional information in the event
App_uart.h (nrf51822\include\app_common):    APP_UART_DATA_READY,                    /**< An event indicating that UART data has been received. The data is available in the FIFO and can be fetched using @ref app_uart_get. */
App_uart.h (nrf51822\include\app_common):        uint32_t        error_code;         /**< Field used if evt_type is: NRF_ERROR_x. Additional status/error code if the error event type is APP_UART_FIFO_ERROR. This error code refer to errors defined in nrf_error.h. */
App_uart.h (nrf51822\include\app_common):        uint8_t         value;              /**< Field used if evt_type is: NRF_ERROR_x. Additional status/error code if the error event type is APP_UART_FIFO_ERROR. This error code refer to errors defined in nrf_error.h. */
App_uart.h (nrf51822\include\app_common): *          If single instance usage is needed, the APP_UART_INIT() macro should be used instead.
App_uart.h (nrf51822\include\app_common): *          reception of the first byte which is added to the RX buffer.
App_uart.h (nrf51822\include\app_common): * @param[out] p_byte    Pointer to an address where next byte received on the UART will be copied.
App_uart.h (nrf51822\include\app_common): *          - UART_READY = CONNECTED
App_uart_fifo.c (nrf51822\source\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
App_uart_fifo.c (nrf51822\source\app_common):#define FIFO_LENGTH(F)             (F.write_pos - F.read_pos)               /**< Macro to calculate length of a FIFO. */
App_uart_fifo.c (nrf51822\source\app_common):#define UART_INSTANCE_GPIOTE_BASE  0x00FF                                   /**< Define the base for UART instance ID when flow control is used. The userid from GPIOTE will be used with padded 0xFF at LSB for easy converting the instance id to GPIOTE id. */
App_uart_fifo.c (nrf51822\source\app_common):    UART_READY,                                                             /**< app_uart state ON, indicating CTS is high. */
App_uart_fifo.c (nrf51822\source\app_common):    ON_TX_READY,                                                            /**< Event: Data has been transmitted on the uart and line is available. */
App_uart_fifo.c (nrf51822\source\app_common):static app_fifo_t                  m_tx_fifo;                               /**< TX FIFO buffer for storing data to be transmitted on the UART when TXD is ready. Data is put to the buffer on using app_uart_put(). */
App_uart_fifo.c (nrf51822\source\app_common):    m_current_state         = UART_READY;
App_uart_fifo.c (nrf51822\source\app_common): *       If no more data is available in the TX buffer, the state machine will enter UART_READY state.
App_uart_fifo.c (nrf51822\source\app_common):static void action_tx_ready()
App_uart_fifo.c (nrf51822\source\app_common):        case UART_READY:
App_uart_fifo.c (nrf51822\source\app_common):                m_current_state = UART_READY;
App_uart_fifo.c (nrf51822\source\app_common):/**@brief Function for the handling of the ON_TX_READY event.
App_uart_fifo.c (nrf51822\source\app_common):static void on_tx_ready(void)
App_uart_fifo.c (nrf51822\source\app_common):        case UART_READY:
App_uart_fifo.c (nrf51822\source\app_common):            action_tx_ready();
App_uart_fifo.c (nrf51822\source\app_common):    if (m_current_state == UART_READY)
App_uart_fifo.c (nrf51822\source\app_common):        case ON_TX_READY:
App_uart_fifo.c (nrf51822\source\app_common):            on_tx_ready();
App_uart_fifo.c (nrf51822\source\app_common):        // If this occurs, we must read the active pins in the GPIOTE module ourself.
App_uart_fifo.c (nrf51822\source\app_common):            // Pin reading was not possible, even though an event from GPIOTE was received that the
App_uart_fifo.c (nrf51822\source\app_common): * @details UART interrupt handler to process TX Ready when TXD is available, RX Ready when a byte
App_uart_fifo.c (nrf51822\source\app_common):            app_uart_event.evt_type = APP_UART_DATA_READY;
App_uart_fifo.c (nrf51822\source\app_common):            // Do nothing, only send event if first byte was added or overflow in FIFO occurred.
App_uart_fifo.c (nrf51822\source\app_common):        on_uart_event(ON_TX_READY);
App_uart_fifo.c (nrf51822\source\app_common):        m_current_state = UART_READY;
App_uart_fifo.c (nrf51822\source\app_common):        m_current_state = UART_READY;
App_util.h (nrf51822\include\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
App_util.h (nrf51822\include\app_common):#define NRF_APP_PRIORITY_THREAD    4                    /**< "Interrupt level" when running in Thread Mode. */
App_util.h (nrf51822\include\app_common): *       symbol static_assert_failed, making the error message more readable).
App_util.h (nrf51822\include\app_common): * @retval   APP_IRQ_PRIORITY_THREAD  We are running in Thread Mode.
App_util.h (nrf51822\include\app_common):        return NRF_APP_PRIORITY_THREAD;
App_util.h (nrf51822\include\app_common): *           load in the actual application is not accounted for!
Bd_battery.c (source\src): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Bd_battery.c (source\src):static app_sched_event_handler_t ad_event_handle = NULL;
Bd_battery.c (source\src):/**@brief ADC interrupt handler.
Bd_battery.c (source\src): * @details  This function will fetch the conversion result from the ADC, convert the value into
Bd_battery.c (source\src):void ADC_IRQHandler(void)
Bd_battery.c (source\src):    uint32_t adc_result = 0;
Bd_battery.c (source\src):    if (NRF_ADC->EVENTS_END != 0) {
Bd_battery.c (source\src):        NRF_ADC->EVENTS_END     = 0;
Bd_battery.c (source\src):        adc_result              = NRF_ADC->RESULT;
Bd_battery.c (source\src):        NRF_ADC->TASKS_STOP     = 1;
Bd_battery.c (source\src):        batt_lvl_in_milli_volts = ADC_RESULT_IN_MILLI_VOLTS(adc_result);
Bd_battery.c (source\src):        //when charging, battery voltage need adjust
Bd_battery.c (source\src):            batt_lvl_in_milli_volts -= BATTERY_VOLTAGE_ADJUSTMENT;
Bd_battery.c (source\src):        if(ad_event_handle) {
Bd_battery.c (source\src):            err_code = app_sched_event_put(&percentage_batt_lvl,1,ad_event_handle);
Bd_battery.c (source\src):    NRF_ADC->ENABLE     = ADC_ENABLE_ENABLE_Disabled;
Bd_battery.c (source\src): * Read battery ADC value once, be sure call this when ADC_IRQn disabled
Bd_battery.c (source\src):void battery_adc_read_once(uint16_t* batt_lvl_in_milli_volts)
Bd_battery.c (source\src):    uint32_t adc_result = 0;
Bd_battery.c (source\src):    while( !(NRF_ADC->EVENTS_END) ) {
Bd_battery.c (source\src):    NRF_ADC->EVENTS_END     = 0;
Bd_battery.c (source\src):    adc_result              = NRF_ADC->RESULT;
Bd_battery.c (source\src):    NRF_ADC->TASKS_STOP     = 1;
Bd_battery.c (source\src):    *batt_lvl_in_milli_volts = ((uint32_t)(ADC_RESULT_IN_MILLI_VOLTS(adc_result)) & 0xffff);
Bd_battery.c (source\src):    //when charging, battery voltage need adjust
Bd_battery.c (source\src):        *batt_lvl_in_milli_volts -= BATTERY_VOLTAGE_ADJUSTMENT;
Bd_battery.c (source\src):static void battery_adc_interrupt_disable(void)
Bd_battery.c (source\src):    NRF_ADC->INTENSET   = ADC_INTENSET_END_Disabled;
Bd_battery.c (source\src):    NVIC_DisableIRQ(ADC_IRQn);
Bd_battery.c (source\src):* ADC read once for charging detect, which returns raw data
Bd_battery.c (source\src):void battery_adc_interrupt_init(void);
Bd_battery.c (source\src):void battery_adc_read_once_for_charging_detect(uint16_t * batt_lvl_in_milli_volts)
Bd_battery.c (source\src):    uint32_t adc_result = 0;
Bd_battery.c (source\src):    //disable adc irq
Bd_battery.c (source\src):    battery_adc_interrupt_disable();
Bd_battery.c (source\src):    //adc stop
Bd_battery.c (source\src):    NRF_ADC->EVENTS_END     = 0;
Bd_battery.c (source\src):    NRF_ADC->TASKS_STOP     = 1;
Bd_battery.c (source\src):    while( !(NRF_ADC->EVENTS_END) ) {
Bd_battery.c (source\src):    NRF_ADC->EVENTS_END     = 0;
Bd_battery.c (source\src):    adc_result              = NRF_ADC->RESULT;
Bd_battery.c (source\src):    NRF_ADC->TASKS_STOP     = 1;
Bd_battery.c (source\src):    *batt_lvl_in_milli_volts = ((uint32_t)(ADC_RESULT_IN_MILLI_VOLTS(adc_result)) & 0xffff);
Bd_battery.c (source\src):    battery_adc_interrupt_init();
Bd_battery.c (source\src):    //start evey time use ADC
Bd_battery.c (source\src):    NRF_ADC->ENABLE     = ADC_ENABLE_ENABLE_Enabled;
Bd_battery.c (source\src):    NRF_ADC->EVENTS_END  = 0;    // Stop any running conversions.
Bd_battery.c (source\src):    NRF_ADC->TASKS_START = 1;
Bd_battery.c (source\src):void battery_adc_dev_init(void)
Bd_battery.c (source\src):    // 1. Delay for ADC stable
Bd_battery.c (source\src):    // Configure ADC
Bd_battery.c (source\src):    NRF_ADC->CONFIG     = BATTERY_ADC_RESOLUTION << ADC_CONFIG_RES_Pos    |
Bd_battery.c (source\src):                          ADC_CONFIG_INPSEL_AnalogInputNoPrescaling  << ADC_CONFIG_INPSEL_Pos |
Bd_battery.c (source\src):                          ADC_CONFIG_REFSEL_VBG << ADC_CONFIG_REFSEL_Pos |
Bd_battery.c (source\src):                          ADC_INPUT_CHANNEL << ADC_CONFIG_PSEL_Pos;
Bd_battery.c (source\src):    NRF_ADC->EVENTS_END = 0;
Bd_battery.c (source\src):void battery_adc_interrupt_init(void)
Bd_battery.c (source\src):    NRF_ADC->INTENSET   = ADC_INTENSET_END_Msk;
Bd_battery.c (source\src):    NVIC_SetPriority(ADC_IRQn,1);
Bd_battery.c (source\src):    NVIC_EnableIRQ(ADC_IRQn);
Bd_battery.c (source\src):    ad_event_handle = handle;
Bd_battery.c (source\src):    if(ad_event_handle) {
Bd_battery.c (source\src):        (*ad_event_handle)(&percentage_batt_lvl,1);
Bd_battery.c (source\src):        battery_adc_read_once(&g_battery_voltage_mv);
Bd_battery.c (source\src):    NRF_ADC->ENABLE     = ADC_ENABLE_ENABLE_Disabled;
Bd_battery.c (source\src):    battery_adc_interrupt_init();
Bd_battery.h (source\inc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Bd_battery.h (source\inc):#define ADC_INPUT_CHANNEL  ADC_CONFIG_PSEL_AnalogInput3
Bd_battery.h (source\inc):#define ADC_REF_VOLTAGE_IN_MILLIVOLTS        1200                                     /**< Reference voltage (in  milli volts) used by ADC while doing conversion. */
Bd_battery.h (source\inc):#define ADC_PRE_SCALING_COMPENSATION         1                                         /**< The ADC is configured to use VDD with no prescaling as input. And hence the result of conversion is to be multiplied by 3 to get the actual value of the battery voltage.*/
Bd_battery.h (source\inc):#define ADC_HW_PRE_SCALING_COMPENSATION      4
Bd_battery.h (source\inc):#define BATTERY_ADC_RESOLUTION  (ADC_CONFIG_RES_10bit)
Bd_battery.h (source\inc):#define BATTERY_ADC_DIV         (1023)
Bd_battery.h (source\inc):/**@brief Macro to convert the result of ADC conversion in millivolts.
Bd_battery.h (source\inc): * @param[in]  ADC_VALUE   ADC result.
Bd_battery.h (source\inc):#define ADC_RESULT_IN_MILLI_VOLTS(ADC_VALUE)\
Bd_battery.h (source\inc):        ((((ADC_VALUE) * ADC_REF_VOLTAGE_IN_MILLIVOLTS)  * ADC_PRE_SCALING_COMPENSATION * ADC_HW_PRE_SCALING_COMPENSATION)/ BATTERY_ADC_DIV)
Bd_battery.h (source\inc):/**@brief Function to make the ADC start a battery level conversion
Bd_battery.h (source\inc):void battery_adc_dev_init(void);
Bd_battery.h (source\inc):void battery_adc_read_once(uint16_t* batt_lvl_in_milli_volts);
Bd_battery.h (source\inc):void battery_adc_read_once_for_charging_detect(uint16_t * batt_lvl_in_milli_volts);
Bd_ble_nus.c (source\src): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Bd_ble_nus.c (source\src):extern uint8_t global_send_header_wait_ack_complete;
Bd_ble_nus.c (source\src):    if(global_send_header_wait_ack_complete == 1) {
Bd_ble_nus.c (source\src):        global_send_header_wait_ack_complete = 0;
Bd_ble_nus.c (source\src):    switch (p_ble_evt->header.evt_id) {
Bd_ble_nus.c (source\src):/**@brief Add RX characteristic.
Bd_ble_nus.c (source\src):static uint32_t rx_char_add(ble_nus_t * p_nus, const ble_nus_init_t * p_nus_init)
Bd_ble_nus.c (source\src):    // Add Battery Level characteristic
Bd_ble_nus.c (source\src):    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.read_perm);
Bd_ble_nus.c (source\src):    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.read_perm);
Bd_ble_nus.c (source\src):    return sd_ble_gatts_characteristic_add(p_nus->service_handle, &char_md,
Bd_ble_nus.c (source\src):/**@brief Add TX characteristic.
Bd_ble_nus.c (source\src):static uint32_t tx_char_add(ble_nus_t * p_nus, const ble_nus_init_t * p_nus_init)
Bd_ble_nus.c (source\src):    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.read_perm);
Bd_ble_nus.c (source\src):    return sd_ble_gatts_characteristic_add(p_nus->service_handle, &char_md,
Bd_ble_nus.c (source\src):    // Add custom base UUID
Bd_ble_nus.c (source\src):    err_code = sd_ble_uuid_vs_add(&nus_base_uuid, &p_nus->uuid_type);
Bd_ble_nus.c (source\src):    // Add service
Bd_ble_nus.c (source\src):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_nus->service_handle);
Bd_ble_nus.c (source\src):    err_code = rx_char_add(p_nus, p_nus_init);
Bd_ble_nus.c (source\src):    err_code = tx_char_add(p_nus, p_nus_init);
Bd_ble_nus.h (source\inc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Bd_ble_nus.h (source\inc): *          During initialization it adds the Nordic UART Service and its characteristics to 
Bd_buzzer.c (source\src): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Bd_buzzer.c (source\src):#define PPI_CHAN0_TO_TOGGLE_BUZZER              0                                         /*!< The PPI Channel that connects CC0 compare event to the GPIOTE Task that toggles the Advertising LED. */
Bd_buzzer.c (source\src):#define GPIOTE_CHAN_FOR_BUZZER_TASK             0                                         /*!< The GPIOTE Channel used to perform write operation on the Advertising LED pin. */
Bd_buzzer.c (source\src):#define ADVERTISING_BUZZER_PIN_NO         BAIDU_LED_4//NRF6310_LED_6     /**< Pin that can be used by applications to indicate advertising state.*/
Bd_buzzer.c (source\src): *          generate capture compare events that toggle the advertising LED state.
Bd_buzzer.c (source\src):    /* Load initial values to TIMER2 CC registers */
Bd_buzzer.c (source\src):                           ADVERTISING_BUZZER_PIN_NO,
Bd_buzzer.c (source\src):    nrf_gpio_pin_set(ADVERTISING_BUZZER_PIN_NO);
Bd_buzzer.h (source\inc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Bd_charging.c (source\src):    charger = !(nrf_gpio_pin_read(CHARGER_CONNECTED_PIN) & 0xFF);
Bd_charging.c (source\src):    charger = (nrf_gpio_pin_read(CHARGER_CHARGING_PIN) & 0xFF);
Bd_charging.c (source\src):    charging = !(nrf_gpio_pin_read(CHARGER_CHARGING_PIN) & 0xFF);
Bd_charging.c (source\src):    //single thread singlton
Bd_click-algorithm.c (source\src):#define THREAD_HOLD_REACH_BY_INC_MAX_TIME  31 //in ms
Bd_click-algorithm.c (source\src):                if(s_continue_inc_time > THREAD_HOLD_REACH_BY_INC_MAX_TIME) {
Bd_click-algorithm.c (source\src):        s_click_algorithm_error_desc = "click algorithm aready been init";
Bd_communicate_protocol.c (source\src):uint8_t global_send_header_wait_ack_complete = 0;
Bd_communicate_protocol.c (source\src):uint8_t global_L1_header_buffer[L1_HEADER_SIZE];
Bd_communicate_protocol.c (source\src):* This variable is used to deal with : send header immediately after send response
Bd_communicate_protocol.c (source\src):static L1_Header_Schedule_type_t L1_header_need_schedule = {NULL,0};
Bd_communicate_protocol.c (source\src):static L1Header_t* construct_response_package(uint16_t sequence_id, bool check_success);
Bd_communicate_protocol.c (source\src):    global_send_header_wait_ack_complete = 0;
Bd_communicate_protocol.c (source\src):    //disable radio
Bd_communicate_protocol.c (source\src):    radio_disable();
Bd_communicate_protocol.c (source\src):    /*fill header*/
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_HEADER_MAGIC_POS] = L1_HEADER_MAGIC;           /* Magic */
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_HEADER_PROTOCOL_VERSION_POS] = L1_HEADER_VERSION;       /* protocol version */
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_PAYLOAD_LENGTH_HIGH_BYTE_POS] = (content->length >> 8 & 0xFF);    /* length high byte */
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_PAYLOAD_LENGTH_LOW_BYTE_POS] = (content->length & 0xFF);      /* length low byte */
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_HEADER_CRC16_HIGH_BYTE_POS] = ( crc16_ret >> 8) & 0xff;
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_HEADER_CRC16_LOW_BYTE_POS] = crc16_ret & 0xff;
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_HEADER_SEQ_ID_HIGH_BYTE_POS] = (L1_sequence_id >> 8) & 0xff;
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_HEADER_SEQ_ID_LOW_BYTE_POS] = L1_sequence_id & 0xff;
Bd_communicate_protocol.c (source\src):    //register need to schedule header
Bd_communicate_protocol.c (source\src):    L1_header_need_schedule.isUsed = 1;
Bd_communicate_protocol.c (source\src):    L1_header_need_schedule.content = content;
Bd_communicate_protocol.c (source\src):                global_send_header_wait_ack_complete = 0;
Bd_communicate_protocol.c (source\src):                    global_send_header_wait_ack_complete = 0;
Bd_communicate_protocol.c (source\src):        if((current_task_type == TASK_ACK) && (new_task_type == TASK_DATA) && (L1_header_need_schedule.isUsed == 1)) {//get a data send request while no buffer to send ack
Bd_communicate_protocol.c (source\src):            sendLen = L1_HEADER_SIZE;
Bd_communicate_protocol.c (source\src):                global_send_header_wait_ack_complete = 1;
Bd_communicate_protocol.c (source\src):        * Order :header content ack
Bd_communicate_protocol.c (source\src):        //first need to check header send request
Bd_communicate_protocol.c (source\src):        if(L1_header_need_schedule.isUsed == 1) {
Bd_communicate_protocol.c (source\src):            if(global_send_header_wait_ack_complete == 1) {
Bd_communicate_protocol.c (source\src):            currentSendPointer = global_L1_header_buffer;
Bd_communicate_protocol.c (source\src):            sendLen = L1_HEADER_SIZE;
Bd_communicate_protocol.c (source\src):            sendContentType = CONTENT_HEADER;
Bd_communicate_protocol.c (source\src):                case CONTENT_HEADER: //mark header send complete
Bd_communicate_protocol.c (source\src):                    if(L1_header_need_schedule.isUsed == 1) {
Bd_communicate_protocol.c (source\src):                        L1_header_need_schedule.isUsed = 0;
Bd_communicate_protocol.c (source\src):                        memset(global_L1_header_buffer,0,L1_HEADER_SIZE);
Bd_communicate_protocol.c (source\src):        if((sendContentType == CONTENT_HEADER) || (( CONTENT_DATA == sendContentType) && (content ->contentLeft != 0))) {
Bd_communicate_protocol.c (source\src):    /*fill header*/
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_HEADER_MAGIC_POS] = L1_HEADER_MAGIC;           /* Magic */
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_HEADER_PROTOCOL_VERSION_POS] = L1_HEADER_VERSION;       /* protocol version */
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_PAYLOAD_LENGTH_HIGH_BYTE_POS] = (content->length >> 8 & 0xFF);    /* length high byte */
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_PAYLOAD_LENGTH_LOW_BYTE_POS] = (content->length & 0xFF);      /* length low byte */
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_HEADER_CRC16_HIGH_BYTE_POS] = ( crc16_ret >> 8) & 0xff;
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_HEADER_CRC16_LOW_BYTE_POS] = crc16_ret & 0xff;
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_HEADER_SEQ_ID_HIGH_BYTE_POS] = (L1_sequence_id >> 8) & 0xff;
Bd_communicate_protocol.c (source\src):    global_L1_header_buffer[L1_HEADER_SEQ_ID_LOW_BYTE_POS] = L1_sequence_id & 0xff;
Bd_communicate_protocol.c (source\src):    //register need to schedule header
Bd_communicate_protocol.c (source\src):    L1_header_need_schedule.isUsed = 1;
Bd_communicate_protocol.c (source\src):    L1_header_need_schedule.content = &sendContent[i];
Bd_communicate_protocol.c (source\src):    global_reponse_buffer[1] = L2_HEADER_VERSION;                             /*L2 header version */
Bd_communicate_protocol.c (source\src):    sendContent.callback    = NULL;       //FIXME: should add send fail resend
Bd_communicate_protocol.c (source\src):    sendContent.length      = L2_HEADER_SIZE + L2_PAYLOAD_HEADER_SIZE + global_reponse_buffer[4];
Bd_communicate_protocol.c (source\src):            global_reponse_buffer[1] = L2_HEADER_VERSION;                               /*L2 header version */
Bd_communicate_protocol.c (source\src):            sendContent.length      = L2_HEADER_SIZE + L2_PAYLOAD_HEADER_SIZE + global_reponse_buffer[4];
Bd_communicate_protocol.c (source\src):    uint8_t first_key;                                                      /* first key of L2 payload*/
Bd_communicate_protocol.c (source\src):                    uint16_t offset = L2_HEADER_SIZE + L2_PAYLOAD_HEADER_SIZE;
Bd_communicate_protocol.c (source\src):                    //     uint16_t payload = 0;
Bd_communicate_protocol.c (source\src):                    uint8_t *key = data + L2_HEADER_SIZE;
Bd_communicate_protocol.c (source\src):                        key += (v_length + L2_PAYLOAD_HEADER_SIZE);
Bd_communicate_protocol.c (source\src):                        offset = offset + v_length + L2_PAYLOAD_HEADER_SIZE;
Bd_communicate_protocol.c (source\src):                    case TEST_FLASH_READ_WRITE:
Bd_communicate_protocol.c (source\src):                           uint16_t offset = L2_HEADER_SIZE + L2_PAYLOAD_HEADER_SIZE;
Bd_communicate_protocol.c (source\src):                           //     uint16_t payload = 0;
Bd_communicate_protocol.c (source\src):                           uint8_t *key = data + L2_HEADER_SIZE;
Bd_communicate_protocol.c (source\src):                            key += (v_length + L2_PAYLOAD_HEADER_SIZE);
Bd_communicate_protocol.c (source\src):                            offset = offset + v_length + L2_PAYLOAD_HEADER_SIZE;
Bd_communicate_protocol.c (source\src):static L1Header_t* construct_response_package(uint16_t sequence_id, bool check_success)
Bd_communicate_protocol.c (source\src):    static L1Header_t response_header;
Bd_communicate_protocol.c (source\src):    response_header.magic = L1_HEADER_MAGIC;
Bd_communicate_protocol.c (source\src):    version_ack.version_def.version = L2_HEADER_VERSION;
Bd_communicate_protocol.c (source\src):    response_header.version =  version_ack.value;
Bd_communicate_protocol.c (source\src):    response_header.payload_len = 0;
Bd_communicate_protocol.c (source\src):    response_header.crc16 = 0;
Bd_communicate_protocol.c (source\src):    response_header.sequence_id = ((sequence_id & 0xFF) << 8) | ((sequence_id >> 8) & 0xFF); //big engian
Bd_communicate_protocol.c (source\src):    return &response_header;
Bd_communicate_protocol.c (source\src):* receive bad package
Bd_communicate_protocol.c (source\src):            if(data[0] != L1_HEADER_MAGIC) {
Bd_communicate_protocol.c (source\src):            //get correct header
Bd_communicate_protocol.c (source\src):            length_to_receive = (received_buffer[L1_PAYLOAD_LENGTH_LOW_BYTE_POS] | (received_buffer[L1_PAYLOAD_LENGTH_HIGH_BYTE_POS] << 8)) + L1_HEADER_SIZE;
Bd_communicate_protocol.c (source\src):                inner_version.value = received_buffer[L1_HEADER_PROTOCOL_VERSION_POS];
Bd_communicate_protocol.c (source\src):                    response_package_handle((received_buffer[L1_HEADER_SEQ_ID_LOW_BYTE_POS] | (received_buffer[L1_HEADER_SEQ_ID_HIGH_BYTE_POS] << 8)),inner_version.version_def.err_flag);
Bd_communicate_protocol.c (source\src):                uint16_t crc16_value = (received_buffer[L1_HEADER_CRC16_HIGH_BYTE_POS] << 8 | received_buffer[L1_HEADER_CRC16_LOW_BYTE_POS]);
Bd_communicate_protocol.c (source\src):                if(L1_crc_check(crc16_value,received_buffer+L1_HEADER_SIZE,(received_buffer[L1_PAYLOAD_LENGTH_LOW_BYTE_POS] | (received_buffer[L1_PAYLOAD_LENGTH_HIGH_BYTE_POS] << 8))) == NRF_SUCCESS) { //check crc for received package
Bd_communicate_protocol.c (source\src):                    L1_receive_response((received_buffer[L1_HEADER_SEQ_ID_LOW_BYTE_POS] | (received_buffer[L1_HEADER_SEQ_ID_HIGH_BYTE_POS] << 8)),true);
Bd_communicate_protocol.c (source\src):                    L2_frame_resolve(received_buffer+L1_HEADER_SIZE,(received_buffer[L1_PAYLOAD_LENGTH_LOW_BYTE_POS] | (received_buffer[L1_PAYLOAD_LENGTH_HIGH_BYTE_POS] << 8)),&receive_state);
Bd_communicate_protocol.c (source\src):                } else { //receive bad package
Bd_communicate_protocol.c (source\src):                    L1_receive_response((received_buffer[L1_HEADER_SEQ_ID_LOW_BYTE_POS] | (received_buffer[L1_HEADER_SEQ_ID_HIGH_BYTE_POS] << 8)),false);
Bd_communicate_protocol.c (source\src):                inner_version.value = received_buffer[L1_HEADER_PROTOCOL_VERSION_POS];
Bd_communicate_protocol.c (source\src):                    response_package_handle((received_buffer[L1_HEADER_SEQ_ID_LOW_BYTE_POS] | (received_buffer[L1_HEADER_SEQ_ID_HIGH_BYTE_POS] << 8)),inner_version.version_def.err_flag);
Bd_communicate_protocol.c (source\src):                uint16_t crc16_value = (received_buffer[L1_HEADER_CRC16_HIGH_BYTE_POS] << 8 | received_buffer[L1_HEADER_CRC16_LOW_BYTE_POS]);
Bd_communicate_protocol.c (source\src):                if(L1_crc_check(crc16_value,received_buffer+L1_HEADER_SIZE,(received_buffer[L1_PAYLOAD_LENGTH_LOW_BYTE_POS] | (received_buffer[L1_PAYLOAD_LENGTH_HIGH_BYTE_POS] << 8))) == NRF_SUCCESS) { //check crc for received package
Bd_communicate_protocol.c (source\src):                    L1_receive_response((received_buffer[L1_HEADER_SEQ_ID_LOW_BYTE_POS] | (received_buffer[L1_HEADER_SEQ_ID_HIGH_BYTE_POS] << 8)),true);
Bd_communicate_protocol.c (source\src):                    L2_frame_resolve(received_buffer+L1_HEADER_SIZE,(received_buffer[L1_PAYLOAD_LENGTH_LOW_BYTE_POS] | (received_buffer[L1_PAYLOAD_LENGTH_HIGH_BYTE_POS] << 8)),&receive_state);
Bd_communicate_protocol.c (source\src):                } else { //receive bad package
Bd_communicate_protocol.c (source\src):                    L1_receive_response((received_buffer[L1_HEADER_SEQ_ID_LOW_BYTE_POS] | (received_buffer[L1_HEADER_SEQ_ID_HIGH_BYTE_POS] << 8)),false);
Bd_communicate_protocol.c (source\src):            inner_version.value = data[L1_HEADER_PROTOCOL_VERSION_POS];
Bd_communicate_protocol.c (source\src):                response_package_handle((data[L1_HEADER_SEQ_ID_LOW_BYTE_POS] | (data[L1_HEADER_SEQ_ID_HIGH_BYTE_POS] << 8)),inner_version.version_def.err_flag);
Bd_communicate_protocol.c (source\src):    global_send_header_wait_ack_complete = 0;
Bd_communicate_protocol.h (source\inc):* structpading
Bd_communicate_protocol.h (source\inc):#define L1_HEADER_MAGIC  (0xAB)     /*header magic number */
Bd_communicate_protocol.h (source\inc):#define L1_HEADER_VERSION (0x00)     /*protocol version */
Bd_communicate_protocol.h (source\inc):#define L1_HEADER_SIZE   (8)      /*L1 header length*/
Bd_communicate_protocol.h (source\inc):* define L1 header byte order
Bd_communicate_protocol.h (source\inc):#define L1_HEADER_MAGIC_POS             (0)
Bd_communicate_protocol.h (source\inc):#define L1_HEADER_PROTOCOL_VERSION_POS  (1)
Bd_communicate_protocol.h (source\inc):#define L1_PAYLOAD_LENGTH_HIGH_BYTE_POS (2)         /* L1 payload lengh high byte */
Bd_communicate_protocol.h (source\inc):#define L1_PAYLOAD_LENGTH_LOW_BYTE_POS  (3)
Bd_communicate_protocol.h (source\inc):#define L1_HEADER_CRC16_HIGH_BYTE_POS   (4)
Bd_communicate_protocol.h (source\inc):#define L1_HEADER_CRC16_LOW_BYTE_POS    (5)
Bd_communicate_protocol.h (source\inc):#define L1_HEADER_SEQ_ID_HIGH_BYTE_POS  (6)
Bd_communicate_protocol.h (source\inc):#define L1_HEADER_SEQ_ID_LOW_BYTE_POS   (7)
Bd_communicate_protocol.h (source\inc):#define L2_HEADER_SIZE   (2)      /*L2 header length*/
Bd_communicate_protocol.h (source\inc):#define L2_HEADER_VERSION (0x00)     /*L2 header version*/
Bd_communicate_protocol.h (source\inc):#define L2_PAYLOAD_HEADER_SIZE (3)        /*L2 payload header*/
Bd_communicate_protocol.h (source\inc):#define L2_FIRST_VALUE_POS (L2_HEADER_SIZE + L2_PAYLOAD_HEADER_SIZE)
Bd_communicate_protocol.h (source\inc):#define L1L2_HEAD_LEN  (5)
Bd_communicate_protocol.h (source\inc):#define SPORT_HEAD_LEN (L1L2_HEAD_LEN+4)
Bd_communicate_protocol.h (source\inc):/* L1 header struct */
Bd_communicate_protocol.h (source\inc):    uint16_t payload_len;
Bd_communicate_protocol.h (source\inc):L1Header_t;
Bd_communicate_protocol.h (source\inc):Key_Header_t;
Bd_communicate_protocol.h (source\inc):    Key_Header_t key_header_bit_field;
Bd_communicate_protocol.h (source\inc):} Key_Header_u;
Bd_communicate_protocol.h (source\inc):    Key_Header_u key_header;
Bd_communicate_protocol.h (source\inc):L2DataHeader_t;
Bd_communicate_protocol.h (source\inc):    KEY_READ_SN         = 0x08,
Bd_communicate_protocol.h (source\inc):    KEY_READ_FLAG       = 0x0b,
Bd_communicate_protocol.h (source\inc):    TEST_FLASH_READ_WRITE = 0xFE,
Bd_communicate_protocol.h (source\inc):    CONTENT_HEADER = 1,
Bd_communicate_protocol.h (source\inc):L1_Header_Schedule_type_t;
Bd_crc16.c (source\src):        0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
Bd_data_manager.c (source\src):    uint8_t     read_word_len = 1 + sizeof(alarm_union_t)/sizeof(uint32_t) * MAX_ALARM_NUM;
Bd_data_manager.c (source\src):    err_code = bd_flash_read_page(FLASH_PAGE_ALARM_SETTINGS,alarm_mem,&read_word_len);
Bd_data_manager.c (source\src):    uint32_t *alarms_addr = NULL;
Bd_data_manager.c (source\src):    ble_flash_page_addr((uint8_t) FLASH_PAGE_ALARM_SETTINGS,&alarms_addr);
Bd_data_manager.c (source\src):    if(check_is_flash_erased(alarms_addr,(FLASH_PAGE_HEADER_LEN + 1 + sizeof(alarm_union_t)/sizeof(uint32_t) * MAX_ALARM_NUM)) != NRF_SUCCESS) { //page not erased
Bd_data_manager.c (source\src):void load_alarm(void)
Bd_data_manager.c (source\src):    uint8_t     read_word_len = 1 + sizeof(alarm_union_t)/sizeof(uint32_t) * MAX_ALARM_NUM;
Bd_data_manager.c (source\src):    err_code = bd_flash_read_page(FLASH_PAGE_ALARM_SETTINGS,alarm_mem,&read_word_len);
Bd_data_manager.c (source\src):    uint8_t     read_word_len = 1;
Bd_data_manager.c (source\src):    err_code = bd_flash_read_page(FLASH_PAGE_USER_PROFILE,&origin_profile,&read_word_len);
Bd_data_manager.c (source\src):    if((err_code == NRF_SUCCESS) && (read_word_len == 1)) {
Bd_data_manager.c (source\src):    uint32_t *userProfile_addr;
Bd_data_manager.c (source\src):    ble_flash_page_addr((uint8_t) FLASH_PAGE_USER_PROFILE,&userProfile_addr);
Bd_data_manager.c (source\src):    if(check_is_flash_erased(userProfile_addr,1 + FLASH_PAGE_HEADER_LEN) != NRF_SUCCESS) { //the page is not erased
Bd_data_manager.c (source\src):void load_user_profile(void)
Bd_data_manager.c (source\src):    uint8_t read_word_len = 1;
Bd_data_manager.c (source\src):    err_code = bd_flash_read_page(FLASH_PAGE_USER_PROFILE,&user_profile.data,&read_word_len);
Bd_data_manager.c (source\src):    if((err_code != NRF_SUCCESS) || (read_word_len != 1)) {
Bd_data_manager.c (source\src):        LOG(LEVEL_ERROR,"read user profile fail reset to default value");
Bd_data_manager.c (source\src):    uint32_t *dailyTarget_addr;
Bd_data_manager.c (source\src):        ble_flash_page_addr(FLASH_PAGE_DAILY_TARGET, &dailyTarget_addr);
Bd_data_manager.c (source\src):        LOG(LEVEL_INFO,"oldTarget:%p:%x\r\n",dailyTarget_addr, *dailyTarget_addr);
Bd_data_manager.c (source\src):void load_daily_target(void)
Bd_data_manager.c (source\src):    uint8_t read_word_len = 1;
Bd_data_manager.c (source\src):    err_code = bd_flash_read_page(FLASH_PAGE_DAILY_TARGET,&daily_step_target,&read_word_len);
Bd_data_manager.c (source\src):    if((err_code != NRF_SUCCESS) || (read_word_len != 1) || (daily_step_target == 0)) {
Bd_data_manager.c (source\src):    LOG(3,"flash_page_num:%d ready to sync\r\n",flash_page_num);
Bd_data_manager.h (source\inc):void load_alarm(void);
Bd_data_manager.h (source\inc):void load_user_profile(void);
Bd_data_manager.h (source\inc):void load_daily_target(void);
Bd_drv2605.c (source\src):static uint8_t drv2605_address;
Bd_drv2605.c (source\src):* Input   : Register Address, Data to be written
Bd_drv2605.c (source\src):u8_t DRV2605_WriteReg(u8_t WriteAddr, u8_t Data) {
Bd_drv2605.c (source\src): w2_data[0] = WriteAddr;
Bd_drv2605.c (source\src):  return twi_master_transfer(drv2605_address, w2_data, 2, TWI_ISSUE_STOP);  
Bd_drv2605.c (source\src):* Function Name  : LIS3DH_ReadReg
Bd_drv2605.c (source\src):* Description  : Generic Reading function. It must be fullfilled with either
Bd_drv2605.c (source\src):*   : I2C or SPI reading functions     
Bd_drv2605.c (source\src):* Input   : Register Address
Bd_drv2605.c (source\src):* Output  : Data REad
Bd_drv2605.c (source\src):bool DRV2605_ReadReg(u8_t Reg, u8_t* Data) {
Bd_drv2605.c (source\src):  //uint8_t register_address, uint8_t *destination, uint8_t number_of_bytes
Bd_drv2605.c (source\src):  transfer_succeeded = twi_master_transfer(drv2605_address, &Reg, 1, TWI_DONT_ISSUE_STOP);
Bd_drv2605.c (source\src):  transfer_succeeded &= twi_master_transfer(drv2605_address|TWI_READ_BIT, Data, 1, TWI_ISSUE_STOP);
Bd_drv2605.c (source\src): parameter "data" format: addr, value, addr, value, ...
Bd_drv2605.c (source\src):        twi_master_transfer(drv2605_address,data + i, 2, TWI_ISSUE_STOP);
Bd_drv2605.c (source\src):static unsigned char drv260x_read_reg(unsigned char reg)
Bd_drv2605.c (source\src):    // TODO, i2c read
Bd_drv2605.c (source\src):    transfer_succeeded = twi_master_transfer(drv2605_address, &mReg, 1, TWI_DONT_ISSUE_STOP);
Bd_drv2605.c (source\src):    transfer_succeeded &= twi_master_transfer(drv2605_address|TWI_READ_BIT, &Data, 1, TWI_ISSUE_STOP);
Bd_drv2605.c (source\src):    unsigned char regval = drv260x_read_reg(reg);
Bd_drv2605.c (source\src):    while (drv260x_read_reg(GO_REG) == GO) {
Bd_drv2605.c (source\src):    //i2c_write(addr_260x,  data, WAVEFORM_SEQUENCER_MAX+1);
Bd_drv2605.c (source\src):    twi_master_transfer(drv2605_address,data, WAVEFORM_SEQUENCER_MAX+1, TWI_ISSUE_STOP);
Bd_drv2605.c (source\src):    drv2605_address = (uint8_t)(DRV2605_ADDR << 1);
Bd_drv2605.c (source\src):    OTP = drv260x_read_reg(AUTOCAL_MEM_INTERFACE_REG) & AUTOCAL_MEM_INTERFACE_REG_OTP_MASK;
Bd_drv2605.c (source\src):    regData = drv260x_read_reg(RATED_VOLTAGE_REG);
Bd_drv2605.c (source\src):    regData = drv260x_read_reg(OVERDRIVE_CLAMP_VOLTAGE_REG);
Bd_drv2605.c (source\src):    regData = drv260x_read_reg(FEEDBACK_CONTROL_REG);
Bd_drv2605.c (source\src):    regData = drv260x_read_reg(Control1_REG);
Bd_drv2605.c (source\src):        status = drv260x_read_reg(STATUS_REG);
Bd_drv2605.c (source\src):    return drv260x_read_reg(GO_REG);
Bd_factory_test.c (source\src):extern AxesRaw_t accData[32]; // Read acc data from FIFO
Bd_factory_test.c (source\src):    uint32_t *flag_addr;
Bd_factory_test.c (source\src):    ble_flash_page_addr(FLASH_PAGE_SN_FACTORY_FLAG, &flag_addr );
Bd_factory_test.c (source\src):    return (*((uint8_t*)(flag_addr + FACTORY_TEST_FLAG_OFF))) == (uint8_t)0x00;
Bd_factory_test.c (source\src):    uint32_t *flag_addr = 0;
Bd_factory_test.c (source\src):    ble_flash_page_addr(FLASH_PAGE_SN_FACTORY_FLAG, &flag_addr );
Bd_factory_test.c (source\src):    if( *flag_addr != 0xFFFFFFFF){
Bd_factory_test.c (source\src):    global_reponse_buffer[1] = L2_HEADER_VERSION;           /*L2 header version */
Bd_factory_test.c (source\src):    content->length      = L2_HEADER_SIZE + L2_PAYLOAD_HEADER_SIZE + length;   /*length of whole L2*/
Bd_factory_test.c (source\src):    uint32_t *addr;
Bd_factory_test.c (source\src):            ble_flash_page_addr(FLASH_PAGE_SN_FACTORY_FLAG, &addr );
Bd_factory_test.c (source\src):            ble_flash_block_write(addr, value, size);
Bd_factory_test.c (source\src):            ble_flash_page_addr(FLASH_PAGE_SN_FACTORY_FLAG, &addr );
Bd_factory_test.c (source\src):            addr += FACTORY_TEST_FLAG_OFF;
Bd_factory_test.c (source\src):            ble_flash_word_write(addr, (uint32_t)0);
Bd_factory_test.c (source\src):void read_flag(void *data, uint16_t length)
Bd_factory_test.c (source\src):        uint32_t *addr;
Bd_factory_test.c (source\src):        ble_flash_page_addr(FLASH_PAGE_SN_FACTORY_FLAG, &addr );
Bd_factory_test.c (source\src):        addr += FACTORY_TEST_FLAG_OFF;
Bd_factory_test.c (source\src):        generate_l2_package(&content, FACTORY_TEST_COMMAND_ID, KEY_RETURN_FLAG, 1, (uint8_t*)addr );
Bd_factory_test.c (source\src):        err_code = app_sched_event_put(NULL, 0, (app_sched_event_handler_t)read_flag);
Bd_factory_test.c (source\src):        SERIAL_NUMBER[i]=data[i+L2_PAYLOAD_HEADER_SIZE];
Bd_factory_test.c (source\src):void read_sn(void *data, uint16_t length)
Bd_factory_test.c (source\src):        uint32_t *addr;
Bd_factory_test.c (source\src):        ble_flash_page_addr(FLASH_PAGE_SN_FACTORY_FLAG, &addr );
Bd_factory_test.c (source\src):        generate_l2_package(&content, FACTORY_TEST_COMMAND_ID, KEY_RETURN_SN, SERIAL_NUMBER_LENGTH, (uint8_t*)addr);
Bd_factory_test.c (source\src):        err_code = app_sched_event_put(NULL, 0, (app_sched_event_handler_t)read_sn);
Bd_factory_test.c (source\src):            err_code = app_sched_event_put(data + L2_PAYLOAD_HEADER_SIZE, length , (app_sched_event_handler_t)request_echo);
Bd_factory_test.c (source\src):        case KEY_READ_FLAG:
Bd_factory_test.c (source\src):            err_code = app_sched_event_put(NULL, 0, (app_sched_event_handler_t)read_flag);
Bd_factory_test.c (source\src):        case KEY_READ_SN:
Bd_factory_test.c (source\src):            err_code = app_sched_event_put(NULL, 0, (app_sched_event_handler_t)read_sn);
Bd_hal_acc.c (source\src):    LIS3DH_ReadReg(LIS3DH_CLICK_CFG,&regValue);
Bd_hal_acc.c (source\src):    LIS3DH_ReadReg(LIS3DH_TIME_LIMIT,&regValue);
Bd_hal_acc.c (source\src):    LIS3DH_ReadReg(LIS3DH_TIME_LATENCY,&regValue);
Bd_hal_acc.c (source\src):    LIS3DH_ReadReg(LIS3DH_TIME_WINDOW,&regValue);
Bd_hal_acc.c (source\src):    LIS3DH_ReadReg(LIS3DH_CLICK_THS,&regValue);
Bd_hal_acc.c (source\src):    uint32_t *spi_base_address = spi_master_init(SPI0,SPI_MODE0,false);
Bd_hal_acc.c (source\src):    if (spi_base_address == 0) {
Bd_hal_acc.c (source\src):    ASSERT(LIS3DH_ReadReg(LIS3DH_WHO_AM_I,&whoami));
Bd_hal_acc.c (source\src):* Description    : Read ALL samples stored in FIFO
Bd_hal_acc.c (source\src):* Input          : Byte to empty by FIFO unread sample value
Bd_hal_acc.c (source\src):    /* Read transaction */
Bd_hal_acc.c (source\src):        LIS3DH_ReadReg(index, &value);
Bd_hal_acc.c (source\src):        LOG(LEVEL_INFO,"--add:0x%x==v:0x%x \n",index,value);
Bd_hal_acc.c (source\src):        // sprintf(str,"--add:0x%x==v:0x%x \r\n",index,value);
Bd_hal_acc.c (source\src):        LIS3DH_ReadReg(index, &value);
Bd_hal_acc.c (source\src):        // sprintf(str,"config add:0x%x==v:0x%x \r\n",index,value);
Bd_hal_acc.c (source\src):        LOG(LEVEL_INFO,"config add:0x%x==v:0x%x \n",index,value);
Bd_hal_acc.c (source\src):    LIS3DH_ReadReg(index, &value);
Bd_hal_acc.c (source\src):    //    sprintf(str,"config add:0x%x==v:0x%x \r\n",index,value);
Bd_hal_acc.c (source\src):    LOG(LEVEL_INFO,"config add:0x%x==v:0x%x \n",index,value);
Bd_hal_acc.c (source\src):    LIS3DH_ReadReg(index, &value);
Bd_hal_acc.c (source\src):    //  sprintf(str,"config add:0x%x==v:0x%x \r\n",index,value);
Bd_hal_acc.c (source\src):    LOG(LEVEL_INFO,"config add:0x%x==v:0x%x \n",index,value);
Bd_interrupt_notify.c (source\src): * @details Saves the current status of the button pins, and starts a timer. If the timer is already
Bd_interrupt_notify.c (source\src): * @param[in]  event_pins_low_to_high   Mask telling which pin(s) had a low to high transition.
Bd_interrupt_notify.c (source\src): * @param[in]  event_pins_high_to_low   Mask telling which pin(s) had a high to low transition.
Bd_level_drive_motor.c (source\src):    //FIXME: tempory impl for tcl, and will be modified when adjust the project
Bd_level_drive_motor.c (source\src):    //FIXME: tempory impl for tcl, and will be modified when adjust the project
Bd_level_drive_motor.c (source\src):    //stop the timer already running
Bd_lis3dh_driver.c (source\src):* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
Bd_lis3dh_driver.c (source\src):extern volatile uint8_t  SPIReadLength, SPIWriteLength;
Bd_lis3dh_driver.c (source\src):* Function Name  : LIS3DH_ReadReg
Bd_lis3dh_driver.c (source\src):* Description  : Generic Reading function. It must be fullfilled with either
Bd_lis3dh_driver.c (source\src):*   : I2C or SPI reading functions     
Bd_lis3dh_driver.c (source\src):* Input   : Register Address
Bd_lis3dh_driver.c (source\src):* Output  : Data REad
Bd_lis3dh_driver.c (source\src):bool LIS3DH_ReadReg(u8_t Reg, u8_t* Data)
Bd_lis3dh_driver.c (source\src):    SPIMasterBuffer[0] = Reg | LIS3DH_READBIT;
Bd_lis3dh_driver.c (source\src):* Input   : Register Address, Data to be written
Bd_lis3dh_driver.c (source\src):u8_t LIS3DH_WriteReg(u8_t WriteAddr, u8_t Data)
Bd_lis3dh_driver.c (source\src):    SPIReadLength = 0;
Bd_lis3dh_driver.c (source\src):    SPIMasterBuffer[0] = WriteAddr;
Bd_lis3dh_driver.c (source\src):* Description    : Read identification code by WHO_AM_I register
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_WHO_AM_I, val) )
Bd_lis3dh_driver.c (source\src):* Description    : Read the AUX status register
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_STATUS_AUX, val) )
Bd_lis3dh_driver.c (source\src):* Description    : Read the AUX status register BIT
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_STATUS_AUX, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG1, &value) )
Bd_lis3dh_driver.c (source\src):* Note           : For Read Temperature by LIS3DH_OUT_AUX_3, LIS3DH_SetADCAux and LIS3DH_SetBDU 
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_TEMP_CFG_REG, &value) )
Bd_lis3dh_driver.c (source\src):    value |= state<<LIS3DH_ADC_PD;
Bd_lis3dh_driver.c (source\src):* Function Name  : LIS3DH_SetADCAux
Bd_lis3dh_driver.c (source\src):* Description    : Sets LIS3DH Output ADC
Bd_lis3dh_driver.c (source\src):status_t LIS3DH_SetADCAux(State_t state)
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_TEMP_CFG_REG, &value) )
Bd_lis3dh_driver.c (source\src):    value |= state<<LIS3DH_ADC_PD;
Bd_lis3dh_driver.c (source\src):* Description    : Read the Aux Values Output Registers
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_OUT_1_L, &valueL) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_OUT_1_H, &valueH) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_OUT_2_L, &valueL) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_OUT_2_H, &valueH) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_OUT_3_L, &valueL) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_OUT_3_H, &valueH) )
Bd_lis3dh_driver.c (source\src):* Description    : Read the Temperature Values by AUX Output Registers OUT_3_H
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_OUT_3_L, &valueL) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_OUT_3_H, &valueH) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG1, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG4, &value2) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG1, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG4, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG4, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG4, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG4, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG2, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG2, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG2, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG2, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG2, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG2, &value) )
Bd_lis3dh_driver.c (source\src):* Note           : To enable Interrupt signals on INT1 Pad (You MUST use all input variable in the argument, as example)
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG3, &value) )
Bd_lis3dh_driver.c (source\src):* Note           : To enable Interrupt signals on INT2 Pad (You MUST use all input variable in the argument, as example)
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG6, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CLICK_CFG, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CLICK_SRC, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG5, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG5, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_INT1_SRC, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_INT1_CFG, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_INT1_CFG, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_INT1_CFG, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG5, &value2) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_INT1_SRC, &value) )
Bd_lis3dh_driver.c (source\src):        if( !LIS3DH_ReadReg(LIS3DH_FIFO_CTRL_REG, &value) )
Bd_lis3dh_driver.c (source\src):        if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG5, &value) )
Bd_lis3dh_driver.c (source\src):        if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG5, &value) )
Bd_lis3dh_driver.c (source\src):        if( !LIS3DH_ReadReg(LIS3DH_FIFO_CTRL_REG, &value) )
Bd_lis3dh_driver.c (source\src):        if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG5, &value) )
Bd_lis3dh_driver.c (source\src):        if( !LIS3DH_ReadReg(LIS3DH_FIFO_CTRL_REG, &value) )
Bd_lis3dh_driver.c (source\src):        if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG5, &value) )
Bd_lis3dh_driver.c (source\src):        if( !LIS3DH_ReadReg(LIS3DH_FIFO_CTRL_REG, &value) )
Bd_lis3dh_driver.c (source\src):        if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG5, &value) )
Bd_lis3dh_driver.c (source\src):        if( !LIS3DH_ReadReg(LIS3DH_FIFO_CTRL_REG, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_FIFO_CTRL_REG, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_FIFO_CTRL_REG, &value) )
Bd_lis3dh_driver.c (source\src):* Description    : Read the status register
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_STATUS_REG, val) )
Bd_lis3dh_driver.c (source\src):* Description    : Read the status register BIT
Bd_lis3dh_driver.c (source\src):       LIS3DH_DATAREADY_BIT
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_STATUS_REG, &value) )
Bd_lis3dh_driver.c (source\src):* Description    : Read the Acceleration Values Output Registers
Bd_lis3dh_driver.c (source\src):    SPIMasterBuffer[0] = LIS3DH_OUT_X_L| LIS3DH_READBIT | LIS3DH_MSBIT;
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_OUT_X_L, valueL) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_OUT_X_H, valueH) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_OUT_Y_L, valueL) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_OUT_Y_H, valueH) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_OUT_Z_L, valueL) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_OUT_Z_H, valueH) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_INT1_SRC, val) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_INT1_SRC, &value) )
Bd_lis3dh_driver.c (source\src):* Description    : Read Fifo source Register
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_FIFO_SRC_REG, val) )
Bd_lis3dh_driver.c (source\src):* Description    : Read Fifo WaterMark source bit
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_FIFO_SRC_REG, &value) )
Bd_lis3dh_driver.c (source\src):* Description    : Read current number of unread samples stored in FIFO
Bd_lis3dh_driver.c (source\src):* Input          : Byte to empty by FIFO unread sample value
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_FIFO_SRC_REG, &value) )
Bd_lis3dh_driver.c (source\src):    if( !LIS3DH_ReadReg(LIS3DH_CTRL_REG4, &value) )
Bd_lis3dh_driver.c (source\src):                            BIT_3  /*lATCH INTERRUPT request on INT1_SRC register, with INT1_SRC register cleared by reading INT1_SRC itself*/
Bd_lis3dh_driver.c (source\src):            ASSERT(LIS3DH_ReadReg(LIS3DH_CTRL_REG1+index,values+index));
Bd_lis3dh_driver.c (source\src):            ASSERT(LIS3DH_ReadReg(LIS3DH_OUT_X_L+index,acc+index));  
Bd_lis3dh_driver.h (source\inc):* Description        : Descriptor Header for lis3dh_driver.c driver file
Bd_lis3dh_driver.h (source\inc):* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
Bd_lis3dh_driver.h (source\inc):#define LIS3DH_READBIT                (0x80)
Bd_lis3dh_driver.h (source\inc):    LIS3DH_STATUS_REG_ZYXDA             = 0x08,   // STATUS_REG: XYZ - sample ready
Bd_lis3dh_driver.h (source\inc):#define LIS3DH_ADC_PD            BIT(7)
Bd_lis3dh_driver.h (source\inc):#define LIS3DH_DATAREADY_BIT                           LIS3DH_STATUS_REG_ZYXDA
Bd_lis3dh_driver.h (source\inc):#define LIS3DH_MEMS_I2C_ADDRESS           0x33
Bd_lis3dh_driver.h (source\inc):status_t LIS3DH_SetADCAux(State_t state);
Bd_lis3dh_driver.h (source\inc)://Other Reading Functions
Bd_lis3dh_driver.h (source\inc):bool LIS3DH_ReadReg(u8_t Reg, u8_t* Data);
Bd_lis3dh_driver.h (source\inc):u8_t LIS3DH_WriteReg(u8_t WriteAddr, u8_t Data);
Bd_lis3dh_driver.h (source\inc):// i.e. u8_t LIS3DH_ReadReg(u8_t Reg, u8_t* Data);
Bd_nrf_delay.c (source\src): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Bd_private_bond.c (source\src):* check if already bonded to some phone
Bd_private_bond.c (source\src):    err_code = ble_flash_page_addr(FLASH_PAGE_USER_ID, &mp_flash_bond_info);
Bd_private_bond.c (source\src):    // Write header
Bd_private_bond.c (source\src):uint32_t bond_read_user_id(void)
Bd_private_bond.c (source\src):    uint16_t  crc_header;
Bd_private_bond.c (source\src):    uint32_t  header;
Bd_private_bond.c (source\src):    err_code = ble_flash_page_addr(FLASH_PAGE_USER_ID, &mp_flash_bond_info);
Bd_private_bond.c (source\src):    header = *mp_flash_bond_info;
Bd_private_bond.c (source\src):    if ((header & 0xFFFF0000U) == BLE_FLASH_MAGIC_NUMBER) {
Bd_private_bond.c (source\src):        crc_header = (uint16_t)(header & 0x0000FFFFU);
Bd_private_bond.c (source\src):    } else if (header == 0xFFFFFFFFU) {
Bd_private_bond.c (source\src):    // Load master
Bd_private_bond.c (source\src):    if (m_crc_bond_info == crc_header) {
Bd_private_bond.c (source\src):    global_reponse_buffer[1] = L2_HEADER_VERSION;   /*L2 header version */
Bd_private_bond.c (source\src):    sendContent.length   = L2_HEADER_SIZE + L2_PAYLOAD_HEADER_SIZE + global_reponse_buffer[4]; /*length of whole L2*/
Bd_private_bond.c (source\src):    global_reponse_buffer[1] = L2_HEADER_VERSION;   /*L2 header version */
Bd_private_bond.c (source\src):    sendContent.length   = L2_HEADER_SIZE + L2_PAYLOAD_HEADER_SIZE + global_reponse_buffer[4]; /*length of whole L2*/
Bd_private_bond.c (source\src):    uint16_t  crc_header;
Bd_private_bond.c (source\src):    uint32_t  header;
Bd_private_bond.c (source\src):    err_code = ble_flash_page_addr(FLASH_PAGE_USER_ID, &mp_flash_bond_info);
Bd_private_bond.c (source\src):    header = *mp_flash_bond_info;
Bd_private_bond.c (source\src):    if ((header & 0xFFFF0000U) == BLE_FLASH_MAGIC_NUMBER) {
Bd_private_bond.c (source\src):        crc_header = (uint16_t)(header & 0x0000FFFFU);
Bd_private_bond.c (source\src):    } else if (header == 0xFFFFFFFFU) {
Bd_private_bond.c (source\src):    if (m_crc_bond_info != crc_header) {
Bd_private_bond.c (source\src):    global_reponse_buffer[1] = L2_HEADER_VERSION;   /*L2 header version */
Bd_private_bond.c (source\src):    sendContent.length   = L2_HEADER_SIZE + L2_PAYLOAD_HEADER_SIZE + global_reponse_buffer[4]; /*length of whole L2*/
Bd_private_bond.c (source\src):    global_reponse_buffer[1] = L2_HEADER_VERSION;   /*L2 header version */
Bd_private_bond.c (source\src):    sendContent.length   = L2_HEADER_SIZE + L2_PAYLOAD_HEADER_SIZE + global_reponse_buffer[4]; /*length of whole L2*/
Bd_private_bond.h (source\inc):uint32_t bond_read_user_id(void);
Bd_public_board_config_pins.h (source\inc):#define DEVICE_NAME       "DuLife"   /**< Name of device. Will be included in the advertising data. */
Bd_public_board_config_pins.h (source\inc):#define BATTERY_VOLTAGE_ADJUSTMENT           60     /**< Adjustment for charging */
Bd_public_board_config_pins.h (source\inc):#define ADVERTISING_LED_PIN_NO      BAIDU_LED_0
Bd_spi_master.c (source\src): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Bd_spi_master.c (source\src):volatile uint8_t  SPIReadLength, SPIWriteLength;
Bd_spi_master.c (source\src):    NRF_SPI_Type *spi_base_address = (SPI0 == module_number)? NRF_SPI0 : (NRF_SPI_Type *)NRF_SPI1;
Bd_spi_master.c (source\src):        spi_base_address->PSELSCK  = SPI_PSELSCK0;
Bd_spi_master.c (source\src):        spi_base_address->PSELMOSI = SPI_PSELMOSI0;
Bd_spi_master.c (source\src):        spi_base_address->PSELMISO = SPI_PSELMISO0;
Bd_spi_master.c (source\src):        spi_base_address->PSELSCK  = SPI_PSELSCK1;
Bd_spi_master.c (source\src):        spi_base_address->PSELMOSI = SPI_PSELMOSI1;
Bd_spi_master.c (source\src):        spi_base_address->PSELMISO = SPI_PSELMISO1;
Bd_spi_master.c (source\src):    spi_base_address->FREQUENCY = (uint32_t) SPI_OPERATING_FREQUENCY;
Bd_spi_master.c (source\src):            config_mode = (SPI_CONFIG_CPHA_Leading << SPI_CONFIG_CPHA_Pos) | (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos);
Bd_spi_master.c (source\src):            config_mode = (SPI_CONFIG_CPHA_Leading << SPI_CONFIG_CPHA_Pos) | (SPI_CONFIG_CPOL_ActiveLow << SPI_CONFIG_CPOL_Pos);
Bd_spi_master.c (source\src):        spi_base_address->CONFIG = (config_mode | (SPI_CONFIG_ORDER_LsbFirst << SPI_CONFIG_ORDER_Pos));
Bd_spi_master.c (source\src):        spi_base_address->CONFIG = (config_mode | (SPI_CONFIG_ORDER_MsbFirst << SPI_CONFIG_ORDER_Pos));
Bd_spi_master.c (source\src):    spi_base_address->EVENTS_READY = 0U;
Bd_spi_master.c (source\src):    return (uint32_t *)spi_base_address;
Bd_spi_master.c (source\src):bool spi_master_tx_rx(uint32_t *spi_base_address, uint8_t transfer_size, const uint8_t *tx_data, uint8_t *rx_data)
Bd_spi_master.c (source\src):    NRF_SPI_Type *spi_base = (NRF_SPI_Type *)spi_base_address;
Bd_spi_master.c (source\src):    if( (uint32_t *)NRF_SPI0 == spi_base_address) {
Bd_spi_master.c (source\src):        while ((spi_base->EVENTS_READY == 0U) && (counter < TIMEOUT_COUNTER)) {
Bd_spi_master.c (source\src):        } else {   /* clear the event to be ready to receive next messages */
Bd_spi_master.c (source\src):            spi_base->EVENTS_READY = 0U;
Bd_spi_master.c (source\src):    NRF_SPI_Type *spi_base_address = (SPI0 == module_number)? NRF_SPI0 : (NRF_SPI_Type *)NRF_SPI1;
Bd_spi_master.c (source\src):    spi_base_address->ENABLE = (SPI_ENABLE_ENABLE_Enabled << SPI_ENABLE_ENABLE_Pos);
Bd_spi_master.c (source\src):    NRF_SPI_Type *spi_base_address = (SPI0 == module_number)? NRF_SPI0 : (NRF_SPI_Type *)NRF_SPI1;
Bd_spi_master.c (source\src):    spi_base_address->ENABLE = (SPI_ENABLE_ENABLE_Disabled << SPI_ENABLE_ENABLE_Pos);
Bd_spi_master.h (source\inc):* WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Bd_spi_master.h (source\inc): * @retval pointer to direct physical address of the requested SPI module if init was successful
Bd_spi_master.h (source\inc): * @param spi_base_address  register base address of the selected SPI master module
Bd_spi_master.h (source\inc):bool spi_master_tx_rx(uint32_t *spi_base_address, uint8_t transfer_size, const uint8_t *tx_data, uint8_t *rx_data);
Bd_stack_dump_repoter.c (source\src):    err_code = ble_flash_page_read(FLASH_PAGE_ERROR_LOG, (uint32_t *) (&m_ble_error_log), &error_log_size);
Bd_stack_dump_repoter.c (source\src):static uint16_t encode_assert_pos_to_buffer(uint8_t * addr)
Bd_stack_dump_repoter.c (source\src):    //copy the header info to buffer
Bd_stack_dump_repoter.c (source\src):    memcpy(addr,(uint8_t *)(&m_ble_error_log),length);
Bd_stack_dump_repoter.c (source\src):    global_reponse_buffer[1] = L2_HEADER_VERSION;       /*L2 header version */
Bd_stack_dump_repoter.c (source\src):static uint16_t encode_stack_info_to_buffer(uint8_t * addr)
Bd_stack_dump_repoter.c (source\src):    memcpy(addr,(uint8_t *)(&m_ble_error_log.stack_info),length);
Bd_stack_dump_repoter.c (source\src):    global_reponse_buffer[1] = L2_HEADER_VERSION;       /*L2 header version */
Bd_stack_dump_repoter.c (source\src):    global_reponse_buffer[1] = L2_HEADER_VERSION;       /*L2 header version */
Bd_step_counter.c (source\src):extern AxesRaw_t accData[32]; // Read acc data from FIFO
Bd_step_counter.c (source\src):extern SleepHead_t *manual_sleep_events_head;
Bd_step_counter.c (source\src):SportsHead_t mSportHead;
Bd_step_counter.c (source\src):SleepHead_t  mSleepHead;
Bd_step_counter.c (source\src):            mSportHead.length ++; // every time total steps change from 0 to non-zero, a new frame data
Bd_step_counter.c (source\src):        if(mSportHead.length == 0) {
Bd_step_counter.c (source\src):            mSportHead.length = 1;
Bd_step_counter.c (source\src):    time_union_t sport_head_time;
Bd_step_counter.c (source\src):    sport_head_time.data = 0;
Bd_step_counter.c (source\src):    sport_head_time.time.year = mSportHead.Date.date.year;
Bd_step_counter.c (source\src):    sport_head_time.time.month = mSportHead.Date.date.month;
Bd_step_counter.c (source\src):    sport_head_time.time.day = mSportHead.Date.date.day;
Bd_step_counter.c (source\src):    uint32_t sport_head_seconds = convert_time_to_Second(sport_head_time);
Bd_step_counter.c (source\src):    time_union_t sleep_head_time;
Bd_step_counter.c (source\src):    sleep_head_time.data = 0;
Bd_step_counter.c (source\src):    sleep_head_time.time.year = mSleepHead.Date.date.year;
Bd_step_counter.c (source\src):    sleep_head_time.time.month= mSleepHead.Date.date.month;
Bd_step_counter.c (source\src):    sleep_head_time.time.day= mSleepHead.Date.date.day;
Bd_step_counter.c (source\src):    uint32_t sleepHead_seconds = convert_time_to_Second(sleep_head_time);
Bd_step_counter.c (source\src):        sleep_event.sleep.starting_time_stamp = sleepHead_seconds + 60*i;
Bd_step_counter.c (source\src):    if(0 == mSportHead.length) {
Bd_step_counter.c (source\src):        reset_sports_head();
Bd_step_counter.c (source\src):    if(0 == mSleepHead.length) {
Bd_step_counter.c (source\src):        reset_sleep_head();
Bd_step_counter.c (source\src):    if(0 == manual_sleep_events_head->length) {
Bd_step_counter.c (source\src):        reset_sleep_setting_head();
Bd_step_counter.c (source\src):    reset_sports_head();
Bd_step_counter.c (source\src):    reset_sleep_head();
Bd_step_counter.c (source\src):    reset_sleep_setting_head();
Bd_step_counter.c (source\src):        LIS3DH_ReadReg(index, &value);
Bd_step_counter.c (source\src):        LOG(LEVEL_INFO,"config add:0x%x==v:0x%x \n",index,value);
Bd_step_counter.c (source\src):uint8_t read_sensor_data() {
Bd_step_counter.c (source\src):    data_size = read_sensor_data();
Bd_step_counter.c (source\src):    data_size = read_sensor_data();
Bd_step_counter.c (source\src):            g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 0] = mSportsData.data >> 56; //OFFSET
Bd_step_counter.c (source\src):            g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 1] = mSportsData.data >> 48;
Bd_step_counter.c (source\src):            g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 2] = mSportsData.data >> 40;
Bd_step_counter.c (source\src):            g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 3] = mSportsData.data >> 32;
Bd_step_counter.c (source\src):            g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 4] = mSportsData.data >> 24;
Bd_step_counter.c (source\src):            g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 5] = mSportsData.data >> 16;
Bd_step_counter.c (source\src):            g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 6] = mSportsData.data >> 8;
Bd_step_counter.c (source\src):            g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 7] = mSportsData.data;
Bd_step_counter.c (source\src):            LOG(LEVEL_INFO,"mOffsetH:%x\n",g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 0]);
Bd_step_counter.c (source\src):            LOG(LEVEL_INFO,"mOffsetL:%x\n",g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 1]);
Bd_step_counter.c (source\src):            if(mSportHead.length == SPORTS_MAX_GROUP_NUM) {
Bd_step_counter.c (source\src):                if(save_sport_group_data(mSportHead.length) == NRF_SUCCESS) {
Bd_step_counter.c (source\src):                    mSportHead.length = 0;
Bd_switch_sleep.c (source\src):SleepHead_t manual_sleep_events_head_data;
Bd_switch_sleep.c (source\src):SleepHead_t *manual_sleep_events_head = &manual_sleep_events_head_data;
Bd_switch_sleep.c (source\src):    int sleepSetting_Head_minutes;
Bd_switch_sleep.c (source\src):    time_union_t sleep_setting_head_time;
Bd_switch_sleep.c (source\src):    sleep_setting_head_time.data = 0;
Bd_switch_sleep.c (source\src):    sleep_setting_head_time.time.year = manual_sleep_events_head->Date.date.year;
Bd_switch_sleep.c (source\src):    sleep_setting_head_time.time.month= manual_sleep_events_head->Date.date.month;
Bd_switch_sleep.c (source\src):    sleep_setting_head_time.time.day= manual_sleep_events_head->Date.date.day;
Bd_switch_sleep.c (source\src):    sleepSetting_Head_minutes = convert_time_to_Second(sleep_setting_head_time)/60;
Bd_switch_sleep.c (source\src):    if(manual_sleep_events_head->length > MAX_SLEEP_EVT_LEN)
Bd_switch_sleep.c (source\src):    manual_sleep_events_head->length++;
Bd_switch_sleep.c (source\src):    manual_sleep_event.bits.timeStamp = (uint16_t)(sleepSetting_minutes - sleepSetting_Head_minutes);
Bd_switch_sleep.c (source\src):    LOG(LEVEL_INFO,"sleep_evt: 0x%x,mode: %d; %d,%d th\n",manual_sleep_event.data, manual_sleep_event.bits.mode,manual_sleep_event.bits.timeStamp, manual_sleep_events_head->length);
Bd_switch_sleep.c (source\src):    sleep_events_buff[SPORT_HEAD_LEN + ((manual_sleep_events_head->length-1) <<2) + 0] = manual_sleep_event.data >> 24; //OFFSET
Bd_switch_sleep.c (source\src):    sleep_events_buff[SPORT_HEAD_LEN + ((manual_sleep_events_head->length-1) <<2) + 1] = manual_sleep_event.data >> 16; // reserved
Bd_switch_sleep.c (source\src):    sleep_events_buff[SPORT_HEAD_LEN + ((manual_sleep_events_head->length-1) <<2) + 2] = manual_sleep_event.data >> 8; // reserved
Bd_switch_sleep.c (source\src):    sleep_events_buff[SPORT_HEAD_LEN + ((manual_sleep_events_head->length-1) <<2) + 3] = manual_sleep_event.data;
Bd_switch_sleep.c (source\src):void update_sleep_setting_head(void)
Bd_switch_sleep.c (source\src):    manual_sleep_events_head->Date.date.year = tm->year - 2000;
Bd_switch_sleep.c (source\src):    manual_sleep_events_head->Date.date.month= tm->month;
Bd_switch_sleep.c (source\src):    manual_sleep_events_head->Date.date.day = tm->day;
Bd_switch_sleep.c (source\src):void reset_sleep_setting_head(void)
Bd_switch_sleep.c (source\src):    memset(manual_sleep_events_head,0,sizeof(SleepHead_t));
Bd_switch_sleep.c (source\src):    update_sleep_setting_head();
Bd_switch_sleep.c (source\src):    manual_sleep_events_head->length -= sleep_evts_sent_cnt;
Bd_switch_sleep.c (source\src):    for(index = 1; index <= manual_sleep_events_head->length; index ++) {
Bd_switch_sleep.c (source\src):        sleep_events_buff[SPORT_HEAD_LEN + ((index-1)<<2) + 0] = sleep_events_buff[SPORT_HEAD_LEN + ((sleep_evts_sent_cnt + index -1)<<2) + 0];
Bd_switch_sleep.c (source\src):        sleep_events_buff[SPORT_HEAD_LEN + ((index-1)<<2) + 1] = sleep_events_buff[SPORT_HEAD_LEN + ((sleep_evts_sent_cnt + index -1)<<2) + 1];
Bd_switch_sleep.c (source\src):        sleep_events_buff[SPORT_HEAD_LEN + ((index-1)<<2) + 2] = sleep_events_buff[SPORT_HEAD_LEN + ((sleep_evts_sent_cnt + index -1)<<2) + 2];
Bd_switch_sleep.c (source\src):        sleep_events_buff[SPORT_HEAD_LEN + ((index-1)<<2) + 3] = sleep_events_buff[SPORT_HEAD_LEN + ((sleep_evts_sent_cnt + index -1)<<2) + 3];
Bd_switch_sleep.c (source\src):    update_sleep_setting_head();
Bd_switch_sleep.c (source\src):    LOG(LEVEL_INFO, "send success,still have: %d\r\n", manual_sleep_events_head->length);
Bd_switch_sleep.c (source\src):    L2DataHeader_t mSleepEventHeader;
Bd_switch_sleep.c (source\src):    if(0 == manual_sleep_events_head->length){
Bd_switch_sleep.c (source\src):    /******SportHead******/
Bd_switch_sleep.c (source\src):    sentDataLen = (manual_sleep_events_head->length<<2) + sizeof(SleepHead_t);
Bd_switch_sleep.c (source\src):    mSleepEventHeader.cmd_ID = HEALTH_DATA_COMMAND_ID;
Bd_switch_sleep.c (source\src):    mSleepEventHeader.version = L2_HEADER_VERSION;
Bd_switch_sleep.c (source\src):    mSleepEventHeader.key = KEY_RETURN_SLEEP_SETTING;
Bd_switch_sleep.c (source\src):    mSleepEventHeader.key_header.data= sentDataLen & 0x01ff; // 9bit length
Bd_switch_sleep.c (source\src):    sleep_events_buff[0] = mSleepEventHeader.cmd_ID; //L2 commandID
Bd_switch_sleep.c (source\src):    sleep_events_buff[1] = mSleepEventHeader.version; //
Bd_switch_sleep.c (source\src):    sleep_events_buff[2] = mSleepEventHeader.key;
Bd_switch_sleep.c (source\src):    sleep_events_buff[3] = mSleepEventHeader.key_header.data>>8;
Bd_switch_sleep.c (source\src):    sleep_events_buff[4] = mSleepEventHeader.key_header.data&0xff;
Bd_switch_sleep.c (source\src):    memcpy(&(sleep_events_buff[5]),manual_sleep_events_head,sizeof(SleepHead_t));
Bd_switch_sleep.c (source\src):    LOG(LEVEL_INFO,"length:%d", manual_sleep_events_head->length);
Bd_switch_sleep.c (source\src):    for(int ii = 0; ii <= (SPORT_HEAD_LEN + ((manual_sleep_events_head->length-1) <<2) + 3); ii ++)
Bd_switch_sleep.c (source\src):    LOG(LEVEL_INFO,"date:%d-%d-%d", manual_sleep_events_head->Date.date.year, manual_sleep_events_head->Date.date.month, manual_sleep_events_head->Date.date.day);
Bd_switch_sleep.c (source\src):    ble_flash_page_read(FLASH_PAGE_SLEEP_SETTINGS,(uint32_t * )sleep_events_buff,&word_count);
Bd_switch_sleep.c (source\src):    memcpy(manual_sleep_events_head,&(sleep_events_buff[5]),sizeof(SleepHead_t));
Bd_switch_sleep.c (source\src):    if(manual_sleep_events_head_data.length != 0){
Bd_switch_sleep.c (source\src):        manual_sleep_event.data = sleep_events_buff[SPORT_HEAD_LEN + ((manual_sleep_events_head->length-1) <<2) + 0]; //OFFSET
Bd_switch_sleep.c (source\src):        manual_sleep_event.data |= sleep_events_buff[SPORT_HEAD_LEN + ((manual_sleep_events_head->length-1) <<2) + 1]; // reserved
Bd_switch_sleep.c (source\src):        manual_sleep_event.data |= sleep_events_buff[SPORT_HEAD_LEN + ((manual_sleep_events_head->length-1) <<2) + 2]; // reserved
Bd_switch_sleep.c (source\src):        manual_sleep_event.data |= sleep_events_buff[SPORT_HEAD_LEN + ((manual_sleep_events_head->length-1) <<2) + 3];
Bd_switch_sleep.c (source\src):        LOG(LEVEL_INFO,"length:%d", manual_sleep_events_head->length);
Bd_switch_sleep.c (source\src):        for(int ii = 0; ii <= (SPORT_HEAD_LEN + ((manual_sleep_events_head->length-1) <<2) + 3); ii ++)
Bd_switch_sleep.c (source\src):        LOG(LEVEL_INFO,"date:%d-%d-%d", manual_sleep_events_head->Date.date.year, manual_sleep_events_head->Date.date.month, manual_sleep_events_head->Date.date.day);
Bd_switch_sleep.c (source\src):    L2DataHeader_t mSleepEventHeader;
Bd_switch_sleep.c (source\src):    sentDataLen = (manual_sleep_events_head->length<<2) + sizeof(SleepHead_t);
Bd_switch_sleep.c (source\src):    mSleepEventHeader.cmd_ID = HEALTH_DATA_COMMAND_ID;
Bd_switch_sleep.c (source\src):    mSleepEventHeader.version = L2_HEADER_VERSION;
Bd_switch_sleep.c (source\src):    mSleepEventHeader.key = KEY_RETURN_SLEEP_SETTING;
Bd_switch_sleep.c (source\src):    mSleepEventHeader.key_header.data= sentDataLen & 0x01ff; // 9bit length
Bd_switch_sleep.c (source\src):    sleep_events_buff[0] = mSleepEventHeader.cmd_ID; //L2 commandID
Bd_switch_sleep.c (source\src):    sleep_events_buff[1] = mSleepEventHeader.version; //
Bd_switch_sleep.c (source\src):    sleep_events_buff[2] = mSleepEventHeader.key;
Bd_switch_sleep.c (source\src):    sleep_events_buff[3] = mSleepEventHeader.key_header.data>>8;
Bd_switch_sleep.c (source\src):    sleep_events_buff[4] = mSleepEventHeader.key_header.data&0xff;
Bd_switch_sleep.c (source\src):    sleep_events_buff[5] = manual_sleep_events_head->Date.data>>8;
Bd_switch_sleep.c (source\src):    sleep_events_buff[6] = manual_sleep_events_head->Date.data;
Bd_switch_sleep.c (source\src):    sleep_events_buff[7] = manual_sleep_events_head->length >> 8;
Bd_switch_sleep.c (source\src):    sleep_events_buff[8] = manual_sleep_events_head->length;
Bd_switch_sleep.c (source\src):        sleep_evts_sent_cnt = manual_sleep_events_head->length;
Bd_switch_sleep.c (source\src):    return manual_sleep_events_head->length;
Bd_switch_sleep.h (source\inc): * @param spi_base_address  register base address of the selected SPI master module
Bd_switch_sleep.h (source\inc):void update_sleep_setting_head(void);
Bd_switch_sleep.h (source\inc):void reset_sleep_setting_head(void);
Bd_sync_data.c (source\src):extern SleepHead_t mSleepHead;
Bd_sync_data.c (source\src):extern SportsHead_t mSportHead;
Bd_sync_data.c (source\src):    g_saved_SportsData.p_read_addr = (uint32_t *)SPORTS_DATA_BASE_ADDR;
Bd_sync_data.c (source\src):    g_saved_SportsData.p_write_addr = (uint32_t *)SPORTS_DATA_BASE_ADDR;
Bd_sync_data.c (source\src):    uint32_t * address = NULL;
Bd_sync_data.c (source\src):    ble_flash_page_addr(SPORTS_DATA_BASE_PAGE,&address);
Bd_sync_data.c (source\src):    if(*address != 0xFFFFFFFF) {
Bd_sync_data.c (source\src):    g_saved_SleepData.p_read_addr = (uint32_t *)SLEEP_DATA_BASE_ADDR;
Bd_sync_data.c (source\src):    g_saved_SleepData.p_write_addr = (uint32_t *)SLEEP_DATA_BASE_ADDR;
Bd_sync_data.c (source\src):    uint32_t * address = NULL;
Bd_sync_data.c (source\src):    ble_flash_page_addr(SLEEP_DATA_BASE_PAGE,&address);
Bd_sync_data.c (source\src):    if(*address != 0xFFFFFFFF) {
Bd_sync_data.c (source\src):uint32_t get_flash_page_number(uint32_t * address);
Bd_sync_data.c (source\src):    uint32_t *address = NULL;
Bd_sync_data.c (source\src):    if((g_saved_SleepData.p_write_addr == 0)  || (g_saved_SleepData.p_read_addr == 0)) {
Bd_sync_data.c (source\src):        g_saved_SleepData.p_write_addr = (uint32_t *)SLEEP_DATA_BASE_ADDR;
Bd_sync_data.c (source\src):        g_saved_SleepData.p_read_addr = (uint32_t *)SLEEP_DATA_BASE_ADDR;
Bd_sync_data.c (source\src):    address = g_saved_SleepData.p_write_addr;
Bd_sync_data.c (source\src):    if((*address != 0xFFFFFFFF) || (*(address + 1) != 0xFFFFFFFF)) {
Bd_sync_data.c (source\src):        ble_flash_page_erase(get_flash_page_number(g_saved_SleepData.p_write_addr));
Bd_sync_data.c (source\src):        g_saved_SleepData.p_write_addr = (uint32_t *)(BLE_FLASH_PAGE_SIZE * (get_flash_page_number(g_saved_SleepData.p_write_addr)));
Bd_sync_data.c (source\src):        if(get_flash_page_number(g_saved_SleepData.p_write_addr) == get_flash_page_number(g_saved_SleepData.p_read_addr)) {
Bd_sync_data.c (source\src):            g_saved_SleepData.p_read_addr = g_saved_SleepData.p_write_addr;
Bd_sync_data.c (source\src):    uint32_t *address = NULL;
Bd_sync_data.c (source\src):    if((g_saved_SportsData.p_write_addr == 0) || (g_saved_SportsData.p_read_addr == 0)) {
Bd_sync_data.c (source\src):        g_saved_SportsData.p_write_addr = (uint32_t *)SPORTS_DATA_BASE_ADDR;
Bd_sync_data.c (source\src):        g_saved_SportsData.p_read_addr  = (uint32_t *)SPORTS_DATA_BASE_ADDR;
Bd_sync_data.c (source\src):    address = g_saved_SportsData.p_write_addr;
Bd_sync_data.c (source\src):    if((*address != 0xFFFFFFFF) || *(address + 1) != 0xFFFFFFFF) {
Bd_sync_data.c (source\src):        ble_flash_page_erase(get_flash_page_number(g_saved_SportsData.p_write_addr));
Bd_sync_data.c (source\src):        g_saved_SportsData.p_write_addr = (uint32_t *)(BLE_FLASH_PAGE_SIZE * (get_flash_page_number(g_saved_SportsData.p_write_addr)));
Bd_sync_data.c (source\src):        if(get_flash_page_number(g_saved_SportsData.p_write_addr) == get_flash_page_number(g_saved_SportsData.p_read_addr)) {
Bd_sync_data.c (source\src):            g_saved_SportsData.p_read_addr = g_saved_SportsData.p_write_addr;
Bd_sync_data.c (source\src):uint32_t get_flash_page_number(uint32_t * address)
Bd_sync_data.c (source\src):    return ((uint32_t)address/BLE_FLASH_PAGE_SIZE);
Bd_sync_data.c (source\src):    //no data to read
Bd_sync_data.c (source\src):    if(g_saved_SleepData.p_read_addr == g_saved_SleepData.p_write_addr) {
Bd_sync_data.c (source\src):    return (mSleepHead.length != 0);
Bd_sync_data.c (source\src):uint32_t* get_next_sleep_read_group_address(void )
Bd_sync_data.c (source\src):    uint32_t* next_read_address = NULL;
Bd_sync_data.c (source\src)://        LOG(LEVEL_INFO,"get_next_sleep_read_group_address \n");;
Bd_sync_data.c (source\src):    LOG(LEVEL_INFO," g_saved_SleepData.p_read_addr:0x%x  \n",g_saved_SleepData.p_read_addr);
Bd_sync_data.c (source\src):    //if the next read group is in same page
Bd_sync_data.c (source\src):    if(get_flash_page_number(g_saved_SleepData.p_read_addr)
Bd_sync_data.c (source\src):       == get_flash_page_number(g_saved_SleepData.p_read_addr + ((2*ONE_SLEEP_GROUP_SIZE)/4) )) {
Bd_sync_data.c (source\src):        next_read_address =  g_saved_SleepData.p_read_addr + (ONE_SLEEP_GROUP_SIZE/4);
Bd_sync_data.c (source\src):        if(get_flash_page_number(g_saved_SleepData.p_read_addr) + 1 < SLEEP_DATA_END_PAGE ) {
Bd_sync_data.c (source\src):            next_read_address = (uint32_t* )( BLE_FLASH_PAGE_SIZE*(get_flash_page_number(g_saved_SleepData.p_read_addr) + 1));
Bd_sync_data.c (source\src):            next_read_address =  (uint32_t* )( BLE_FLASH_PAGE_SIZE*SLEEP_DATA_BASE_PAGE);
Bd_sync_data.c (source\src):    LOG(LEVEL_INFO," next_read_address:0x%x  \n",next_read_address);
Bd_sync_data.c (source\src):    return next_read_address;
Bd_sync_data.c (source\src):uint32_t* get_next_sleep_write_group_address(void)
Bd_sync_data.c (source\src):    uint32_t* next_write_address = NULL;
Bd_sync_data.c (source\src)://         LOG(LEVEL_INFO,"get_next_sleep_write_group_address \n");
Bd_sync_data.c (source\src):    LOG(LEVEL_INFO,"p_write_addr:0x%x  \n",g_saved_SleepData.p_write_addr);
Bd_sync_data.c (source\src):    if(get_flash_page_number(g_saved_SleepData.p_write_addr + (3*ONE_SLEEP_GROUP_SIZE)/4 )
Bd_sync_data.c (source\src):       != get_flash_page_number(g_saved_SleepData.p_write_addr)
Bd_sync_data.c (source\src):       && get_flash_page_number(g_saved_SleepData.p_write_addr + (2*ONE_SLEEP_GROUP_SIZE)/4 )
Bd_sync_data.c (source\src):       == get_flash_page_number(g_saved_SleepData.p_write_addr )) {
Bd_sync_data.c (source\src):        LOG(LEVEL_INFO,"need to erase next page: p_write_addr:0x%x \n",g_saved_SleepData.p_write_addr);
Bd_sync_data.c (source\src):        if(get_flash_page_number(g_saved_SleepData.p_write_addr) + 1 < SLEEP_DATA_END_PAGE ) {
Bd_sync_data.c (source\src):            ble_flash_page_delay_erase(get_flash_page_number(g_saved_SleepData.p_write_addr) + 1);
Bd_sync_data.c (source\src):            if((uint32_t)g_saved_SleepData.p_read_addr >= BLE_FLASH_PAGE_SIZE*(get_flash_page_number(g_saved_SleepData.p_write_addr) + 1)
Bd_sync_data.c (source\src):               && (uint32_t)g_saved_SleepData.p_read_addr < BLE_FLASH_PAGE_SIZE + BLE_FLASH_PAGE_SIZE*(get_flash_page_number(g_saved_SleepData.p_write_addr) + 1)  ) {
Bd_sync_data.c (source\src):                if(get_flash_page_number(g_saved_SleepData.p_read_addr) + 1 == SLEEP_DATA_END_PAGE) {
Bd_sync_data.c (source\src):                    g_saved_SleepData.p_read_addr = (uint32_t* )(BLE_FLASH_PAGE_SIZE*SLEEP_DATA_BASE_PAGE);
Bd_sync_data.c (source\src):                    g_saved_SleepData.p_read_addr =  (uint32_t* )(BLE_FLASH_PAGE_SIZE*(get_flash_page_number(g_saved_SleepData.p_read_addr) + 1));
Bd_sync_data.c (source\src):            if((uint32_t )g_saved_SleepData.p_read_addr >= BLE_FLASH_PAGE_SIZE*SLEEP_DATA_BASE_PAGE
Bd_sync_data.c (source\src):               && (uint32_t)g_saved_SleepData.p_read_addr < BLE_FLASH_PAGE_SIZE + BLE_FLASH_PAGE_SIZE*SLEEP_DATA_BASE_PAGE  ) {
Bd_sync_data.c (source\src):                g_saved_SleepData.p_read_addr =  (uint32_t* )(BLE_FLASH_PAGE_SIZE*(get_flash_page_number(g_saved_SleepData.p_read_addr) + 1));
Bd_sync_data.c (source\src):    //if the next read group is in same page
Bd_sync_data.c (source\src):    if(get_flash_page_number(g_saved_SleepData.p_write_addr)
Bd_sync_data.c (source\src):       == get_flash_page_number(g_saved_SleepData.p_write_addr + ((2*ONE_SLEEP_GROUP_SIZE)/4) ) ) {
Bd_sync_data.c (source\src):        next_write_address =  (uint32_t* )(g_saved_SleepData.p_write_addr + (ONE_SLEEP_GROUP_SIZE/4));
Bd_sync_data.c (source\src):        if(get_flash_page_number(g_saved_SleepData.p_write_addr) + 1 < SLEEP_DATA_END_PAGE ) {
Bd_sync_data.c (source\src):            next_write_address =  (uint32_t* )(BLE_FLASH_PAGE_SIZE*(get_flash_page_number(g_saved_SleepData.p_write_addr) + 1));
Bd_sync_data.c (source\src):            next_write_address =  (uint32_t* )(BLE_FLASH_PAGE_SIZE*SLEEP_DATA_BASE_PAGE);
Bd_sync_data.c (source\src):    LOG(LEVEL_INFO,"next_write_address:0x%x  \n",next_write_address);
Bd_sync_data.c (source\src):    return next_write_address;
Bd_sync_data.c (source\src):    if(g_saved_SportsData.p_read_addr == g_saved_SportsData.p_write_addr) {
Bd_sync_data.c (source\src):    return ((mSportHead.length != 0) && (mSportsData.bits.steps != 0));
Bd_sync_data.c (source\src):    return (mSportHead.length > 1);
Bd_sync_data.c (source\src):uint32_t* get_next_sport_read_group_address(void )
Bd_sync_data.c (source\src):    uint32_t* next_read_address = NULL;
Bd_sync_data.c (source\src)://        LOG(LEVEL_INFO,"get_next_sport_read_group_address \n");
Bd_sync_data.c (source\src):    LOG(LEVEL_INFO," p_read_addr:0x%x  \n",g_saved_SportsData.p_read_addr);
Bd_sync_data.c (source\src):    //if the next read group is in same page
Bd_sync_data.c (source\src):    if(get_flash_page_number(g_saved_SportsData.p_read_addr)
Bd_sync_data.c (source\src):       == get_flash_page_number(g_saved_SportsData.p_read_addr + ((2*ONE_SPORTS_GROUP_SIZE)/4) )) {
Bd_sync_data.c (source\src):        next_read_address =  (uint32_t* )(g_saved_SportsData.p_read_addr + (ONE_SPORTS_GROUP_SIZE/4));
Bd_sync_data.c (source\src):        if(get_flash_page_number(g_saved_SportsData.p_read_addr) + 1 < SPORTS_DATA_END_PAGE ) {
Bd_sync_data.c (source\src):            next_read_address =  (uint32_t* )(BLE_FLASH_PAGE_SIZE*(get_flash_page_number(g_saved_SportsData.p_read_addr) + 1));
Bd_sync_data.c (source\src):            next_read_address =  (uint32_t* )(BLE_FLASH_PAGE_SIZE*SPORTS_DATA_BASE_PAGE);
Bd_sync_data.c (source\src):    LOG(LEVEL_INFO," next_read_address:0x%x  \n",next_read_address);
Bd_sync_data.c (source\src):    return next_read_address;
Bd_sync_data.c (source\src):uint32_t* get_next_sport_write_group_address(void)
Bd_sync_data.c (source\src):    uint32_t* next_write_address = NULL;
Bd_sync_data.c (source\src)://         LOG(LEVEL_INFO,"get_next_sport_write_group_address");
Bd_sync_data.c (source\src):    LOG(LEVEL_INFO," p_write_addr:0x%x  \n",g_saved_SportsData.p_write_addr);
Bd_sync_data.c (source\src):    if(get_flash_page_number(g_saved_SportsData.p_write_addr + ((3*ONE_SPORTS_GROUP_SIZE)/4) )
Bd_sync_data.c (source\src):       != get_flash_page_number(g_saved_SportsData.p_write_addr)
Bd_sync_data.c (source\src):       && get_flash_page_number(g_saved_SportsData.p_write_addr + ((2*ONE_SPORTS_GROUP_SIZE)/4) )
Bd_sync_data.c (source\src):       == get_flash_page_number(g_saved_SportsData.p_write_addr)) {
Bd_sync_data.c (source\src):        LOG(LEVEL_INFO,"need to erase next page: p_write_addr:0x%x \n",g_saved_SportsData.p_write_addr);
Bd_sync_data.c (source\src):        if(get_flash_page_number(g_saved_SportsData.p_write_addr) + 1 < SPORTS_DATA_END_PAGE ) {
Bd_sync_data.c (source\src):            ble_flash_page_delay_erase(get_flash_page_number(g_saved_SportsData.p_write_addr) + 1);
Bd_sync_data.c (source\src):            if((uint32_t)(g_saved_SportsData.p_read_addr) >= BLE_FLASH_PAGE_SIZE*(get_flash_page_number(g_saved_SportsData.p_write_addr) + 1)
Bd_sync_data.c (source\src):               && (uint32_t)(g_saved_SportsData.p_read_addr) < BLE_FLASH_PAGE_SIZE + BLE_FLASH_PAGE_SIZE*(get_flash_page_number(g_saved_SportsData.p_write_addr) + 1)  ) {
Bd_sync_data.c (source\src):                if(get_flash_page_number(g_saved_SportsData.p_read_addr) + 1 == SPORTS_DATA_END_PAGE) {
Bd_sync_data.c (source\src):                    g_saved_SportsData.p_read_addr = (uint32_t* )(BLE_FLASH_PAGE_SIZE*SPORTS_DATA_BASE_PAGE);
Bd_sync_data.c (source\src):                    g_saved_SportsData.p_read_addr =  (uint32_t* )(BLE_FLASH_PAGE_SIZE*(get_flash_page_number(g_saved_SportsData.p_read_addr) + 1));
Bd_sync_data.c (source\src):            if((uint32_t)(g_saved_SportsData.p_read_addr) >= BLE_FLASH_PAGE_SIZE*SPORTS_DATA_BASE_PAGE
Bd_sync_data.c (source\src):               && (uint32_t)(g_saved_SportsData.p_read_addr) < BLE_FLASH_PAGE_SIZE + BLE_FLASH_PAGE_SIZE*SPORTS_DATA_BASE_PAGE  ) {
Bd_sync_data.c (source\src):                g_saved_SportsData.p_read_addr =  (uint32_t* )(BLE_FLASH_PAGE_SIZE*(get_flash_page_number(g_saved_SportsData.p_read_addr) + 1));
Bd_sync_data.c (source\src):    //if the next read group is in same page
Bd_sync_data.c (source\src):    if(get_flash_page_number(g_saved_SportsData.p_write_addr)
Bd_sync_data.c (source\src):       == get_flash_page_number(g_saved_SportsData.p_write_addr + ((2*ONE_SPORTS_GROUP_SIZE)/4) )) {
Bd_sync_data.c (source\src):        next_write_address = (uint32_t* )(g_saved_SportsData.p_write_addr + (ONE_SPORTS_GROUP_SIZE/4));
Bd_sync_data.c (source\src):        if(get_flash_page_number(g_saved_SportsData.p_write_addr) + 1 < SPORTS_DATA_END_PAGE ) {
Bd_sync_data.c (source\src):            next_write_address = (uint32_t* )(BLE_FLASH_PAGE_SIZE*(get_flash_page_number(g_saved_SportsData.p_write_addr) + 1));
Bd_sync_data.c (source\src):            next_write_address =  (uint32_t* )(BLE_FLASH_PAGE_SIZE*SPORTS_DATA_BASE_PAGE);
Bd_sync_data.c (source\src):    LOG(LEVEL_INFO," next_write_address:0x%x  \n",next_write_address);
Bd_sync_data.c (source\src):    return next_write_address;
Bd_sync_data.c (source\src):static int set_sport_data_buffer_header(char * buffer, SportsHead_t* header)
Bd_sync_data.c (source\src):    L2DataHeader_t mSportsDataHeader;
Bd_sync_data.c (source\src):    if(NULL== buffer || NULL == header) {
Bd_sync_data.c (source\src):    sportsDataLen = (header->length<<3) + sizeof(SportsHead_t);// mSportHead.length * 8 + 4
Bd_sync_data.c (source\src):    mSportsDataHeader.cmd_ID = HEALTH_DATA_COMMAND_ID;
Bd_sync_data.c (source\src):    mSportsDataHeader.version = L2_HEADER_VERSION;
Bd_sync_data.c (source\src):    mSportsDataHeader.key = KEY_RETURN_SPORTS_DATA;
Bd_sync_data.c (source\src):    mSportsDataHeader.key_header.data= sportsDataLen & 0x01ff; // 9bit
Bd_sync_data.c (source\src):    buffer[0] = mSportsDataHeader.cmd_ID; //L2 commandID
Bd_sync_data.c (source\src):    buffer[1] = mSportsDataHeader.version; //
Bd_sync_data.c (source\src):    buffer[2] = mSportsDataHeader.key;
Bd_sync_data.c (source\src):    buffer[3] = mSportsDataHeader.key_header.data>>8;
Bd_sync_data.c (source\src):    buffer[4] = mSportsDataHeader.key_header.data&0xff;
Bd_sync_data.c (source\src):    buffer[5] = header->Date.data>>8;
Bd_sync_data.c (source\src):    buffer[6] = header->Date.data;
Bd_sync_data.c (source\src):    buffer[7] = header->key;
Bd_sync_data.c (source\src):    buffer[8] = header->length;
Bd_sync_data.c (source\src):static int set_sleep_data_buffer_header(char * buffer, SleepHead_t* header)
Bd_sync_data.c (source\src):    L2DataHeader_t mSleepDataHeader;
Bd_sync_data.c (source\src):    if(NULL== buffer || NULL == header) {
Bd_sync_data.c (source\src):    sleepDataLen = (header->length<<2) + sizeof(SleepHead_t);
Bd_sync_data.c (source\src):    mSleepDataHeader.cmd_ID = HEALTH_DATA_COMMAND_ID;
Bd_sync_data.c (source\src):    mSleepDataHeader.version = L2_HEADER_VERSION;
Bd_sync_data.c (source\src):    mSleepDataHeader.key = KEY_RETURN_SLEEP_DATA;
Bd_sync_data.c (source\src):    mSleepDataHeader.key_header.data= sleepDataLen & 0x01ff; // 9bit length
Bd_sync_data.c (source\src):    buffer[0] = mSleepDataHeader.cmd_ID; //L2 commandID
Bd_sync_data.c (source\src):    buffer[1] = mSleepDataHeader.version; //
Bd_sync_data.c (source\src):    buffer[2] = mSleepDataHeader.key;
Bd_sync_data.c (source\src):    buffer[3] = mSleepDataHeader.key_header.data>>8;
Bd_sync_data.c (source\src):    buffer[4] = mSleepDataHeader.key_header.data&0xff;
Bd_sync_data.c (source\src):    buffer[5] = header->Date.data>>8;
Bd_sync_data.c (source\src):    buffer[6] = header->Date.data;
Bd_sync_data.c (source\src):    buffer[7] = header->length >> 8;
Bd_sync_data.c (source\src):    buffer[8] = header->length;
Bd_sync_data.c (source\src):    int L1_payload_length = 0;
Bd_sync_data.c (source\src):    L1_payload_length = set_sport_data_buffer_header((char *)g_sports_send_buffer, &mSportHead);
Bd_sync_data.c (source\src):    if(NRF_SUCCESS != ble_flash_block_write(g_saved_SportsData.p_write_addr,(uint32_t* )g_sports_send_buffer,(L1_payload_length+3)/4)) {
Bd_sync_data.c (source\src):    g_saved_SportsData.p_write_addr = get_next_sport_write_group_address();
Bd_sync_data.c (source\src):    mSportHead.length = 0;
Bd_sync_data.c (source\src):    uint8_t *read_address = NULL;
Bd_sync_data.c (source\src):    LOG(LEVEL_INFO,"p_read_addr: 0x%x \n",g_saved_SportsData.p_read_addr);
Bd_sync_data.c (source\src):    read_address = (uint8_t*)(g_saved_SportsData.p_read_addr);
Bd_sync_data.c (source\src):        LOG(LEVEL_INFO,"read_address[%d]: 0x%x \n",i,read_address[i]);
Bd_sync_data.c (source\src):    sentLen = read_address[3];
Bd_sync_data.c (source\src):    sentLen += read_address[4];
Bd_sync_data.c (source\src):    sendContent.content  = (uint8_t *)read_address;
Bd_sync_data.c (source\src):    g_saved_SportsData.p_read_addr = get_next_sport_read_group_address();
Bd_sync_data.c (source\src):    uint8_t *read_address = NULL;
Bd_sync_data.c (source\src):    LOG(LEVEL_INFO,"p_read_addr: 0x%x \n",g_saved_SleepData.p_read_addr);
Bd_sync_data.c (source\src):    read_address =(uint8_t*)( g_saved_SleepData.p_read_addr);
Bd_sync_data.c (source\src):        LOG(LEVEL_INFO,"read_address[%d]: 0x%x \n",i,read_address[i]);
Bd_sync_data.c (source\src):    sentLen = read_address[3];
Bd_sync_data.c (source\src):    sentLen += read_address[4];
Bd_sync_data.c (source\src):    sendContent.content  = (uint8_t *)read_address;
Bd_sync_data.c (source\src):void update_sleep_head(void)
Bd_sync_data.c (source\src):    mSleepHead.Date.date.year = tm->year - 2000;
Bd_sync_data.c (source\src):    mSleepHead.Date.date.month= tm->month;
Bd_sync_data.c (source\src):    mSleepHead.Date.date.day = tm->day;
Bd_sync_data.c (source\src):    mSleepHead.length = 0;
Bd_sync_data.c (source\src):void reset_sleep_head(void)
Bd_sync_data.c (source\src):    update_sleep_head();
Bd_sync_data.c (source\src):    g_saved_SleepData.p_read_addr = get_next_sleep_read_group_address();
Bd_sync_data.c (source\src):void update_sports_head(void)
Bd_sync_data.c (source\src):    mSportHead.Date.date.day = tm->day;
Bd_sync_data.c (source\src):    mSportHead.Date.date.month = tm->month;
Bd_sync_data.c (source\src):    mSportHead.Date.date.year = tm->year-2000;
Bd_sync_data.c (source\src):    mSportHead.length = 0;
Bd_sync_data.c (source\src):void reset_sports_head(void)
Bd_sync_data.c (source\src):    mSportHead.Date.date.day = tm->day;
Bd_sync_data.c (source\src):    mSportHead.Date.date.month = tm->month;
Bd_sync_data.c (source\src):    mSportHead.Date.date.year = tm->year-2000;
Bd_sync_data.c (source\src):    mSportHead.length = 0;
Bd_sync_data.c (source\src):    update_sports_head();
Bd_sync_data.c (source\src):    int L1_payload_length = 0;
Bd_sync_data.c (source\src):        // when comming here, mSportHead.length shall not be 0
Bd_sync_data.c (source\src):        g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 0] = mSportsData.data >> 56; //OFFSET
Bd_sync_data.c (source\src):        g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 1] = mSportsData.data >> 48;
Bd_sync_data.c (source\src):        g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 2] = mSportsData.data >> 40;
Bd_sync_data.c (source\src):        g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 3] = mSportsData.data >> 32;
Bd_sync_data.c (source\src):        g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 4] = mSportsData.data >> 24;
Bd_sync_data.c (source\src):        g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 5] = mSportsData.data >> 16;
Bd_sync_data.c (source\src):        g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 6] = mSportsData.data >> 8;
Bd_sync_data.c (source\src):        g_sports_send_buffer[SPORT_HEAD_LEN + ((mSportHead.length-1) <<3) + 7] = mSportsData.data;
Bd_sync_data.c (source\src):    /******SportHead******/
Bd_sync_data.c (source\src):    L1_payload_length = set_sport_data_buffer_header((char *)g_sports_send_buffer,&mSportHead);
Bd_sync_data.c (source\src):    sendContent.length   = L1_payload_length;
Bd_sync_data.c (source\src):    update_sleep_head();
Bd_sync_data.c (source\src):    int  L1_payload_length = 0;
Bd_sync_data.c (source\src):    /******SportHead******/
Bd_sync_data.c (source\src):    L1_payload_length = set_sleep_data_buffer_header((char *)g_sleep_send_buffer, &mSleepHead);
Bd_sync_data.c (source\src):    sendContent.length   = L1_payload_length;
Bd_sync_data.c (source\src):    int L1_payload_length = 0;
Bd_sync_data.c (source\src):    L1_payload_length = set_sleep_data_buffer_header((char *)g_sleep_send_buffer, &mSleepHead);
Bd_sync_data.c (source\src):    LOG(LEVEL_INFO,"p_write_addr: 0x%x \n",i,g_saved_SleepData.p_write_addr);
Bd_sync_data.c (source\src):    if(NRF_SUCCESS != ble_flash_block_write(g_saved_SleepData.p_write_addr ,(uint32_t* )g_sleep_send_buffer,(L1_payload_length+3)/4)) {
Bd_sync_data.c (source\src):    g_saved_SleepData.p_write_addr = get_next_sleep_write_group_address();
Bd_sync_data.c (source\src):    mSleepHead.length = 0;
Bd_sync_data.c (source\src):    int sleepHead_minutes;
Bd_sync_data.c (source\src):    time_union_t sleep_head_time;
Bd_sync_data.c (source\src):    sleep_head_time.data = 0;
Bd_sync_data.c (source\src):    sleep_head_time.time.year = mSleepHead.Date.date.year;
Bd_sync_data.c (source\src):    sleep_head_time.time.month= mSleepHead.Date.date.month;
Bd_sync_data.c (source\src):    sleep_head_time.time.day= mSleepHead.Date.date.day;
Bd_sync_data.c (source\src):    sleepHead_minutes = convert_time_to_Second(sleep_head_time)/60;
Bd_sync_data.c (source\src):    mSleepData.bits.timeStamp = (uint16_t)(sleep_minutes - sleepHead_minutes);
Bd_sync_data.c (source\src):    mSleepHead.length ++;
Bd_sync_data.c (source\src):    g_sleep_send_buffer[SPORT_HEAD_LEN + ((mSleepHead.length-1) <<2) + 0] = mSleepData.data >> 24; //OFFSET
Bd_sync_data.c (source\src):    g_sleep_send_buffer[SPORT_HEAD_LEN + ((mSleepHead.length-1) <<2) + 1] = mSleepData.data >> 16; // reserved
Bd_sync_data.c (source\src):    g_sleep_send_buffer[SPORT_HEAD_LEN + ((mSleepHead.length-1) <<2) + 2] = mSleepData.data >> 8; // reserved
Bd_sync_data.c (source\src):    g_sleep_send_buffer[SPORT_HEAD_LEN + ((mSleepHead.length-1) <<2) + 3] = mSleepData.data;
Bd_sync_data.c (source\src):    LOG(LEVEL_INFO,"sleep_head: %d-%d-%d",mSleepHead.Date.date.year, mSleepHead.Date.date.month, mSleepHead.Date.date.day);
Bd_sync_data.c (source\src):    LOG(LEVEL_INFO,"sleep_minutes : %d-sleepHead_minutes %d", sleep_minutes, sleepHead_minutes);
Bd_sync_data.c (source\src):    if(mSleepHead.length >= SLEEP_MAX_GROUP_NUM) {
Bd_sync_data.c (source\src):        save_sleep_group_data((uint8_t)mSleepHead.length);
Bd_sync_data.c (source\src):    save_sleep_group_data((uint8_t)mSleepHead.length);
Bd_sync_data.c (source\src):    save_sport_group_data(mSportHead.length);
Bd_sync_data.c (source\src):    uint32_t *p_address = (uint32_t *)(FLASH_PAGE_SIZE * FLASH_PAGE_HEALTH_DATA);
Bd_sync_data.c (source\src):    uint32_t *flash_addr = NULL;
Bd_sync_data.c (source\src):    uint8_t *addr = NULL;
Bd_sync_data.c (source\src):    for(flash_addr = p_address,value = 0; value< FLASH_PAGE_SIZE/2; value ++) {
Bd_sync_data.c (source\src):        ble_flash_word_write(flash_addr++,value);
Bd_sync_data.c (source\src):        //ble_nus_send_string(&m_nus,(uint8_t *) p_address,&len);
Bd_sync_data.c (source\src):    sendContent.content  = (uint8_t *)p_address;
Bd_sync_data.c (source\src):    for(addr = (uint8_t *)p_address ; addr < (uint8_t *)p_address + 128; addr ++)
Bd_sync_data.c (source\src):        simple_uart_put(*addr);
Bd_sync_data.c (source\src):    uint32_t *  address = NULL;
Bd_sync_data.c (source\src):    uint8_t header[4];
Bd_sync_data.c (source\src):        ble_flash_page_addr(page_num , &address);
Bd_sync_data.c (source\src):        memcpy((char *)header,(char *)address,4);
Bd_sync_data.c (source\src):        LOG(LEVEL_INFO,"sports data paga %d first word :%x,%x,%x,%x",page_num,header[0],header[1],header[2],header[3]);
Bd_sync_data.c (source\src):        if((header[0] == 0xff) && (header[1] == 0xff) && (header[2] == 0xff) && (header[3] == 0xff)) {
Bd_sync_data.c (source\src):        if((header[0] != HEALTH_DATA_COMMAND_ID) ||  (header[1] != L2_HEADER_VERSION ) || (header[2] != KEY_RETURN_SPORTS_DATA)) {
Bd_sync_data.c (source\src):    uint32_t *  address = NULL;
Bd_sync_data.c (source\src):    uint8_t header[4];
Bd_sync_data.c (source\src):        ble_flash_page_addr(page_num , &address);
Bd_sync_data.c (source\src):        memcpy((char *)header,(char *)address,4);
Bd_sync_data.c (source\src):        LOG(LEVEL_INFO,"sleep data paga %d first word :%x,%x,%x,%x",page_num,header[0],header[1],header[2],header[3]);
Bd_sync_data.c (source\src):        if((header[0] == 0xff) && (header[1] == 0xff) && (header[2] == 0xff) && (header[3] == 0xff)) {
Bd_sync_data.c (source\src):        if((header[0] != HEALTH_DATA_COMMAND_ID) ||  (header[1] != L2_HEADER_VERSION ) || (header[2] != KEY_RETURN_SLEEP_DATA)) {
Bd_sync_data.h (source\inc):#define SPORTS_DATA_BASE_ADDR  (FLASH_PAGE_HEALTH_DATA * FLASH_PAGE_SIZE)
Bd_sync_data.h (source\inc):#define SLEEP_DATA_BASE_ADDR  (SLEEP_DATA_BASE_PAGE * FLASH_PAGE_SIZE)
Bd_sync_data.h (source\inc):L1L2Protocal_Head_t;
Bd_sync_data.h (source\inc):    uint32_t *  p_read_addr;
Bd_sync_data.h (source\inc):    uint32_t *  p_write_addr;  
Bd_sync_data.h (source\inc):void update_sleep_head(void);
Bd_sync_data.h (source\inc):void update_sports_head(void);
Bd_sync_data.h (source\inc):void reset_sleep_head(void);
Bd_sync_data.h (source\inc):void reset_sports_head(void);
Bd_twi_hw_master.c (source\src): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Bd_twi_hw_master.c (source\src):/* Max cycles approximately to wait on RXDREADY and TXDREADY event, this is optimum way instead of using timers, this is not power aware, negetive side is this is not power aware */
Bd_twi_hw_master.c (source\src):static bool twi_master_read(uint8_t *data, uint8_t data_length, bool issue_stop_condition)
Bd_twi_hw_master.c (source\src):    uint32_t timeout = MAX_TIMEOUT_LOOPS;   /* max loops to wait for RXDREADY event*/
Bd_twi_hw_master.c (source\src):        while((NRF_TWI1->EVENTS_RXDREADY == 0) && (--timeout)) {  //nrf_app_event_wait();
Bd_twi_hw_master.c (source\src):        NRF_TWI1->EVENTS_RXDREADY = 0;
Bd_twi_hw_master.c (source\src):    if (TWI_SDA_READ() == 1 && TWI_SCL_READ() == 1) {
Bd_twi_hw_master.c (source\src):            if (TWI_SDA_READ() == 1) {
Bd_twi_hw_master.c (source\src):    NRF_TWI1->EVENTS_RXDREADY = 0;
Bd_twi_hw_master.c (source\src):bool twi_master_transfer(uint8_t address, uint8_t *data, uint8_t data_length, bool issue_stop_condition)
Bd_twi_hw_master.c (source\src):        NRF_TWI1->ADDRESS = (address >> 1);
Bd_twi_hw_master.c (source\src):        if ((address & TWI_READ_BIT) != 0) {
Bd_twi_hw_master.c (source\src):            transfer_succeeded = twi_master_read(data, data_length, issue_stop_condition);
Bd_wall_clock_timer.c (source\src):    SecondCountRTC = 0;       /* This should read from flash */
Bd_wall_clock_timer.c (source\src):               global_reponse_buffer[1] = L2_HEADER_VERSION;   /*L2 header version */
Bd_wall_clock_timer.c (source\src):               sendContent.length   = L2_HEADER_SIZE + L2_PAYLOAD_HEADER_SIZE + global_reponse_buffer[4]; /*length of whole L2*/
Bd_wdt.c (source\src):#define RELOAD_COUNT (32768*60*3-1)    //3 minutes
Bd_wdt.c (source\src):    NRF_WDT->CRV = RELOAD_COUNT;
Bd_wdt.c (source\src):        NRF_WDT->RR[0] = WDT_RR_RR_Reload;
Bd_work_state.h (source\inc):    ADVERTISING,
Ble.h (nrf51822\include\ble\softdevice):  @addtogroup BLE_COMMON BLE SoftDevice Common
Ble.h (nrf51822\include\ble\softdevice):  SD_BLE_UUID_VS_ADD,                   /**< Add a Vendor Specific UUID. */
Ble.h (nrf51822\include\ble\softdevice):/**@brief BLE Event header. */
Ble.h (nrf51822\include\ble\softdevice):  uint16_t evt_len;                     /**< Length in octets excluding this header. */
Ble.h (nrf51822\include\ble\softdevice):  ble_evt_hdr_t header;                 /**< Event header. */
Ble.h (nrf51822\include\ble\softdevice): * The application is free to choose whether to call this function from thread mode (main context) or directly from the Interrupt Service Routine
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid or not sufficiently aligned pointer supplied.
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_NOT_FOUND No events ready to be pulled.
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_DATA_SIZE Event ready but could not fit into the supplied buffer.
Ble.h (nrf51822\include\ble\softdevice): *          it should retrieve the count field in such event and add that number to the same
Ble.h (nrf51822\include\ble\softdevice): *          - Choose to simply not keep track of available buffers at all, and instead handle the 
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble.h (nrf51822\include\ble\softdevice):/**@brief Add a Vendor Specific UUID.
Ble.h (nrf51822\include\ble\softdevice): * @details This call enables the application to add a vendor specific UUID to the BLE stack's table,
Ble.h (nrf51822\include\ble\softdevice): *          UUIDs available to the application is therefore the number of Vendor Specific UUIDs added with the help
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS Successfully added the Vendor Specific UUID.
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR if p_vs_uuids is NULL or invalid.
Ble.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_UUID_VS_ADD, uint32_t, sd_ble_uuid_vs_add(ble_uuid128_t const * const p_vs_uuid, uint8_t * const p_uuid_type));
Ble.h (nrf51822\include\ble\softdevice): * to the corresponding ones in each entry of the table of vendor specific UUIDs pouplated with @ref sd_ble_uuid_vs_add 
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_advdata.c (nrf51822\source\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_advdata.c (nrf51822\source\ble):#include "ble_advdata.h"
Ble_advdata.c (nrf51822\source\ble)://       from the advertising data.
Ble_advdata.c (nrf51822\source\ble):static uint32_t name_encode(const ble_advdata_t * p_advdata,
Ble_advdata.c (nrf51822\source\ble):    uint16_t name_length = BLE_GAP_ADV_MAX_SIZE - (2 + *p_len);
Ble_advdata.c (nrf51822\source\ble):    uint8_t  adv_data_format;
Ble_advdata.c (nrf51822\source\ble):    if ((p_advdata->short_name_len != 0) && (name_length > p_advdata->short_name_len))
Ble_advdata.c (nrf51822\source\ble):        name_length     = p_advdata->short_name_len;
Ble_advdata.c (nrf51822\source\ble):        adv_data_format = BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME;
Ble_advdata.c (nrf51822\source\ble):        adv_data_format = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
Ble_advdata.c (nrf51822\source\ble):    p_encoded_data[(*p_len)++] = adv_data_format;
Ble_advdata.c (nrf51822\source\ble):    if ((*p_len) + 4 > BLE_GAP_ADV_MAX_SIZE)
Ble_advdata.c (nrf51822\source\ble):    // Encode Length, AD Type and Appearance.
Ble_advdata.c (nrf51822\source\ble):    p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_APPEARANCE;
Ble_advdata.c (nrf51822\source\ble):                                   uint8_t               adv_type,
Ble_advdata.c (nrf51822\source\ble):    if ((*p_len) + 2 + p_uint8_array->size > BLE_GAP_ADV_MAX_SIZE)
Ble_advdata.c (nrf51822\source\ble):    // Encode Length and AD Type.
Ble_advdata.c (nrf51822\source\ble):    p_encoded_data[(*p_len)++] = adv_type;
Ble_advdata.c (nrf51822\source\ble):    if ((*p_len) + 3 > BLE_GAP_ADV_MAX_SIZE)
Ble_advdata.c (nrf51822\source\ble):    p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_TX_POWER_LEVEL;
Ble_advdata.c (nrf51822\source\ble):static uint32_t uuid_list_sized_encode(const ble_advdata_uuid_list_t * p_uuid_list,
Ble_advdata.c (nrf51822\source\ble):                                       uint8_t                         adv_type,
Ble_advdata.c (nrf51822\source\ble):    bool    is_heading_written = false;
Ble_advdata.c (nrf51822\source\ble):            uint8_t heading_bytes = (is_heading_written) ? 0 : 2;
Ble_advdata.c (nrf51822\source\ble):            if (*p_len + encoded_size + heading_bytes > BLE_GAP_ADV_MAX_SIZE)
Ble_advdata.c (nrf51822\source\ble):            if (!is_heading_written)
Ble_advdata.c (nrf51822\source\ble):                // Write AD structure heading.
Ble_advdata.c (nrf51822\source\ble):                p_encoded_data[(*p_len)++] = adv_type;
Ble_advdata.c (nrf51822\source\ble):                is_heading_written = true;
Ble_advdata.c (nrf51822\source\ble):    if (is_heading_written)
Ble_advdata.c (nrf51822\source\ble):static uint32_t uuid_list_encode(const ble_advdata_uuid_list_t * p_uuid_list,
Ble_advdata.c (nrf51822\source\ble):                                 uint8_t                         adv_type_16,
Ble_advdata.c (nrf51822\source\ble):                                 uint8_t                         adv_type_128,
Ble_advdata.c (nrf51822\source\ble):                                      adv_type_16,
Ble_advdata.c (nrf51822\source\ble):                                      adv_type_128,
Ble_advdata.c (nrf51822\source\ble):static uint32_t conn_int_check(const ble_advdata_conn_int_t *p_conn_int)
Ble_advdata.c (nrf51822\source\ble):static uint32_t conn_int_encode(const ble_advdata_conn_int_t * p_conn_int,
Ble_advdata.c (nrf51822\source\ble):    if ((*p_len) + 2 + 2 * sizeof(uint16_le_t) > BLE_GAP_ADV_MAX_SIZE)
Ble_advdata.c (nrf51822\source\ble):    // Encode Length and AD Type.
Ble_advdata.c (nrf51822\source\ble):    p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE;
Ble_advdata.c (nrf51822\source\ble):static uint32_t manuf_specific_data_encode(const ble_advdata_manuf_data_t * p_manuf_sp_data,
Ble_advdata.c (nrf51822\source\ble):    if ((*p_len) + 2 + data_size > BLE_GAP_ADV_MAX_SIZE)
Ble_advdata.c (nrf51822\source\ble):    // Encode Length and AD Type.
Ble_advdata.c (nrf51822\source\ble):    p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
Ble_advdata.c (nrf51822\source\ble):    // Encode additional manufacturer specific data.
Ble_advdata.c (nrf51822\source\ble):static uint32_t service_data_encode(const ble_advdata_t * p_advdata,
Ble_advdata.c (nrf51822\source\ble):    if (p_advdata->p_service_data_array == NULL)
Ble_advdata.c (nrf51822\source\ble):    for (i = 0; i < p_advdata->service_data_count; i++)
Ble_advdata.c (nrf51822\source\ble):        ble_advdata_service_data_t * p_service_data;
Ble_advdata.c (nrf51822\source\ble):        p_service_data = &p_advdata->p_service_data_array[i];
Ble_advdata.c (nrf51822\source\ble):        // Encode Length and AD Type.
Ble_advdata.c (nrf51822\source\ble):        p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_SERVICE_DATA;
Ble_advdata.c (nrf51822\source\ble):        // Encode additional service data.
Ble_advdata.c (nrf51822\source\ble):* Random device address encode
Ble_advdata.c (nrf51822\source\ble):#define RANDOM_DEVICE_ADRESS_LEN (6)
Ble_advdata.c (nrf51822\source\ble):uint32_t random_device_address_encode(uint8_t *             p_encoded_data,
Ble_advdata.c (nrf51822\source\ble):    //random device address length = 6
Ble_advdata.c (nrf51822\source\ble):    if(*p_len + 2 + RANDOM_DEVICE_ADRESS_LEN > BLE_GAP_ADV_MAX_SIZE) {
Ble_advdata.c (nrf51822\source\ble):    * Mac address
Ble_advdata.c (nrf51822\source\ble):    uint64_t mac_address;
Ble_advdata.c (nrf51822\source\ble):    mac_address = ((((uint64_t)(NRF_FICR->DEVICEADDR[1] & 0xFFFF)) << 32) | ((uint64_t)NRF_FICR->DEVICEADDR[0]));
Ble_advdata.c (nrf51822\source\ble):    p_encoded_data[(*p_len)++] = 2+ RANDOM_DEVICE_ADRESS_LEN;
Ble_advdata.c (nrf51822\source\ble):    p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_RANDOM_TARGET_ADDRESS;
Ble_advdata.c (nrf51822\source\ble):    for(i = RANDOM_DEVICE_ADRESS_LEN - 1 ;i>=0;--i) {
Ble_advdata.c (nrf51822\source\ble):       p_encoded_data[(*p_len)++] =  (mac_address >> 8*i) & 0xff;
Ble_advdata.c (nrf51822\source\ble):    //BLE_GAP_AD_TYPE_CLASS_OF_DEVICE
Ble_advdata.c (nrf51822\source\ble):    if (*p_len + 2 + sizeof(uint16_t) > BLE_GAP_ADV_MAX_SIZE) {
Ble_advdata.c (nrf51822\source\ble):    p_encoded_data[(*p_len)++] = BLE_GAP_AD_TYPE_CLASS_OF_DEVICE;
Ble_advdata.c (nrf51822\source\ble):static uint32_t adv_data_encode(const ble_advdata_t * p_advdata,
Ble_advdata.c (nrf51822\source\ble):    if (p_advdata->name_type != BLE_ADVDATA_NO_NAME)
Ble_advdata.c (nrf51822\source\ble):        err_code = name_encode(p_advdata, p_encoded_data, p_len);
Ble_advdata.c (nrf51822\source\ble):    if (p_advdata->include_appearance)
Ble_advdata.c (nrf51822\source\ble):    if (p_advdata->flags.size > 0)
Ble_advdata.c (nrf51822\source\ble):        err_code = uint8_array_encode(&p_advdata->flags,
Ble_advdata.c (nrf51822\source\ble):                                      BLE_GAP_AD_TYPE_FLAGS,
Ble_advdata.c (nrf51822\source\ble):    if (p_advdata->p_tx_power_level != NULL)
Ble_advdata.c (nrf51822\source\ble):        err_code = tx_power_level_encode(*p_advdata->p_tx_power_level, p_encoded_data, p_len);
Ble_advdata.c (nrf51822\source\ble):    if (p_advdata->uuids_more_available.uuid_cnt > 0)
Ble_advdata.c (nrf51822\source\ble):        err_code = uuid_list_encode(&p_advdata->uuids_more_available,
Ble_advdata.c (nrf51822\source\ble):                                    BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE,
Ble_advdata.c (nrf51822\source\ble):                                    BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE,
Ble_advdata.c (nrf51822\source\ble):    if (p_advdata->uuids_complete.uuid_cnt > 0)
Ble_advdata.c (nrf51822\source\ble):        err_code = uuid_list_encode(&p_advdata->uuids_complete,
Ble_advdata.c (nrf51822\source\ble):                                    BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE,
Ble_advdata.c (nrf51822\source\ble):                                    BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE,
Ble_advdata.c (nrf51822\source\ble):    if (p_advdata->uuids_solicited.uuid_cnt > 0)
Ble_advdata.c (nrf51822\source\ble):        err_code = uuid_list_encode(&p_advdata->uuids_solicited,
Ble_advdata.c (nrf51822\source\ble):                                    BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT,
Ble_advdata.c (nrf51822\source\ble):                                    BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT,
Ble_advdata.c (nrf51822\source\ble):    if (p_advdata->p_slave_conn_int != NULL)
Ble_advdata.c (nrf51822\source\ble):        err_code = conn_int_encode(p_advdata->p_slave_conn_int, p_encoded_data, p_len);
Ble_advdata.c (nrf51822\source\ble):    if (p_advdata->p_manuf_specific_data != NULL)
Ble_advdata.c (nrf51822\source\ble):        err_code = manuf_specific_data_encode(p_advdata->p_manuf_specific_data,
Ble_advdata.c (nrf51822\source\ble):    if (p_advdata->service_data_count > 0)
Ble_advdata.c (nrf51822\source\ble):        err_code = service_data_encode(p_advdata, p_encoded_data, p_len);
Ble_advdata.c (nrf51822\source\ble):static uint32_t advdata_check(const ble_advdata_t * p_advdata)
Ble_advdata.c (nrf51822\source\ble):    // Flags must be included in advertising data, and the BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED flag must be set.
Ble_advdata.c (nrf51822\source\ble):    if ((p_advdata->flags.size == 0)      ||
Ble_advdata.c (nrf51822\source\ble):        (p_advdata->flags.p_data == NULL) ||
Ble_advdata.c (nrf51822\source\ble):        ((p_advdata->flags.p_data[0] & BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED) == 0)
Ble_advdata.c (nrf51822\source\ble):static uint32_t srdata_check(const ble_advdata_t * p_srdata)
Ble_advdata.c (nrf51822\source\ble):uint32_t ble_advdata_set(const ble_advdata_t * p_advdata, const ble_advdata_t * p_srdata)
Ble_advdata.c (nrf51822\source\ble):    uint8_t   len_advdata = 0;
Ble_advdata.c (nrf51822\source\ble):    uint8_t   encoded_advdata[BLE_GAP_ADV_MAX_SIZE];
Ble_advdata.c (nrf51822\source\ble):    uint8_t   encoded_srdata[BLE_GAP_ADV_MAX_SIZE];
Ble_advdata.c (nrf51822\source\ble):    uint8_t * p_encoded_advdata;
Ble_advdata.c (nrf51822\source\ble):    // Encode advertising data (if supplied).
Ble_advdata.c (nrf51822\source\ble):    if (p_advdata != NULL)
Ble_advdata.c (nrf51822\source\ble):        err_code = advdata_check(p_advdata);
Ble_advdata.c (nrf51822\source\ble):        err_code = adv_data_encode(p_advdata, encoded_advdata, &len_advdata);
Ble_advdata.c (nrf51822\source\ble):        p_encoded_advdata = encoded_advdata;
Ble_advdata.c (nrf51822\source\ble):        p_encoded_advdata = NULL;
Ble_advdata.c (nrf51822\source\ble):        err_code = adv_data_encode(p_srdata, encoded_srdata, &len_srdata);
Ble_advdata.c (nrf51822\source\ble):    // Pass encoded advertising data and/or scan response data to the stack.
Ble_advdata.c (nrf51822\source\ble):    return sd_ble_gap_adv_data_set(p_encoded_advdata, len_advdata, p_encoded_srdata, len_srdata);
Ble_advdata.h (nrf51822\include\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_advdata.h (nrf51822\include\ble): * @defgroup ble_sdk_lib_advdata Advertising Data Encoder
Ble_advdata.h (nrf51822\include\ble): * @brief Function for encoding the advertising data and/or scan response data, and passing them to
Ble_advdata.h (nrf51822\include\ble):#ifndef BLE_ADVDATA_H__
Ble_advdata.h (nrf51822\include\ble):#define BLE_ADVDATA_H__
Ble_advdata.h (nrf51822\include\ble):/**@brief Advertising data name type. This contains the options available for the device name inside
Ble_advdata.h (nrf51822\include\ble): *        the advertising data. */
Ble_advdata.h (nrf51822\include\ble):    BLE_ADVDATA_NO_NAME,                                              /**< Include no device name in advertising data. */
Ble_advdata.h (nrf51822\include\ble):    BLE_ADVDATA_SHORT_NAME,                                           /**< Include short device name in advertising data. */
Ble_advdata.h (nrf51822\include\ble):    BLE_ADVDATA_FULL_NAME                                             /**< Include full device name in advertising data. */
Ble_advdata.h (nrf51822\include\ble):} ble_advdata_name_type_t;
Ble_advdata.h (nrf51822\include\ble):} ble_advdata_uuid_list_t;
Ble_advdata.h (nrf51822\include\ble):} ble_advdata_conn_int_t;
Ble_advdata.h (nrf51822\include\ble):    uint8_array_t                data;                                /**< Additional manufacturer specific data. */
Ble_advdata.h (nrf51822\include\ble):} ble_advdata_manuf_data_t;
Ble_advdata.h (nrf51822\include\ble):    uint8_array_t                data;                                /**< Additional service data. */
Ble_advdata.h (nrf51822\include\ble):} ble_advdata_service_data_t;
Ble_advdata.h (nrf51822\include\ble):/**@brief Advertising data structure. This contains all options and data needed for encoding and
Ble_advdata.h (nrf51822\include\ble): *        setting the advertising data. */
Ble_advdata.h (nrf51822\include\ble):    ble_advdata_name_type_t      name_type;                           /**< Type of device name. */
Ble_advdata.h (nrf51822\include\ble):    uint8_array_t                flags;                               /**< Advertising data Flags field. */
Ble_advdata.h (nrf51822\include\ble):    ble_advdata_uuid_list_t      uuids_more_available;                /**< List of UUIDs in the 'More Available' list. */
Ble_advdata.h (nrf51822\include\ble):    ble_advdata_uuid_list_t      uuids_complete;                      /**< List of UUIDs in the 'Complete' list. */
Ble_advdata.h (nrf51822\include\ble):    ble_advdata_uuid_list_t      uuids_solicited;                     /**< List of solcited UUIDs. */
Ble_advdata.h (nrf51822\include\ble):    ble_advdata_conn_int_t *     p_slave_conn_int;                    /**< Slave Connection Interval Range. */
Ble_advdata.h (nrf51822\include\ble):    ble_advdata_manuf_data_t *   p_manuf_specific_data;               /**< Manufacturer specific data. */
Ble_advdata.h (nrf51822\include\ble):    ble_advdata_service_data_t * p_service_data_array;                /**< Array of Service data structures. */
Ble_advdata.h (nrf51822\include\ble):} ble_advdata_t;
Ble_advdata.h (nrf51822\include\ble):/**@brief Function for encoding and setting the advertising data and/or scan response data.
Ble_advdata.h (nrf51822\include\ble): * @details This function encodes advertising data and/or scan response data based on the selections
Ble_advdata.h (nrf51822\include\ble): * @param[in]   p_advdata   Structure for specifying the content of the advertising data.
Ble_advdata.h (nrf51822\include\ble): *                          Set to NULL if advertising data is not to be set.
Ble_advdata.h (nrf51822\include\ble): *              into the advertising packet. The maximum size of the advertisement packet is @ref
Ble_advdata.h (nrf51822\include\ble): *              BLE_GAP_ADV_MAX_SIZE.
Ble_advdata.h (nrf51822\include\ble):uint32_t ble_advdata_set(const ble_advdata_t * p_advdata, const ble_advdata_t * p_srdata);
Ble_advdata.h (nrf51822\include\ble):#endif // BLE_ADVDATA_H__
Ble_ans_c.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_ans_c.c (nrf51822\source\ble\ble_services):#define READ_DATA_LENGTH_MIN            1                                                  /**< Minimum data length in a valid Alert Notification Read Response message. */
Ble_ans_c.c (nrf51822\source\ble\ble_services):    READ_REQ = 1,                                                                          /**< Type identifying that this tx_message is a read request. */
Ble_ans_c.c (nrf51822\source\ble\ble_services):    alert_characteristic_t   suported_unread_alert_cat;                                    /**< Characteristic for the Unread Alert category. */
Ble_ans_c.c (nrf51822\source\ble\ble_services):    alert_characteristic_t   unread_alert_status;                                          /**< Characteristic for the Unread Alert Notification. */
Ble_ans_c.c (nrf51822\source\ble\ble_services):    ans_tx_request_t         type;                                                         /**< Type of this message, i.e. read or write message. */
Ble_ans_c.c (nrf51822\source\ble\ble_services):        uint16_t             read_handle;                                                  /**< Read request message. */
Ble_ans_c.c (nrf51822\source\ble\ble_services):        if (m_tx_buffer[m_tx_index].type == READ_REQ)
Ble_ans_c.c (nrf51822\source\ble\ble_services):            err_code = sd_ble_gattc_read(m_tx_buffer[m_tx_index].conn_handle,
Ble_ans_c.c (nrf51822\source\ble\ble_services):                                         m_tx_buffer[m_tx_index].req.read_handle,
Ble_ans_c.c (nrf51822\source\ble\ble_services):    else if (m_service.unread_alert_status.handle_cccd == BLE_ANS_INVALID_HANDLE)
Ble_ans_c.c (nrf51822\source\ble\ble_services):        descriptor_handle.start_handle = m_service.unread_alert_status.handle_value + 1;
Ble_ans_c.c (nrf51822\source\ble\ble_services):        descriptor_handle.end_handle = m_service.unread_alert_status.handle_value + 1;
Ble_ans_c.c (nrf51822\source\ble\ble_services):        err_code = ble_ans_c_unread_alert_notify(p_ans, ANS_TYPE_ALL_ALERTS);
Ble_ans_c.c (nrf51822\source\ble\ble_services):            (m_service.suported_unread_alert_cat.handle_value == 0) ||
Ble_ans_c.c (nrf51822\source\ble\ble_services):            (m_service.unread_alert_status.handle_value == 0))
Ble_ans_c.c (nrf51822\source\ble\ble_services):                case BLE_UUID_UNREAD_ALERT_CHAR:
Ble_ans_c.c (nrf51822\source\ble\ble_services):                    characteristics_set(&m_service.unread_alert_status, p_char_resp);
Ble_ans_c.c (nrf51822\source\ble\ble_services):                case BLE_UUID_SUPPORTED_UNREAD_ALERT_CATEGORY_CHAR:
Ble_ans_c.c (nrf51822\source\ble\ble_services):                    characteristics_set(&m_service.suported_unread_alert_cat, p_char_resp);
Ble_ans_c.c (nrf51822\source\ble\ble_services):    else if (p_service->unread_alert_status.handle_value == (p_desc_resp->handle - 1) &&
Ble_ans_c.c (nrf51822\source\ble\ble_services):        p_service->unread_alert_status.handle_cccd = p_desc_resp->handle;
Ble_ans_c.c (nrf51822\source\ble\ble_services):            m_service.unread_alert_status.handle_cccd == BLE_ANS_INVALID_HANDLE)
Ble_ans_c.c (nrf51822\source\ble\ble_services):    else if (p_notification->handle == m_service.unread_alert_status.handle_value)
Ble_ans_c.c (nrf51822\source\ble\ble_services):        BLE_UUID_COPY_INST(event.uuid, m_service.unread_alert_status.uuid);
Ble_ans_c.c (nrf51822\source\ble\ble_services): *			when a read response is received.
Ble_ans_c.c (nrf51822\source\ble\ble_services):static void event_read_rsp(ble_ans_c_t * p_ans, const ble_evt_t * p_ble_evt)
Ble_ans_c.c (nrf51822\source\ble\ble_services):    const ble_gattc_evt_read_rsp_t * p_response;
Ble_ans_c.c (nrf51822\source\ble\ble_services):    p_response     = &p_ble_evt->evt.gattc_evt.params.read_rsp;
Ble_ans_c.c (nrf51822\source\ble\ble_services):    event.evt_type = BLE_ANS_C_EVT_READ_RESP;
Ble_ans_c.c (nrf51822\source\ble\ble_services):    if (p_response->len < READ_DATA_LENGTH_MIN)
Ble_ans_c.c (nrf51822\source\ble\ble_services):    else if (p_response->handle == m_service.suported_unread_alert_cat.handle_value)
Ble_ans_c.c (nrf51822\source\ble\ble_services):        BLE_UUID_COPY_INST(event.uuid, m_service.suported_unread_alert_cat.uuid);
Ble_ans_c.c (nrf51822\source\ble\ble_services):        // Bad response, ignore.
Ble_ans_c.c (nrf51822\source\ble\ble_services):    if (p_response->len == READ_DATA_LENGTH_MIN)
Ble_ans_c.c (nrf51822\source\ble\ble_services):    // Only if our previous state was RUNNING, i.e. the client had fully initialized, then the
Ble_ans_c.c (nrf51822\source\ble\ble_services):    uint16_t event = p_ble_evt->header.evt_id;
Ble_ans_c.c (nrf51822\source\ble\ble_services):            else if (event == BLE_GATTC_EVT_READ_RSP)
Ble_ans_c.c (nrf51822\source\ble\ble_services):                event_read_rsp(p_ans, p_ble_evt);
Ble_ans_c.c (nrf51822\source\ble\ble_services):uint32_t ble_ans_c_enable_notif_unread_alert(const ble_ans_c_t * p_ans)
Ble_ans_c.c (nrf51822\source\ble\ble_services):                          m_service.unread_alert_status.handle_cccd,
Ble_ans_c.c (nrf51822\source\ble\ble_services):uint32_t ble_ans_c_disable_notif_unread_alert(const ble_ans_c_t * p_ans)
Ble_ans_c.c (nrf51822\source\ble\ble_services):                          m_service.unread_alert_status.handle_cccd,
Ble_ans_c.c (nrf51822\source\ble\ble_services):uint32_t ble_ans_c_new_alert_read(const ble_ans_c_t * p_ans)
Ble_ans_c.c (nrf51822\source\ble\ble_services):    msg->req.read_handle = m_service.suported_new_alert_cat.handle_value;
Ble_ans_c.c (nrf51822\source\ble\ble_services):    msg->type            = READ_REQ;
Ble_ans_c.c (nrf51822\source\ble\ble_services):uint32_t ble_ans_c_unread_alert_read(const ble_ans_c_t * p_ans)
Ble_ans_c.c (nrf51822\source\ble\ble_services):    msg->req.read_handle = m_service.suported_unread_alert_cat.handle_value;
Ble_ans_c.c (nrf51822\source\ble\ble_services):    msg->type            = READ_REQ;
Ble_ans_c.c (nrf51822\source\ble\ble_services):uint32_t ble_ans_c_unread_alert_notify(const ble_ans_c_t * p_ans, ble_ans_category_id_t category_id)
Ble_ans_c.c (nrf51822\source\ble\ble_services):    control_point.command  = ANS_NOTIFY_UNREAD_CATEGORY_STATUS_IMMEDIATELY;
Ble_ans_c.c (nrf51822\source\ble\ble_services):uint32_t ble_ans_c_service_load(const ble_ans_c_t * p_ans)
Ble_ans_c.c (nrf51822\source\ble\ble_services):    err_code = ble_flash_page_read(m_flash_page_num, m_service_db, &word_count);
Ble_ans_c.c (nrf51822\source\ble\ble_services):        // Problem with loading values from flash, initialize the RAM DB with default.
Ble_ans_c.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_ans_c.h (nrf51822\include\ble\ble_services):    ANS_ENABLE_UNREAD_CATEGORY_STATUS_NOTIFICATION  = 1,                                  /**< Enable Unread Category Status Notification.*/
Ble_ans_c.h (nrf51822\include\ble\ble_services):    ANS_DISABLE_UNREAD_CATEGORY_STATUS_NOTIFICATION = 3,                                  /**< Disable Unread Category Status Notification.*/
Ble_ans_c.h (nrf51822\include\ble\ble_services):    ANS_NOTIFY_UNREAD_CATEGORY_STATUS_IMMEDIATELY   = 5,                                  /**< Notify Unread Category Status immediately.*/
Ble_ans_c.h (nrf51822\include\ble\ble_services):    BLE_ANS_C_EVT_READ_RESP,                                                              /**< A read response has been received from the server.*/
Ble_ans_c.h (nrf51822\include\ble\ble_services): *          additional information.
Ble_ans_c.h (nrf51822\include\ble\ble_services):        ble_ans_alert_settings_t        settings;                                         /**< Setting returned from server on read request. */
Ble_ans_c.h (nrf51822\include\ble\ble_services):        uint32_t                        error_code;                                       /**< Additional status/error code if the event was caused by a stack error or gatt status, e.g. during service discovery. */
Ble_ans_c.h (nrf51822\include\ble\ble_services):    uint32_t                            message_buffer_size;                              /**< Size of message buffer to hold the additional text messages received on notifications. */
Ble_ans_c.h (nrf51822\include\ble\ble_services):    uint8_t *                           p_message_buffer;                                 /**< Pointer to the buffer to be used for additional text message handling. */
Ble_ans_c.h (nrf51822\include\ble\ble_services): *          Notification Control Point for re-send of New Alert and Unread Alert notifications.
Ble_ans_c.h (nrf51822\include\ble\ble_services):/**@brief Function for writing to the CCCD to enable unread alert notifications from the Alert Notification Service.
Ble_ans_c.h (nrf51822\include\ble\ble_services):uint32_t ble_ans_c_enable_notif_unread_alert(const ble_ans_c_t * p_ans);
Ble_ans_c.h (nrf51822\include\ble\ble_services):/**@brief Function for writing to the CCCD to disable unread alert notifications from the Alert Notification Service.
Ble_ans_c.h (nrf51822\include\ble\ble_services):uint32_t ble_ans_c_disable_notif_unread_alert(const ble_ans_c_t * p_ans);
Ble_ans_c.h (nrf51822\include\ble\ble_services):/**@brief Function for reading the Supported New Alert characteristic value of the service.
Ble_ans_c.h (nrf51822\include\ble\ble_services): * @return     NRF_SUCCESS on successful transmission of the read request, otherwise an error code.
Ble_ans_c.h (nrf51822\include\ble\ble_services):uint32_t ble_ans_c_new_alert_read(const ble_ans_c_t * p_ans);
Ble_ans_c.h (nrf51822\include\ble\ble_services):/**@brief Function for reading the Supported Unread Alert characteristic value of the service.
Ble_ans_c.h (nrf51822\include\ble\ble_services): * @return     NRF_SUCCESS on successful transmission of the read request, otherwise an error code.
Ble_ans_c.h (nrf51822\include\ble\ble_services):uint32_t ble_ans_c_unread_alert_read(const ble_ans_c_t * p_ans);
Ble_ans_c.h (nrf51822\include\ble\ble_services): * @return     NRF_SUCCESS on successful transmission of the read request, otherwise an error code.
Ble_ans_c.h (nrf51822\include\ble\ble_services):/**@brief Function for requesting the peer to notify the Unread Alert characteristics immediately.
Ble_ans_c.h (nrf51822\include\ble\ble_services): * @return     NRF_SUCCESS on successful transmission of the read request, otherwise an error code.
Ble_ans_c.h (nrf51822\include\ble\ble_services):uint32_t ble_ans_c_unread_alert_notify(const ble_ans_c_t * p_ans, ble_ans_category_id_t category);
Ble_ans_c.h (nrf51822\include\ble\ble_services):/**@brief  Function for loading previous discovered service and characteristic handles for bonded masters from
Ble_ans_c.h (nrf51822\include\ble\ble_services): * @details Read the database of all discovered service and characteristic handles from flash.
Ble_ans_c.h (nrf51822\include\ble\ble_services):uint32_t ble_ans_c_service_load(const ble_ans_c_t * p_ans);
Ble_ans_c.h (nrf51822\include\ble\ble_services): *          are diferent than the one already stored) and then write into flash. Those
Ble_ans_c.h (nrf51822\include\ble\ble_services): *          operations could prevent the radio to run.
Ble_ans_c.h (nrf51822\include\ble\ble_services): * @note    Do not call this function while in a connection or when advertising. If you do, the
Ble_bas.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_bas.c (nrf51822\source\ble\ble_services):    switch (p_ble_evt->header.evt_id)
Ble_bas.c (nrf51822\source\ble\ble_services):/**@brief Function for adding the Battery Level characteristic.
Ble_bas.c (nrf51822\source\ble\ble_services):static uint32_t battery_level_char_add(ble_bas_t * p_bas, const ble_bas_init_t * p_bas_init)
Ble_bas.c (nrf51822\source\ble\ble_services):    // Add Battery Level characteristic
Ble_bas.c (nrf51822\source\ble\ble_services):        // According to BAS_SPEC_V10, the read operation on cccd should be possible without
Ble_bas.c (nrf51822\source\ble\ble_services):        BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.read_perm);
Ble_bas.c (nrf51822\source\ble\ble_services):    char_md.char_props.read   = 1;
Ble_bas.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_bas_init->battery_level_char_attr_md.read_perm;
Ble_bas.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_characteristic_add(p_bas->service_handle, &char_md,
Ble_bas.c (nrf51822\source\ble\ble_services):        // Add Report Reference descriptor
Ble_bas.c (nrf51822\source\ble\ble_services):        attr_md.read_perm = p_bas_init->battery_level_report_read_perm;
Ble_bas.c (nrf51822\source\ble\ble_services):        err_code = sd_ble_gatts_descriptor_add(p_bas->battery_level_handles.value_handle,
Ble_bas.c (nrf51822\source\ble\ble_services):    // Add service
Ble_bas.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_bas->service_handle);
Ble_bas.c (nrf51822\source\ble\ble_services):    // Add battery level characteristic
Ble_bas.c (nrf51822\source\ble\ble_services):    return battery_level_char_add(p_bas, p_bas_init);
Ble_bas.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_bas.h (nrf51822\include\ble\ble_services): *          During initialization it adds the Battery Service and Battery Level characteristic
Ble_bas.h (nrf51822\include\ble\ble_services): *          to the BLE stack database. Optionally it can also add a Report Reference descriptor
Ble_bas.h (nrf51822\include\ble\ble_services):    ble_srv_report_ref_t *        p_report_ref;                   /**< If not NULL, a Report Reference descriptor with the specified value will be added to the Battery Level characteristic */
Ble_bas.h (nrf51822\include\ble\ble_services):    ble_gap_conn_sec_mode_t       battery_level_report_read_perm; /**< Initial security level for battery report read attribute */
Ble_bondmngr.c (nrf51822\source\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_bondmngr.c (nrf51822\source\ble):    ble_gap_addr_t                 master_addr;                           /**< Master's address. */
Ble_bondmngr.c (nrf51822\source\ble):/**@brief This structure contains the whitelisted addresses.
Ble_bondmngr.c (nrf51822\source\ble):    ble_gap_addr_t * p_addr;                                              /**< Pointer to the master's address if BLE_GAP_ADDR_TYPE_PUBLIC. */
Ble_bondmngr.c (nrf51822\source\ble):} whitelist_addr_t;
Ble_bondmngr.c (nrf51822\source\ble):static whitelist_addr_t    m_whitelist_addr[MAX_NUM_MASTER_WHITE_LIST];   /**< List of master's addresses  for the whitelist. */
Ble_bondmngr.c (nrf51822\source\ble):static uint8_t             m_addr_count;                                  /**< Number of addresses in the whitelist. */
Ble_bondmngr.c (nrf51822\source\ble):static bool                m_bond_loaded;                                 /**< Variable to indicate if the bonding information of the currently connected master is available in the RAM.*/
Ble_bondmngr.c (nrf51822\source\ble):static bool                m_sys_attr_loaded;                             /**< Variable to indicate if the system attribute information of the currently connected master is loaded from the database and set in the S110 SoftDevice.*/
Ble_bondmngr.c (nrf51822\source\ble): * @param[in]  header   Header containing CRC and magic number.
Ble_bondmngr.c (nrf51822\source\ble): * @retval      NRF_ERROR_INVALID_DATA   Header does not contain the magic number.
Ble_bondmngr.c (nrf51822\source\ble):static uint32_t crc_extract(uint32_t header, uint16_t * p_crc)
Ble_bondmngr.c (nrf51822\source\ble):    if ((header & 0xFFFF0000U) == BLE_FLASH_MAGIC_NUMBER)
Ble_bondmngr.c (nrf51822\source\ble):        *p_crc = (uint16_t)(header & 0x0000FFFFU);
Ble_bondmngr.c (nrf51822\source\ble):    else if (header == 0xFFFFFFFFU)
Ble_bondmngr.c (nrf51822\source\ble):        err_code = ble_flash_page_addr(m_bondmngr_config.flash_page_num_bond, &mp_flash_bond_info);
Ble_bondmngr.c (nrf51822\source\ble):    // Write header
Ble_bondmngr.c (nrf51822\source\ble):        err_code = ble_flash_page_addr(m_bondmngr_config.flash_page_num_sys_attr,
Ble_bondmngr.c (nrf51822\source\ble):    // Write header.
Ble_bondmngr.c (nrf51822\source\ble):/**@brief      Function for loading the Bonding Information of one master from flash.
Ble_bondmngr.c (nrf51822\source\ble): * @param[out] p_bond   Loaded Bonding Information.
Ble_bondmngr.c (nrf51822\source\ble):static uint32_t bonding_info_load_from_flash(master_bond_t * p_bond)
Ble_bondmngr.c (nrf51822\source\ble):    uint16_t crc_header;
Ble_bondmngr.c (nrf51822\source\ble):    // Check if this is the first bond to be loaded, in which case the
Ble_bondmngr.c (nrf51822\source\ble):        err_code = ble_flash_page_addr(m_bondmngr_config.flash_page_num_bond, &mp_flash_bond_info);
Ble_bondmngr.c (nrf51822\source\ble):    // Extract CRC from header.
Ble_bondmngr.c (nrf51822\source\ble):    err_code = crc_extract(*mp_flash_bond_info, &crc_header);
Ble_bondmngr.c (nrf51822\source\ble):    // Load master.
Ble_bondmngr.c (nrf51822\source\ble):    if (m_crc_bond_info == crc_header)
Ble_bondmngr.c (nrf51822\source\ble):/**@brief      Function for loading the System Attributes related to one master from flash.
Ble_bondmngr.c (nrf51822\source\ble): * @param[out] p_sys_attr   Loaded System Attributes.
Ble_bondmngr.c (nrf51822\source\ble):static uint32_t sys_attr_load_from_flash(master_sys_attr_t * p_sys_attr)
Ble_bondmngr.c (nrf51822\source\ble):    uint16_t crc_header;
Ble_bondmngr.c (nrf51822\source\ble):    // Check if this is the first time System Attributes is loaded from flash, in which case the
Ble_bondmngr.c (nrf51822\source\ble):        err_code = ble_flash_page_addr(m_bondmngr_config.flash_page_num_sys_attr,
Ble_bondmngr.c (nrf51822\source\ble):    // Extract CRC from header.
Ble_bondmngr.c (nrf51822\source\ble):    err_code = crc_extract(*mp_flash_sys_attr, &crc_header);
Ble_bondmngr.c (nrf51822\source\ble):    // Read System Attributes from flash.
Ble_bondmngr.c (nrf51822\source\ble):    if (m_crc_sys_attr == crc_header)
Ble_bondmngr.c (nrf51822\source\ble):    for (i = 0, m_addr_count = 0, m_irk_count = 0; i < m_masters_in_db_count; i++)
Ble_bondmngr.c (nrf51822\source\ble):        if (BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE != p_bond->master_addr.addr_type)
Ble_bondmngr.c (nrf51822\source\ble):            m_whitelist_addr[m_addr_count].master_handle = p_bond->master_handle;
Ble_bondmngr.c (nrf51822\source\ble):            m_whitelist_addr[m_addr_count].p_addr        = &(p_bond->master_addr);
Ble_bondmngr.c (nrf51822\source\ble):            m_addr_count++;
Ble_bondmngr.c (nrf51822\source\ble): * @details    This function adds the new master to the database and stores the master's Bonding
Ble_bondmngr.c (nrf51822\source\ble):    // Add new master to database.
Ble_bondmngr.c (nrf51822\source\ble):    m_bond_loaded = true;
Ble_bondmngr.c (nrf51822\source\ble):        // been loaded or not to avoid overwriting information that was not used in the
Ble_bondmngr.c (nrf51822\source\ble):        if (m_bond_loaded)
Ble_bondmngr.c (nrf51822\source\ble):        if (m_sys_attr_loaded)
Ble_bondmngr.c (nrf51822\source\ble):/**@brief      Function for loading all Bonding Information and System Attributes from flash.
Ble_bondmngr.c (nrf51822\source\ble):static uint32_t load_all_from_flash(void)
Ble_bondmngr.c (nrf51822\source\ble):        // Load Bonding Information.
Ble_bondmngr.c (nrf51822\source\ble):        err_code = bonding_info_load_from_flash(&master_bond_info);
Ble_bondmngr.c (nrf51822\source\ble):            // Add/update Bonding Information in master array.
Ble_bondmngr.c (nrf51822\source\ble):    // Load System Attributes for all previously known masters.
Ble_bondmngr.c (nrf51822\source\ble):        // Load System Attributes.
Ble_bondmngr.c (nrf51822\source\ble):        err_code = sys_attr_load_from_flash(&master_sys_attr);
Ble_bondmngr.c (nrf51822\source\ble):            // Add/update Bonding Information in master array.
Ble_bondmngr.c (nrf51822\source\ble):    m_master.bond.master_addr       = p_ble_evt->evt.gap_evt.params.connected.peer_addr;
Ble_bondmngr.c (nrf51822\source\ble):        for (i = 0; i < m_addr_count; i++)
Ble_bondmngr.c (nrf51822\source\ble):            ble_gap_addr_t * p_cur_addr = m_whitelist_addr[i].p_addr;
Ble_bondmngr.c (nrf51822\source\ble):            if (memcmp(p_cur_addr->addr, m_master.bond.master_addr.addr, BLE_GAP_ADDR_LEN) == 0)
Ble_bondmngr.c (nrf51822\source\ble):                m_master = m_masters_db[m_whitelist_addr[i].master_handle];
Ble_bondmngr.c (nrf51822\source\ble):        // Reset bond and system attributes loaded variables.
Ble_bondmngr.c (nrf51822\source\ble):        m_bond_loaded     = false;
Ble_bondmngr.c (nrf51822\source\ble):        m_sys_attr_loaded = false;
Ble_bondmngr.c (nrf51822\source\ble):            // Set System Attributes loaded status variable.
Ble_bondmngr.c (nrf51822\source\ble):            m_sys_attr_loaded = true;
Ble_bondmngr.c (nrf51822\source\ble): *             SoftDevice, related to an already bonded master.
Ble_bondmngr.c (nrf51822\source\ble):            // Add the new device to data base
Ble_bondmngr.c (nrf51822\source\ble):        m_bond_loaded = true;
Ble_bondmngr.c (nrf51822\source\ble):        // Receiving a auth status again when already in have existing information!
Ble_bondmngr.c (nrf51822\source\ble):        // Bond information has been found and loaded for security procedures. Reflect this in the
Ble_bondmngr.c (nrf51822\source\ble):        m_bond_loaded = true;
Ble_bondmngr.c (nrf51822\source\ble):            m_sys_attr_loaded = true;
Ble_bondmngr.c (nrf51822\source\ble):    switch (p_ble_evt->header.evt_id)
Ble_bondmngr.c (nrf51822\source\ble):        //       Disconnected handler of the application before advertising is restarted (to make
Ble_bondmngr.c (nrf51822\source\ble):        //       sure the flash blocks are cleared while the radio is inactive).
Ble_bondmngr.c (nrf51822\source\ble):    m_bond_loaded                   = false;
Ble_bondmngr.c (nrf51822\source\ble):    m_sys_attr_loaded               = false;
Ble_bondmngr.c (nrf51822\source\ble):        // Will not write to flash because System Attributes of an old master would already be
Ble_bondmngr.c (nrf51822\source\ble):uint32_t ble_bondmngr_master_addr_get(int8_t master_handle, ble_gap_addr_t * p_master_addr)
Ble_bondmngr.c (nrf51822\source\ble):        (p_master_addr == NULL)                  ||
Ble_bondmngr.c (nrf51822\source\ble):         m_masters_db[master_handle].bond.master_addr.addr_type
Ble_bondmngr.c (nrf51822\source\ble):         BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE
Ble_bondmngr.c (nrf51822\source\ble):    *p_master_addr = m_masters_db[master_handle].bond.master_addr;
Ble_bondmngr.c (nrf51822\source\ble):    static ble_gap_addr_t * s_addr[MAX_NUM_MASTER_WHITE_LIST];
Ble_bondmngr.c (nrf51822\source\ble):    for (i = 0; i < m_addr_count; i++)
Ble_bondmngr.c (nrf51822\source\ble):        s_addr[i] = m_whitelist_addr[i].p_addr;
Ble_bondmngr.c (nrf51822\source\ble):    p_whitelist->addr_count = m_addr_count;
Ble_bondmngr.c (nrf51822\source\ble):    p_whitelist->pp_addrs   = (m_addr_count != 0) ? s_addr : NULL;
Ble_bondmngr.c (nrf51822\source\ble):    // Load bond manager data from flash.
Ble_bondmngr.c (nrf51822\source\ble):    err_code = load_all_from_flash();
Ble_bondmngr.c (nrf51822\source\ble):    err_code = ble_flash_page_addr(m_bondmngr_config.flash_page_num_bond, &mp_flash_bond_info);
Ble_bondmngr.c (nrf51822\source\ble):    err_code = ble_flash_page_addr(m_bondmngr_config.flash_page_num_sys_attr, &mp_flash_sys_attr);
Ble_bondmngr.h (nrf51822\include\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_bondmngr.h (nrf51822\include\ble): *          The application can use the Bond Manager API to store or load (or restore) the
Ble_bondmngr.h (nrf51822\include\ble): *          In addition, you can use the bond manager to set up your application to advertise:
Ble_bondmngr.h (nrf51822\include\ble): *          - To a given bonded master using directed advertisement.
Ble_bondmngr.h (nrf51822\include\ble): *          data for the current connected master is already present in the flash. The API does so
Ble_bondmngr.h (nrf51822\include\ble): *          long time (21 milliseconds) to complete. This may disrupt the radio.
Ble_bondmngr.h (nrf51822\include\ble):/** @addtogroup DATA_STRUCTURES
Ble_bondmngr.h (nrf51822\include\ble): * @warning This function could prevent the radio from running. Therefore it MUST be called ONLY
Ble_bondmngr.h (nrf51822\include\ble): *          when the application knows that the <i>Bluetooth</i> radio is not active. An example of
Ble_bondmngr.h (nrf51822\include\ble): *          started advertising. <b>If it is called in any other state, or if it is not called at
Ble_bondmngr.h (nrf51822\include\ble): * @details     This function populates the whitelist with either the IRKs or the public adresses
Ble_bondmngr.h (nrf51822\include\ble):/**@brief Function for getting the master's address corresponding to a given master_handle.
Ble_bondmngr.h (nrf51822\include\ble): *              address.
Ble_bondmngr.h (nrf51822\include\ble): * @param[out]  p_master_addr  Pointer to the master's address which can be used for
Ble_bondmngr.h (nrf51822\include\ble): *                             directed advertising.
Ble_bondmngr.h (nrf51822\include\ble):uint32_t ble_bondmngr_master_addr_get(int8_t master_handle, ble_gap_addr_t * p_master_addr);
Ble_bondmngr.h (nrf51822\include\ble): * @details This function fetches the System Attributes of the current master from the stack, adds
Ble_bondmngr.h (nrf51822\include\ble): *          state without affecting radio link. This function can, for example, be called after the
Ble_bondmngr.h (nrf51822\include\ble): *          already present in the flash because it is a previously known master.
Ble_bondmngr.h (nrf51822\include\ble): * @warning     This function could prevent the radio from running. Therefore it MUST be called ONLY
Ble_bondmngr.h (nrf51822\include\ble): *              when the application knows that the <i>Bluetooth</i> radio is not active. An example
Ble_bondmngr.h (nrf51822\include\ble): *              also not advertising. <b>If it is called in any other state, the behavior is
Ble_bondmngr.h (nrf51822\include\ble): * @warning     Currently the master id paramater is unused and is added only for future extension.
Ble_bondmngr_cfg.h (source\inc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_bps.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_bps.c (nrf51822\source\ble\ble_services):    switch (p_ble_evt->header.evt_id)
Ble_bps.c (nrf51822\source\ble\ble_services):/**@brief Function for adding Blood Pressure Measurement characteristics.
Ble_bps.c (nrf51822\source\ble\ble_services):static uint32_t bps_measurement_char_add(ble_bps_t * p_bps, const ble_bps_init_t * p_bps_init)
Ble_bps.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.read_perm);
Ble_bps.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_bps_init->bps_meas_attr_md.read_perm;
Ble_bps.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_bps->service_handle,
Ble_bps.c (nrf51822\source\ble\ble_services):/**@brief Function for adding Blood Pressure Feature characteristics.
Ble_bps.c (nrf51822\source\ble\ble_services):static uint32_t bps_feature_char_add(ble_bps_t * p_bps, const ble_bps_init_t * p_bps_init)
Ble_bps.c (nrf51822\source\ble\ble_services):    char_md.char_props.read  = 1;
Ble_bps.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_bps_init->bps_feature_attr_md.read_perm;
Ble_bps.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_bps->service_handle,
Ble_bps.c (nrf51822\source\ble\ble_services):    // Add service
Ble_bps.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_bps->service_handle);
Ble_bps.c (nrf51822\source\ble\ble_services):    // Add measurement characteristic
Ble_bps.c (nrf51822\source\ble\ble_services):    err_code = bps_measurement_char_add(p_bps, p_bps_init);
Ble_bps.c (nrf51822\source\ble\ble_services):    // Add feature characteristic
Ble_bps.c (nrf51822\source\ble\ble_services):    err_code = bps_feature_char_add(p_bps, p_bps_init);
Ble_bps.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_conn_params.c (nrf51822\source\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_conn_params.c (nrf51822\source\ble):#include "ble_radio_notification.h"
Ble_conn_params.c (nrf51822\source\ble):    switch (p_ble_evt->header.evt_id)
Ble_conn_params.h (nrf51822\include\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_cscs.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_cscs.c (nrf51822\source\ble\ble_services):#define OPCODE_LENGTH  1                                                    /**< Length of opcode inside Cycling Speed and Cadence Measurement packet. */
Ble_cscs.c (nrf51822\source\ble\ble_services):#define HANDLE_LENGTH  2                                                    /**< Length of handle inside Cycling Speed and Cadence Measurement packet. */
Ble_cscs.c (nrf51822\source\ble\ble_services):#define MAX_CSCM_LEN   (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH)  /**< Maximum size of a transmitted Cycling Speed and Cadence Measurement. */
Ble_cscs.c (nrf51822\source\ble\ble_services):// Cycling Speed and Cadence Measurement flag bits
Ble_cscs.c (nrf51822\source\ble\ble_services): * @param[in]   p_cscs      Cycling Speed and Cadence Service structure.
Ble_cscs.c (nrf51822\source\ble\ble_services): * @param[in]   p_cscs      Cycling Speed and Cadence Service structure.
Ble_cscs.c (nrf51822\source\ble\ble_services): * @param[in]   p_cscs        Cycling Speed and Cadence Service structure.
Ble_cscs.c (nrf51822\source\ble\ble_services): * @param[in]   p_cscs      Cycling Speed and Cadence Service structure.
Ble_cscs.c (nrf51822\source\ble\ble_services):    switch (p_ble_evt->header.evt_id)
Ble_cscs.c (nrf51822\source\ble\ble_services): * @param[in]   p_cscs              Cycling Speed and Cadence Service structure.
Ble_cscs.c (nrf51822\source\ble\ble_services):/**@brief Function for adding CSC Measurement characteristics.
Ble_cscs.c (nrf51822\source\ble\ble_services): * @param[in]   p_cscs        Cycling Speed and Cadence Service structure.
Ble_cscs.c (nrf51822\source\ble\ble_services):static uint32_t csc_measurement_char_add(ble_cscs_t * p_cscs, const ble_cscs_init_t * p_cscs_init)
Ble_cscs.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.read_perm);
Ble_cscs.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&attr_md.read_perm );
Ble_cscs.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_cscs->service_handle,
Ble_cscs.c (nrf51822\source\ble\ble_services):/**@brief Function for adding CSC Feature characteristics.
Ble_cscs.c (nrf51822\source\ble\ble_services): * @param[in]   p_cscs        Cycling Speed and Cadence Service structure.
Ble_cscs.c (nrf51822\source\ble\ble_services):static uint32_t csc_feature_char_add(ble_cscs_t * p_cscs, const ble_cscs_init_t * p_cscs_init)
Ble_cscs.c (nrf51822\source\ble\ble_services):    char_md.char_props.read  = 1;
Ble_cscs.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_cscs_init->csc_feature_attr_md.read_perm;
Ble_cscs.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_cscs->service_handle,
Ble_cscs.c (nrf51822\source\ble\ble_services):/**@brief Function for adding CSC Sensor Location characteristic.
Ble_cscs.c (nrf51822\source\ble\ble_services): * @param[in]   p_cscs        Cycling Speed and Cadence Service structure.
Ble_cscs.c (nrf51822\source\ble\ble_services):static uint32_t csc_sensor_loc_char_add(ble_cscs_t * p_cscs, const ble_cscs_init_t * p_cscs_init)
Ble_cscs.c (nrf51822\source\ble\ble_services):    char_md.char_props.read  = 1;
Ble_cscs.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_cscs_init->csc_sensor_loc_attr_md.read_perm;
Ble_cscs.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_cscs->service_handle,
Ble_cscs.c (nrf51822\source\ble\ble_services):    // Add service
Ble_cscs.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_CYCLING_SPEED_AND_CADENCE);
Ble_cscs.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY,
Ble_cscs.c (nrf51822\source\ble\ble_services):    // Add cycling speed and cadence measurement characteristic
Ble_cscs.c (nrf51822\source\ble\ble_services):    err_code = csc_measurement_char_add(p_cscs, p_cscs_init);
Ble_cscs.c (nrf51822\source\ble\ble_services):    // Add cycling speed and cadence feature characteristic
Ble_cscs.c (nrf51822\source\ble\ble_services):    err_code = csc_feature_char_add(p_cscs, p_cscs_init);
Ble_cscs.c (nrf51822\source\ble\ble_services):    // Add Sensor Location characteristic (optional)
Ble_cscs.c (nrf51822\source\ble\ble_services):        err_code = csc_sensor_loc_char_add(p_cscs, p_cscs_init);
Ble_cscs.c (nrf51822\source\ble\ble_services):    //Add speed and cadence control point characteristic
Ble_cscs.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_cscs.h (nrf51822\include\ble\ble_services): * @defgroup ble_sdk_srv_csc Cycling Speed and Cadence Service
Ble_cscs.h (nrf51822\include\ble\ble_services): * @brief Cycling Speed and Cadence Service module.
Ble_cscs.h (nrf51822\include\ble\ble_services): * @details This module implements the Cycling Speed and Cadence Service. If enabled, notification
Ble_cscs.h (nrf51822\include\ble\ble_services): *          of the Cycling Speead and Candence Measurement is performed when the application
Ble_cscs.h (nrf51822\include\ble\ble_services): *          Speed and Cadence Control Point (@ref ble_sdk_srv_sc_ctrlpt) by setting the @ref BLE_SRV_SC_CTRLPT_CUM_VAL_OP_SUPPORTED
Ble_cscs.h (nrf51822\include\ble\ble_services): *       Cycling Speead and Candence Service module by calling ble_cscs_on_ble_evt() from the 
Ble_cscs.h (nrf51822\include\ble\ble_services):/** @defgroup BLE_CSCS_FEATURES Cycling Speed and Cadence Service feature bits
Ble_cscs.h (nrf51822\include\ble\ble_services):/**@brief Cycling Speed and Cadence Service event type. */
Ble_cscs.h (nrf51822\include\ble\ble_services):    BLE_CSCS_EVT_NOTIFICATION_ENABLED,                                  /**< Cycling Speed and Cadence value notification enabled event. */
Ble_cscs.h (nrf51822\include\ble\ble_services):    BLE_CSCS_EVT_NOTIFICATION_DISABLED                                  /**< Cycling Speed and Cadence value notification disabled event. */
Ble_cscs.h (nrf51822\include\ble\ble_services):/**@brief Cycling Speed and Cadence Service event. */
Ble_cscs.h (nrf51822\include\ble\ble_services):/**@brief Cycling Speed and Cadence Service event handler type. */
Ble_cscs.h (nrf51822\include\ble\ble_services):/**@brief Cycling Speed and Cadence Service init structure. This contains all options and data
Ble_cscs.h (nrf51822\include\ble\ble_services):    ble_cscs_evt_handler_t       evt_handler;                           /**< Event handler to be called for handling events in the Cycling Speed and Cadence Service. */
Ble_cscs.h (nrf51822\include\ble\ble_services):    ble_srv_cccd_security_mode_t csc_meas_attr_md;                      /**< Initial security level for cycling speed and cadence measurement attribute */
Ble_cscs.h (nrf51822\include\ble\ble_services):    ble_srv_cccd_security_mode_t csc_ctrlpt_attr_md;                    /**< Initial security level for cycling speed and cadence control point attribute */
Ble_cscs.h (nrf51822\include\ble\ble_services):    ble_sensor_location_t        *sensor_location;                      /**< Initial Sensor Location, if NULL, sensor_location characteristic is not added*/
Ble_cscs.h (nrf51822\include\ble\ble_services):/**@brief Cycling Speed and Cadence Service structure. This contains various status information for
Ble_cscs.h (nrf51822\include\ble\ble_services):    ble_cscs_evt_handler_t       evt_handler;                           /**< Event handler to be called for handling events in the Cycling Speed and Cadence Service. */
Ble_cscs.h (nrf51822\include\ble\ble_services):    uint16_t                     service_handle;                        /**< Handle of Cycling Speed and Cadence Service (as provided by the BLE stack). */
Ble_cscs.h (nrf51822\include\ble\ble_services):    ble_gatts_char_handles_t     meas_handles;                          /**< Handles related to the Cycling Speed and Cadence Measurement characteristic. */
Ble_cscs.h (nrf51822\include\ble\ble_services):    ble_gatts_char_handles_t     feature_handles;                       /**< Handles related to the Cycling Speed and Cadence feature characteristic. */
Ble_cscs.h (nrf51822\include\ble\ble_services):    ble_gatts_char_handles_t     sensor_loc_handles;                    /**< Handles related to the Cycling Speed and Cadence Sensor Location characteristic. */
Ble_cscs.h (nrf51822\include\ble\ble_services):    ble_sc_ctrlpt_t              ctrl_pt;                               /**< data for speed and cadence control point */
Ble_cscs.h (nrf51822\include\ble\ble_services):/**@brief Cycling Speed and Cadence Service measurement structure. This contains a Cycling Speed and
Ble_cscs.h (nrf51822\include\ble\ble_services): *        Cadence Service measurement. */
Ble_cscs.h (nrf51822\include\ble\ble_services):/**@brief Function for initializing the Cycling Speed and Cadence Service.
Ble_cscs.h (nrf51822\include\ble\ble_services): * @param[out]  p_cscs      Cycling Speed and Cadence Service structure. This structure will have to
Ble_cscs.h (nrf51822\include\ble\ble_services): * @details Handles all events from the BLE stack of interest to the Cycling Speed and Cadence
Ble_cscs.h (nrf51822\include\ble\ble_services): * @param[in]   p_cscs     Cycling Speed and Cadence Service structure.
Ble_cscs.h (nrf51822\include\ble\ble_services):/**@brief Function for sending cycling speed and cadence measurement if notification has been enabled.
Ble_cscs.h (nrf51822\include\ble\ble_services): * @details The application calls this function after having performed a Cycling Speed and Cadence
Ble_cscs.h (nrf51822\include\ble\ble_services): * @param[in]   p_cscs         Cycling Speed and Cadence Service structure.
Ble_cscs.h (nrf51822\include\ble\ble_services): * @param[in]   p_measurement  Pointer to new cycling speed and cadence measurement.
Ble_date_time.h (nrf51822\include\ble):* WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_debug_assert_handler.c (nrf51822\source\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_debug_assert_handler.c (nrf51822\source\ble):extern SportsHead_t mSportHead;
Ble_debug_assert_handler.c (nrf51822\source\ble):extern SleepHead_t  mSleepHead;
Ble_debug_assert_handler.c (nrf51822\source\ble):extern SleepHead_t *manual_sleep_events_head;
Ble_debug_assert_handler.c (nrf51822\source\ble):    uint32_t * address =0;
Ble_debug_assert_handler.c (nrf51822\source\ble):    ble_flash_page_addr(FLASH_PAGE_STORE_TIME,&address);
Ble_debug_assert_handler.c (nrf51822\source\ble):    if(!address) { //Not use assert :)
Ble_debug_assert_handler.c (nrf51822\source\ble):    for(i = 0 ; i<length ; ++i,address++) {
Ble_debug_assert_handler.c (nrf51822\source\ble):        if(*address == 0xFFFFFFFF) {//flash init value
Ble_debug_assert_handler.c (nrf51822\source\ble):        //Note: this operation should not occure because the page was erased in the read operation
Ble_debug_assert_handler.c (nrf51822\source\ble):        ble_flash_page_addr(FLASH_PAGE_STORE_TIME,&address);
Ble_debug_assert_handler.c (nrf51822\source\ble):        if(!address) {
Ble_debug_assert_handler.c (nrf51822\source\ble):    ble_flash_word_write(address,time.data);
Ble_debug_assert_handler.c (nrf51822\source\ble):    uint32_t * address;
Ble_debug_assert_handler.c (nrf51822\source\ble):    ble_flash_page_addr(FLASH_PAGE_STORE_TIME,&address);
Ble_debug_assert_handler.c (nrf51822\source\ble):        if(*address != 0xFFFFFFFF) {
Ble_debug_assert_handler.c (nrf51822\source\ble):            address++;
Ble_debug_assert_handler.c (nrf51822\source\ble):    address--;
Ble_debug_assert_handler.c (nrf51822\source\ble):    time.data = * address;
Ble_debug_assert_handler.c (nrf51822\source\ble):    uint32_t info_to_restore[WORD_NUM_TO_BACK_UP + FLASH_PAGE_HEADER_LEN];
Ble_debug_assert_handler.c (nrf51822\source\ble):    uint32_t *  address = 0;
Ble_debug_assert_handler.c (nrf51822\source\ble):    uint16_t    crc_header;
Ble_debug_assert_handler.c (nrf51822\source\ble):    uint32_t    header;
Ble_debug_assert_handler.c (nrf51822\source\ble):    uint8_t  *  end_addr;
Ble_debug_assert_handler.c (nrf51822\source\ble):    ble_flash_page_addr(FLASH_PAGE_STORE_TIME,&address);
Ble_debug_assert_handler.c (nrf51822\source\ble):    if(address) {
Ble_debug_assert_handler.c (nrf51822\source\ble):        memcpy((char *)info_to_restore,(char *)address,((WORD_NUM_TO_BACK_UP + FLASH_PAGE_HEADER_LEN) * sizeof(uint32_t)));
Ble_debug_assert_handler.c (nrf51822\source\ble):        header = info_to_restore[0];
Ble_debug_assert_handler.c (nrf51822\source\ble):        if((header & 0xFFFF0000U) == BLE_FLASH_MAGIC_NUMBER) {
Ble_debug_assert_handler.c (nrf51822\source\ble):            crc_header = (uint16_t) (header & 0x0000FFFFU);
Ble_debug_assert_handler.c (nrf51822\source\ble):            cal_crc = ble_flash_crc16_compute((uint8_t *) (info_to_restore + FLASH_PAGE_HEADER_LEN), (word_count * sizeof(uint32_t)), NULL);
Ble_debug_assert_handler.c (nrf51822\source\ble):            if(cal_crc == crc_header) {
Ble_debug_assert_handler.c (nrf51822\source\ble):                current_pos = (uint8_t *)(info_to_restore + FLASH_PAGE_HEADER_LEN);
Ble_debug_assert_handler.c (nrf51822\source\ble):                end_addr    = (uint8_t *)(info_to_restore + FLASH_PAGE_HEADER_LEN + word_count);
Ble_debug_assert_handler.c (nrf51822\source\ble):                check_and_restore(&data,current_pos,sizeof(data),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):                check_and_restore(&data,current_pos,sizeof(data),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):                check_and_restore(&data,current_pos,sizeof(data),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):                //restore mSportHead to Ram
Ble_debug_assert_handler.c (nrf51822\source\ble):                check_and_restore(&mSportHead,current_pos, sizeof(SportsHead_t),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):                //restore mSportHead to Ram
Ble_debug_assert_handler.c (nrf51822\source\ble):                check_and_restore(&mSportsData,current_pos,sizeof(mSportsData),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):                //restore mSleepHead to Ram
Ble_debug_assert_handler.c (nrf51822\source\ble):                check_and_restore(&mSleepHead, current_pos, sizeof(SleepHead_t),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):                check_and_restore(&mSleepData.data,current_pos,sizeof(mSleepData.data),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):                check_and_restore(&curr_sleep_status,current_pos,sizeof(uint32_t),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):                check_and_restore(&g_saved_SportsData,current_pos,sizeof(g_saved_SportsData),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):                check_and_restore(&g_saved_SleepData,current_pos,sizeof(g_saved_SleepData),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):                for(int ii = 0; ii < word_count+FLASH_PAGE_HEADER_LEN; ii ++)
Ble_debug_assert_handler.c (nrf51822\source\ble):        for(i = 0 ; i< (WORD_NUM_TO_BACK_UP + FLASH_PAGE_HEADER_LEN); ++i) {
Ble_debug_assert_handler.c (nrf51822\source\ble):            if(*(address + i) != 0xFFFFFFFF) {
Ble_debug_assert_handler.c (nrf51822\source\ble):        if(i <  (WORD_NUM_TO_BACK_UP + FLASH_PAGE_HEADER_LEN)) {
Ble_debug_assert_handler.c (nrf51822\source\ble):    memset(&mSportHead, 0, sizeof(SportsHead_t));
Ble_debug_assert_handler.c (nrf51822\source\ble):    memset(&mSleepHead, 0, sizeof(SleepHead_t));
Ble_debug_assert_handler.c (nrf51822\source\ble):    return NRF_ERROR_INVALID_ADDR;
Ble_debug_assert_handler.c (nrf51822\source\ble):    uint32_t info_to_backup[WORD_NUM_TO_BACK_UP + FLASH_PAGE_HEADER_LEN];
Ble_debug_assert_handler.c (nrf51822\source\ble):    uint32_t flash_header;
Ble_debug_assert_handler.c (nrf51822\source\ble):    uint32_t * address =0;
Ble_debug_assert_handler.c (nrf51822\source\ble):    uint8_t  * current_pos = (uint8_t *)(info_to_backup + FLASH_PAGE_HEADER_LEN); 
Ble_debug_assert_handler.c (nrf51822\source\ble):    uint8_t  * end_addr = (uint8_t *)(info_to_backup + FLASH_PAGE_HEADER_LEN + WORD_NUM_TO_BACK_UP);
Ble_debug_assert_handler.c (nrf51822\source\ble):    ble_flash_page_addr(FLASH_PAGE_STORE_TIME,&address);
Ble_debug_assert_handler.c (nrf51822\source\ble):    if(!address) { //Not use assert :)
Ble_debug_assert_handler.c (nrf51822\source\ble):    for(; i < WORD_NUM_TO_BACK_UP + FLASH_PAGE_HEADER_LEN ; ++i) {// 2 words for flash header : crc + word_count
Ble_debug_assert_handler.c (nrf51822\source\ble):        if(*(address + i) != 0xFFFFFFFF) {
Ble_debug_assert_handler.c (nrf51822\source\ble):        //FIXME: here should stop radio, and erase the page syncronize
Ble_debug_assert_handler.c (nrf51822\source\ble):    check_and_backup(current_pos,&counter,sizeof(UTCTime),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):    check_and_backup(current_pos,&data,sizeof(uint32_t),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):    check_and_backup(current_pos,&data,sizeof(uint32_t),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):    //store mSportHead to flash
Ble_debug_assert_handler.c (nrf51822\source\ble):    check_and_backup(current_pos,&mSportHead,sizeof(SportsHead_t),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):    //store mSportHead to flash
Ble_debug_assert_handler.c (nrf51822\source\ble):    check_and_backup(current_pos,&mSportsData,sizeof(mSportsData),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):    //store mSleepHead to flash
Ble_debug_assert_handler.c (nrf51822\source\ble):    check_and_backup(current_pos,&mSleepHead, sizeof(SleepHead_t),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):    check_and_backup(current_pos,&mSleepData.data,sizeof(mSleepData.data),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):    check_and_backup(current_pos,&curr_sleep_status, sizeof(uint32_t),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):    check_and_backup(current_pos,&g_saved_SportsData,sizeof(g_saved_SportsData),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):    check_and_backup(current_pos,&g_saved_SleepData,sizeof(g_saved_SleepData),end_addr);
Ble_debug_assert_handler.c (nrf51822\source\ble):    uint32_t word_count = ((current_pos - (uint8_t *)(info_to_backup + FLASH_PAGE_HEADER_LEN)) - 1) / sizeof(uint32_t) + 1; // align to 4
Ble_debug_assert_handler.c (nrf51822\source\ble):    flash_crc = ble_flash_crc16_compute((uint8_t *)(info_to_backup + FLASH_PAGE_HEADER_LEN), (word_count * sizeof(uint32_t)) , NULL);
Ble_debug_assert_handler.c (nrf51822\source\ble):    flash_header = BLE_FLASH_MAGIC_NUMBER | (uint32_t)flash_crc;
Ble_debug_assert_handler.c (nrf51822\source\ble):    info_to_backup[0] = flash_header;
Ble_debug_assert_handler.c (nrf51822\source\ble):    for (i = 0 ; i < word_count + FLASH_PAGE_HEADER_LEN; i++) { 
Ble_debug_assert_handler.c (nrf51822\source\ble):        ble_flash_word_write(address + i, info_to_backup[i]);
Ble_debug_assert_handler.c (nrf51822\source\ble):uint32_t check_is_flash_erased(uint32_t * address ,uint16_t wordCount);
Ble_debug_assert_handler.c (nrf51822\source\ble):    //disable radio
Ble_debug_assert_handler.c (nrf51822\source\ble):    radio_disable();
Ble_debug_assert_handler.c (nrf51822\source\ble):    // In addition, the Cortex-M0 stack memory will also be written to the flash.
Ble_debug_assert_handler.c (nrf51822\source\ble):    uint32_t * log_page_address;
Ble_debug_assert_handler.c (nrf51822\source\ble):    ble_flash_page_addr(FLASH_PAGE_ERROR_LOG,&log_page_address);
Ble_debug_assert_handler.c (nrf51822\source\ble):    //write if the page has already been erased
Ble_debug_assert_handler.c (nrf51822\source\ble):    if(check_is_flash_erased(log_page_address,log_word_count) == NRF_SUCCESS ) {
Ble_debug_assert_handler.h (nrf51822\include\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_dfu.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_dfu.c (nrf51822\source\ble\ble_services):/**@brief       Function for adding DFU Packet characteristic to the BLE Stack.
Ble_dfu.c (nrf51822\source\ble\ble_services):static uint32_t dfu_pkt_char_add(ble_dfu_t * const p_dfu)
Ble_dfu.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&attr_md.read_perm);
Ble_dfu.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_dfu->service_handle,
Ble_dfu.c (nrf51822\source\ble\ble_services):/**@brief       Function for adding DFU Control Point characteristic to the BLE Stack.
Ble_dfu.c (nrf51822\source\ble\ble_services):static uint32_t dfu_ctrl_pt_add(ble_dfu_t * const p_dfu)
Ble_dfu.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&attr_md.read_perm);
Ble_dfu.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_dfu->service_handle,
Ble_dfu.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_uuid_vs_add(&base_uuid128, &(service_uuid.type));
Ble_dfu.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY,
Ble_dfu.c (nrf51822\source\ble\ble_services):    err_code = dfu_pkt_char_add(p_dfu);
Ble_dfu.c (nrf51822\source\ble\ble_services):    err_code = dfu_ctrl_pt_add(p_dfu);
Ble_dfu.c (nrf51822\source\ble\ble_services):        switch (p_ble_evt->header.evt_id)
Ble_dfu.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_dfu.h (nrf51822\include\ble\ble_services): * @return     NRF_SUCCESS if the DFU service and its characteristics were successfully added to the
Ble_dis.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_dis.c (nrf51822\source\ble\ble_services):/**@brief Function for adding the Characteristic.
Ble_dis.c (nrf51822\source\ble\ble_services): * @param[in]   uuid           UUID of characteristic to be added.
Ble_dis.c (nrf51822\source\ble\ble_services): * @param[in]   p_char_value   Initial value of characteristic to be added.
Ble_dis.c (nrf51822\source\ble\ble_services): * @param[in]   dis_attr_md    Security settings of characteristic to be added.
Ble_dis.c (nrf51822\source\ble\ble_services):static uint32_t char_add(uint16_t                        uuid,
Ble_dis.c (nrf51822\source\ble\ble_services):    char_md.char_props.read  = 1;
Ble_dis.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = dis_attr_md->read_perm;
Ble_dis.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(service_handle, &char_md, &attr_char_value, p_handles);
Ble_dis.c (nrf51822\source\ble\ble_services):    // Add service
Ble_dis.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &service_handle);
Ble_dis.c (nrf51822\source\ble\ble_services):    // Add characteristics
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_MANUFACTURER_NAME_STRING_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_MODEL_NUMBER_STRING_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_SERIAL_NUMBER_STRING_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_HARDWARE_REVISION_STRING_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_FIRMWARE_REVISION_STRING_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_SOFTWARE_REVISION_STRING_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_SYSTEM_ID_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_IEEE_REGULATORY_CERTIFICATION_DATA_LIST_CHAR,
Ble_dis.c (nrf51822\source\ble\ble_services):        err_code = char_add(BLE_UUID_PNP_ID_CHAR,
Ble_dis.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_dis.h (nrf51822\include\ble\ble_services): *          During initialization it adds the Device Information Service to the BLE stack database.
Ble_dis.h (nrf51822\include\ble\ble_services): *          It then encodes the supplied information, and adds the curresponding characteristics.
Ble_dis.h (nrf51822\include\ble\ble_services): *          It adds the DIS service and DIS characteristics to the database, using the initial
Ble_dis.h (nrf51822\include\ble\ble_services): *          added, shall be set to NULL in p_dis_init.
Ble_dtm.c (nrf51822\source\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_dtm.c (nrf51822\source\ble):#define DTM_HEADER_OFFSET               0                                                   /**< Index where the header of the pdu is located. */
Ble_dtm.c (nrf51822\source\ble):#define DTM_HEADER_SIZE                 2                                                   /**< Size of PDU header. */
Ble_dtm.c (nrf51822\source\ble):#define DTM_PAYLOAD_MAX_SIZE            37                                                  /**< Maximum payload size allowed during dtm execution. */
Ble_dtm.c (nrf51822\source\ble):#define DTM_LENGTH_OFFSET               (DTM_HEADER_OFFSET + 1)                             /**< Index where the length of the payload is encoded. */
Ble_dtm.c (nrf51822\source\ble):#define DTM_PDU_MAX_MEMORY_SIZE         (DTM_HEADER_SIZE + DTM_PAYLOAD_MAX_SIZE)            /**< Maximum PDU size allowed during dtm execution. */
Ble_dtm.c (nrf51822\source\ble):#define RX_MODE                         true                                                /**< Constant defining RX mode for radio during dtm test. */
Ble_dtm.c (nrf51822\source\ble):#define TX_MODE                         false                                               /**< Constant defining TX mode for radio during dtm test. */
Ble_dtm.c (nrf51822\source\ble):                       0xc,  0x18, 0x53, 0x2c, 0xfd}                                        /**< The PRBS9 sequence used as packet payload. */
Ble_dtm.c (nrf51822\source\ble):    uint8_t content[DTM_HEADER_SIZE + DTM_PAYLOAD_MAX_SIZE];                                /**< PDU packet content. */
Ble_dtm.c (nrf51822\source\ble):static uint8_t                          m_packet_length;                                    /**< Payload length of transmitted PDU, bits 2:7 of 16-bit dtm command. */
Ble_dtm.c (nrf51822\source\ble):static uint8_t                          m_packetHeaderLFlen = 8;                            /**< Length of length field in packet Header (in bits). */
Ble_dtm.c (nrf51822\source\ble):static uint8_t                          m_packetHeaderS0len = 1;                            /**< Length of S0 field in packet Header (in bytes). */
Ble_dtm.c (nrf51822\source\ble):static uint8_t                          m_packetHeaderS1len = 0;                            /**< Length of S1 field in packet Header (in bits). */
Ble_dtm.c (nrf51822\source\ble):static uint8_t                          m_crcConfSkipAddr   = 1;                            /**< Leave packet address field out of CRC calculation. */
Ble_dtm.c (nrf51822\source\ble):static uint8_t                          m_static_length     = 0;                            /**< Number of bytes sent in addition to the var.length payload. */
Ble_dtm.c (nrf51822\source\ble):static uint32_t                         m_balen             = 3;                            /**< Base address length in bytes. */
Ble_dtm.c (nrf51822\source\ble):static uint32_t                         m_endian            = RADIO_PCNF1_ENDIAN_Little;    /**< On air endianess of packet, this applies to the S0, LENGTH, S1 and the PAYLOAD fields. */
Ble_dtm.c (nrf51822\source\ble):static uint32_t                         m_whitening         = RADIO_PCNF1_WHITEEN_Disabled; /**< Whitening disabled. */
Ble_dtm.c (nrf51822\source\ble):static uint8_t                          m_crcLength         = RADIO_CRCCNF_LEN_Three;       /**< CRC Length (in bytes). */
Ble_dtm.c (nrf51822\source\ble):static uint32_t                         m_address           = 0x71764129;                   /**< Address. */
Ble_dtm.c (nrf51822\source\ble):static uint8_t                          m_radio_mode        = RADIO_MODE_MODE_Ble_1Mbit;    /**< nRF51 specific radio mode vale. */
Ble_dtm.c (nrf51822\source\ble):    uint8_t        k;                   // Byte pointer for running through PDU payload
Ble_dtm.c (nrf51822\source\ble):    uint8_t        pattern;             // Repeating octet value in payload
Ble_dtm.c (nrf51822\source\ble):    pdu_packet_type = (dtm_pkt_type_t)(m_pdu.content[DTM_HEADER_OFFSET] & 0x0F);
Ble_dtm.c (nrf51822\source\ble):    if ((pdu_packet_type > (dtm_pkt_type_t)PACKET_TYPE_MAX) || (length > DTM_PAYLOAD_MAX_SIZE))
Ble_dtm.c (nrf51822\source\ble):        // Payload does not consist of one repeated octet; must compare ir with entire block into
Ble_dtm.c (nrf51822\source\ble):        return (memcmp(m_pdu.content+DTM_HEADER_SIZE, m_prbs_content, length) == 0);
Ble_dtm.c (nrf51822\source\ble):        // Check repeated pattern filling the PDU payload 
Ble_dtm.c (nrf51822\source\ble):/**@brief Function for turning off the radio after a test.
Ble_dtm.c (nrf51822\source\ble): *        Also called after test done, to be ready for next test.
Ble_dtm.c (nrf51822\source\ble):static void radio_reset(void)
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->SHORTS          = 0;
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->EVENTS_DISABLED = 0;
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->TASKS_DISABLE   = 1;
Ble_dtm.c (nrf51822\source\ble):    while (NRF_RADIO->EVENTS_DISABLED == 0)
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->EVENTS_DISABLED = 0;
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->TASKS_RXEN      = 0;
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->TASKS_TXEN      = 0;
Ble_dtm.c (nrf51822\source\ble):/**@brief Function for initializing the radio for DTM.
Ble_dtm.c (nrf51822\source\ble):static uint32_t radio_init(void)
Ble_dtm.c (nrf51822\source\ble):    // are constant. Non-constant values are essentially set in radio_prepare().
Ble_dtm.c (nrf51822\source\ble):         (m_radio_mode > RADIO_MODE_MODE_Ble_1Mbit)       // Values 0-2: Proprietary mode, 3 (last valid): BLE
Ble_dtm.c (nrf51822\source\ble):    // Turn off radio before configuring it
Ble_dtm.c (nrf51822\source\ble):    radio_reset();
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->TXPOWER = m_tx_power;
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->MODE    = m_radio_mode << RADIO_MODE_MODE_Pos;
Ble_dtm.c (nrf51822\source\ble):    // Set the access address, address0/prefix0 used for both Rx and Tx address
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->PREFIX0     &= ~RADIO_PREFIX0_AP0_Msk;
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->PREFIX0     |= (m_address >> 24) & RADIO_PREFIX0_AP0_Msk;
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->BASE0        = m_address << 8;
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->RXADDRESSES  = RADIO_RXADDRESSES_ADDR0_Enabled << RADIO_RXADDRESSES_ADDR0_Pos;
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->TXADDRESS    = (0x00 << RADIO_TXADDRESS_TXADDRESS_Pos) & RADIO_TXADDRESS_TXADDRESS_Msk;
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->CRCCNF = (m_crcConfSkipAddr << RADIO_CRCCNF_SKIP_ADDR_Pos) |
Ble_dtm.c (nrf51822\source\ble):                        (m_crcLength << RADIO_CRCCNF_LEN_Pos);
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->PCNF0 = (m_packetHeaderS1len  << RADIO_PCNF0_S1LEN_Pos) |
Ble_dtm.c (nrf51822\source\ble):                       (m_packetHeaderS0len  << RADIO_PCNF0_S0LEN_Pos) |
Ble_dtm.c (nrf51822\source\ble):                       (m_packetHeaderLFlen  << RADIO_PCNF0_LFLEN_Pos);
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->PCNF1 = (m_whitening          << RADIO_PCNF1_WHITEEN_Pos) |
Ble_dtm.c (nrf51822\source\ble):                       (m_endian             << RADIO_PCNF1_ENDIAN_Pos)  |
Ble_dtm.c (nrf51822\source\ble):                       (m_balen              << RADIO_PCNF1_BALEN_Pos)   |
Ble_dtm.c (nrf51822\source\ble):                       (m_static_length      << RADIO_PCNF1_STATLEN_Pos) |
Ble_dtm.c (nrf51822\source\ble):                       (DTM_PAYLOAD_MAX_SIZE << RADIO_PCNF1_MAXLEN_Pos);
Ble_dtm.c (nrf51822\source\ble):/**@brief Function for preparing the radio. At start of each test: Turn off RF, clear interrupt flags of RF, initialize the radio
Ble_dtm.c (nrf51822\source\ble): *@param[in] rx     boolean indicating if radio should be prepared in rx mode (true) or tx mode.
Ble_dtm.c (nrf51822\source\ble):static void radio_prepare(bool rx)
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->TEST         = 0;
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->CRCPOLY      = m_crc_poly;
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->CRCINIT      = m_crc_init;
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->FREQUENCY    = (m_phys_ch << 1) + 2;                     // Actual frequency (MHz): 2400 + register value
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->PACKETPTR    = (uint32_t)&m_pdu;                         // Setting packet pointer will start the radio
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->EVENTS_READY = 0;
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->SHORTS       = (1 << RADIO_SHORTS_READY_START_Pos) |     // Shortcut between READY event and START task
Ble_dtm.c (nrf51822\source\ble):                              (1 << RADIO_SHORTS_END_DISABLE_Pos);      // Shortcut between END event and DISABLE task
Ble_dtm.c (nrf51822\source\ble):        NRF_RADIO->EVENTS_END = 0;
Ble_dtm.c (nrf51822\source\ble):        NRF_RADIO->TASKS_RXEN = 1;                                       // shorts will start radio in RX mode when it is ready
Ble_dtm.c (nrf51822\source\ble):        NRF_RADIO->TXPOWER = m_tx_power;
Ble_dtm.c (nrf51822\source\ble):/**@brief Function for terminating the ongoing test (if any) and closing down the radio.
Ble_dtm.c (nrf51822\source\ble):    NRF_RADIO->TEST = 0;
Ble_dtm.c (nrf51822\source\ble):    NRF_PPI->CH[0].EEP = 0;     // Break connection from timer to radio to stop transmit loop
Ble_dtm.c (nrf51822\source\ble):    radio_reset();
Ble_dtm.c (nrf51822\source\ble):            // should be transmitted by the radio.
Ble_dtm.c (nrf51822\source\ble):            radio_prepare(TX_MODE);
Ble_dtm.c (nrf51822\source\ble):            NRF_RADIO->TEST = (RADIO_TEST_PLL_LOCK_Enabled << RADIO_TEST_PLL_LOCK_Pos) |
Ble_dtm.c (nrf51822\source\ble):                              (RADIO_TEST_CONST_CARRIER_Enabled << RADIO_TEST_CONST_CARRIER_Pos);
Ble_dtm.c (nrf51822\source\ble):            // Shortcut between READY event and START task
Ble_dtm.c (nrf51822\source\ble):            NRF_RADIO->SHORTS = 1 << RADIO_SHORTS_READY_START_Pos;
Ble_dtm.c (nrf51822\source\ble):            // Shortcut will start radio in Tx mode when it is ready
Ble_dtm.c (nrf51822\source\ble):            NRF_RADIO->TASKS_TXEN = 1;
Ble_dtm.c (nrf51822\source\ble):    if ((timer_init() != DTM_SUCCESS) || (radio_init() != DTM_SUCCESS))
Ble_dtm.c (nrf51822\source\ble):        // handle radio first, to give it highest priority:
Ble_dtm.c (nrf51822\source\ble):        if (NRF_RADIO->EVENTS_END != 0)
Ble_dtm.c (nrf51822\source\ble):            NRF_RADIO->EVENTS_END = 0;
Ble_dtm.c (nrf51822\source\ble):            NVIC_ClearPendingIRQ(RADIO_IRQn);
Ble_dtm.c (nrf51822\source\ble):                NRF_RADIO->TASKS_RXEN = 1;
Ble_dtm.c (nrf51822\source\ble):                if ((NRF_RADIO->CRCSTATUS == 1) && check_pdu())
Ble_dtm.c (nrf51822\source\ble):uint32_t dtm_cmd(dtm_cmd_t cmd, dtm_freq_t freq, uint32_t length, dtm_pkt_type_t payload)
Ble_dtm.c (nrf51822\source\ble):    m_packet_type   = payload;
Ble_dtm.c (nrf51822\source\ble):        radio_prepare(RX_MODE);                                // Reinitialize "everything"; RF interrupts OFF
Ble_dtm.c (nrf51822\source\ble):        if (m_packet_length > DTM_PAYLOAD_MAX_SIZE)
Ble_dtm.c (nrf51822\source\ble):        m_pdu.content[DTM_HEADER_OFFSET] = ((uint8_t)m_packet_type & 0x0F); 
Ble_dtm.c (nrf51822\source\ble):                memcpy(m_pdu.content + DTM_HEADER_SIZE, m_prbs_content, length);
Ble_dtm.c (nrf51822\source\ble):                memset(m_pdu.content + DTM_HEADER_SIZE, RFPHY_TEST_0X0F_REF_PATTERN, length);
Ble_dtm.c (nrf51822\source\ble):                memset(m_pdu.content + DTM_HEADER_SIZE, RFPHY_TEST_0X55_REF_PATTERN, length);
Ble_dtm.c (nrf51822\source\ble):        radio_prepare(TX_MODE);             
Ble_dtm.c (nrf51822\source\ble):        // Configure PPI so that timer will activate radio every 625 us
Ble_dtm.c (nrf51822\source\ble):        NRF_PPI->CH[0].TEP = (uint32_t)&NRF_RADIO->TASKS_TXEN;
Ble_dtm.c (nrf51822\source\ble):    // return value indicates whether this value was already retrieved.
Ble_dtm.c (nrf51822\source\ble):          DTM_PKT_VENDORSPECIFIC as payload, SET_TX_POWER as length, and the dBm value as frequency.
Ble_dtm.c (nrf51822\source\ble):    // radio->TXPOWER register is 32 bits, low octet a signed value, upper 24 bits zeroed
Ble_dtm.c (nrf51822\source\ble):        // radio must be idle to change the tx power
Ble_dtm.c (nrf51822\source\ble):        // Parameter outside valid range: nRF radio is restricted to the range -40 dBm to +4 dBm
Ble_dtm.c (nrf51822\source\ble):        // Parameter error: The nRF51 radio requires settings that are a multiple of 4.
Ble_dtm.c (nrf51822\source\ble): *        DTM_PKT_VENDORSPECIFIC as payload, SELECT_TIMER as length, and the timer as freq
Ble_dtm.h (nrf51822\include\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_dtm.h (nrf51822\include\ble):#define DEFAULT_TX_POWER                RADIO_TXPOWER_TXPOWER_Pos4dBm   /**< Default Transmission power using in the DTM module. */
Ble_dtm.h (nrf51822\include\ble):// when cmd == LE_TRANSMITTER_TEST and payload == DTM_PKT_VENDORSPECIFIC
Ble_dtm.h (nrf51822\include\ble):#define DTM_ERROR_ILLEGAL_LENGTH        0x03                            /**< Payload size must be in the range 0..37. */
Ble_dtm.h (nrf51822\include\ble):typedef uint32_t dtm_pkt_type_t;                                        /**< Type for holding the requested DTM payload type.*/
Ble_dtm.h (nrf51822\include\ble):/**@brief Function for giving control to dtmlib for handling timer and radio events.
Ble_dtm.h (nrf51822\include\ble): *        Will return to caller at 625us intervals or whenever another event than radio occurs
Ble_dtm.h (nrf51822\include\ble): * @param[in]   length    Payload length, 0..37 (bits 2:7 in the 16-bit UART format).
Ble_dtm.h (nrf51822\include\ble): * @param[in]   payload   One of the DTM_PKT values (bits 0:1 in the 16-bit UART format).
Ble_dtm.h (nrf51822\include\ble):uint32_t dtm_cmd(dtm_cmd_t cmd, dtm_freq_t freq, uint32_t length, dtm_pkt_type_t payload);
Ble_dtm.h (nrf51822\include\ble):/**@brief Function for reading the result of a DTM command
Ble_dtm.h (nrf51822\include\ble): * @return      true: new event, false: no event since last call, this event has been read earlier
Ble_err.h (nrf51822\include\ble\softdevice):  @addtogroup BLE_COMMON
Ble_err.h (nrf51822\include\ble\softdevice):  @addtogroup  nrf_error
Ble_error_log.c (nrf51822\source\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_error_log.c (nrf51822\source\ble):// Made static to avoid the error_log to go on the stack.
Ble_error_log.c (nrf51822\source\ble):extern uint32_t             * __Vectors;                  /**< The initialization vector holds the address to __initial_sp that will be used when fetching the stack. */ 
Ble_error_log.c (nrf51822\source\ble):uint32_t ble_error_log_read(ble_error_log_data_t * error_log)
Ble_error_log.c (nrf51822\source\ble):    err_code = ble_flash_page_read(FLASH_PAGE_ERROR_LOG, (uint32_t *) error_log, &error_log_size);
Ble_error_log.c (nrf51822\source\ble):        // Put breakpoint, and read data, then log->failure=false; to continue in debug mode.
Ble_error_log.c (nrf51822\source\ble):        // e.g. read button 6, if pressed, then clear log and continue.
Ble_error_log.c (nrf51822\source\ble):    // Variable made volatile in order to avoid optimization.
Ble_error_log.c (nrf51822\source\ble):    // and set 'read_error_log = true' in the debugger to break execution.
Ble_error_log.c (nrf51822\source\ble):    volatile bool read_error_log = false;
Ble_error_log.c (nrf51822\source\ble):    if (read_error_log)
Ble_error_log.c (nrf51822\source\ble):        err_code = ble_error_log_read(&m_ble_error_log);
Ble_error_log.h (nrf51822\include\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_error_log.h (nrf51822\include\ble): * @note This function will force the writing to flash, and disregard any radio communication.
Ble_error_log.h (nrf51822\include\ble):/**@brief Function for reading Error Log from flash.
Ble_error_log.h (nrf51822\include\ble):uint32_t ble_error_log_read(ble_error_log_data_t * error_log);
Ble_error_log.h (nrf51822\include\ble): * @details If an error was present and execution is blocked at @see ble_error_log_read() then this
Ble_error_log.h (nrf51822\include\ble): *          function will notify the read and ensure operation continues. This function is expected
Ble_eval_board_pins.h (nrf51822\include\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_eval_board_pins.h (nrf51822\include\ble):#define ADVERTISING_LED_PIN_NO     EVAL_BOARD_LED_0     /**< Pin that can be used by applications to indicate advertising state.*/
Ble_flash.c (nrf51822\source\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_flash.c (nrf51822\source\ble):#include "ble_radio_notification.h"
Ble_flash.c (nrf51822\source\ble):static volatile bool m_radio_active = false;  /**< TRUE if radio is active (or about to become active), FALSE otherwise. */
Ble_flash.c (nrf51822\source\ble):    // Turn on flash erase enable and wait until the NVMC is ready.
Ble_flash.c (nrf51822\source\ble):    while (NRF_NVMC->READY == NVMC_READY_READY_Busy) {
Ble_flash.c (nrf51822\source\ble):    while (NRF_NVMC->READY == NVMC_READY_READY_Busy) {
Ble_flash.c (nrf51822\source\ble):    // Turn off flash erase enable and wait until the NVMC is ready.
Ble_flash.c (nrf51822\source\ble):    while (NRF_NVMC->READY == NVMC_READY_READY_Busy) {
Ble_flash.c (nrf51822\source\ble):/**@brief Function for writing one word to flash. Unprotected write, which can interfere with radio communication.
Ble_flash.c (nrf51822\source\ble): * @details This function DOES NOT use the m_radio_active variable, but will force the write even
Ble_flash.c (nrf51822\source\ble): *          when the radio is active. To be used only from @ref ble_flash_page_write.
Ble_flash.c (nrf51822\source\ble): * @param[in]  p_address   Pointer to flash location to be written.
Ble_flash.c (nrf51822\source\ble):static void flash_word_unprotected_write(uint32_t * p_address, uint32_t value)
Ble_flash.c (nrf51822\source\ble):    // Turn on flash write enable and wait until the NVMC is ready.
Ble_flash.c (nrf51822\source\ble):    while (NRF_NVMC->READY == NVMC_READY_READY_Busy) {
Ble_flash.c (nrf51822\source\ble):    *p_address = value;
Ble_flash.c (nrf51822\source\ble):    while (NRF_NVMC->READY == NVMC_READY_READY_Busy) {
Ble_flash.c (nrf51822\source\ble):    // Turn off flash write enable and wait until the NVMC is ready.
Ble_flash.c (nrf51822\source\ble):    while (NRF_NVMC->READY == NVMC_READY_READY_Busy) {
Ble_flash.c (nrf51822\source\ble): * @param[in]  p_address   Pointer to flash location to be written.
Ble_flash.c (nrf51822\source\ble):static void flash_word_write(uint32_t * p_address, uint32_t value)
Ble_flash.c (nrf51822\source\ble):    // If radio is active, wait for it to become inactive.
Ble_flash.c (nrf51822\source\ble):    while (m_radio_active) {
Ble_flash.c (nrf51822\source\ble):        // Do nothing (just wait for radio to become inactive).
Ble_flash.c (nrf51822\source\ble):    // Turn on flash write enable and wait until the NVMC is ready.
Ble_flash.c (nrf51822\source\ble):    while (NRF_NVMC->READY == NVMC_READY_READY_Busy) {
Ble_flash.c (nrf51822\source\ble):    *p_address = value;
Ble_flash.c (nrf51822\source\ble):    while (NRF_NVMC->READY == NVMC_READY_READY_Busy) {
Ble_flash.c (nrf51822\source\ble):    // Turn off flash write enable and wait until the NVMC is ready.
Ble_flash.c (nrf51822\source\ble):    while (NRF_NVMC->READY == NVMC_READY_READY_Busy) {
Ble_flash.c (nrf51822\source\ble):uint32_t ble_flash_word_write(uint32_t * p_address, uint32_t value)
Ble_flash.c (nrf51822\source\ble):    flash_word_write(p_address, value);
Ble_flash.c (nrf51822\source\ble):uint32_t ble_flash_block_write(uint32_t * p_address, uint32_t * p_in_array, uint16_t word_count)
Ble_flash.c (nrf51822\source\ble):        flash_word_write(p_address, p_in_array[i]);
Ble_flash.c (nrf51822\source\ble):        p_address++;
Ble_flash.c (nrf51822\source\ble):* This function is used to write content to a flash page which has already been
Ble_flash.c (nrf51822\source\ble):    //check is page already erased
Ble_flash.c (nrf51822\source\ble):    ASSERT(word_count <= (BLE_FLASH_PAGE_SIZE/sizeof(uint32_t) - FLASH_PAGE_HEADER_LEN));
Ble_flash.c (nrf51822\source\ble):    uint32_t *  address = 0;
Ble_flash.c (nrf51822\source\ble):    uint32_t    flash_header;
Ble_flash.c (nrf51822\source\ble):    ble_flash_page_addr(page_num,&address);
Ble_flash.c (nrf51822\source\ble):    for(i = 0; i< (word_count + FLASH_PAGE_HEADER_LEN); ++i ) {
Ble_flash.c (nrf51822\source\ble):        if(*(address + i) != 0xFFFFFFFF) {
Ble_flash.c (nrf51822\source\ble):    if( i< (word_count + FLASH_PAGE_HEADER_LEN) ) {
Ble_flash.c (nrf51822\source\ble):        return NRF_ERROR_INVALID_ADDR;
Ble_flash.c (nrf51822\source\ble):        ble_flash_word_write((address + i + FLASH_PAGE_HEADER_LEN), p_in_array[i] );
Ble_flash.c (nrf51822\source\ble):    //write flash header
Ble_flash.c (nrf51822\source\ble):    flash_header = BLE_FLASH_MAGIC_NUMBER | (uint32_t)flash_crc;
Ble_flash.c (nrf51822\source\ble):    ble_flash_word_write(address,flash_header);
Ble_flash.c (nrf51822\source\ble):    ble_flash_word_write(address + 1, word_count);
Ble_flash.c (nrf51822\source\ble):uint32_t bd_flash_read_page(uint8_t page_num, uint32_t * p_out_array, uint8_t * p_word_count)
Ble_flash.c (nrf51822\source\ble):    return  ble_flash_page_read(page_num,p_out_array,p_word_count);
Ble_flash.c (nrf51822\source\ble):uint32_t check_is_flash_erased(uint32_t * address ,uint16_t wordCount)
Ble_flash.c (nrf51822\source\ble):        if(*(address + index) != 0xFFFFFFFF) {
Ble_flash.c (nrf51822\source\ble):    uint32_t * p_curr_addr;
Ble_flash.c (nrf51822\source\ble):    uint32_t   flash_header;
Ble_flash.c (nrf51822\source\ble):    p_curr_addr = p_page;
Ble_flash.c (nrf51822\source\ble):    flash_header = *p_curr_addr;
Ble_flash.c (nrf51822\source\ble):    flash_crc    = (uint16_t)flash_header;
Ble_flash.c (nrf51822\source\ble):        // Data is the same as the data already stored in flash, return without modifying flash.
Ble_flash.c (nrf51822\source\ble):    p_curr_addr++;
Ble_flash.c (nrf51822\source\ble):    p_curr_addr++;
Ble_flash.c (nrf51822\source\ble):        flash_word_unprotected_write(p_curr_addr, p_in_array[i]);
Ble_flash.c (nrf51822\source\ble):        p_curr_addr++;
Ble_flash.c (nrf51822\source\ble):    flash_header = BLE_FLASH_MAGIC_NUMBER | (uint32_t)in_data_crc;
Ble_flash.c (nrf51822\source\ble):    flash_word_write(p_page, flash_header);
Ble_flash.c (nrf51822\source\ble):uint32_t ble_flash_page_read(uint8_t page_num, uint32_t * p_out_array, uint8_t * p_word_count)
Ble_flash.c (nrf51822\source\ble):    uint32_t * p_curr_addr;
Ble_flash.c (nrf51822\source\ble):    uint32_t   flash_header;
Ble_flash.c (nrf51822\source\ble):    uint32_t   calc_header;
Ble_flash.c (nrf51822\source\ble):    p_curr_addr = p_page;
Ble_flash.c (nrf51822\source\ble):    flash_header = *p_curr_addr;
Ble_flash.c (nrf51822\source\ble):    tmp = flash_header & 0xFFFF0000;
Ble_flash.c (nrf51822\source\ble):    p_curr_addr++;
Ble_flash.c (nrf51822\source\ble):    // Read number of elements
Ble_flash.c (nrf51822\source\ble):    *p_word_count = (uint8_t)(*(p_curr_addr));
Ble_flash.c (nrf51822\source\ble):    p_curr_addr++;
Ble_flash.c (nrf51822\source\ble):    // Read data
Ble_flash.c (nrf51822\source\ble):    memcpy(p_out_array, p_curr_addr, byte_count);
Ble_flash.c (nrf51822\source\ble):    calc_header = BLE_FLASH_MAGIC_NUMBER | (uint32_t)calc_crc;
Ble_flash.c (nrf51822\source\ble):    if (calc_header != flash_header) {
Ble_flash.c (nrf51822\source\ble):uint32_t ble_flash_page_addr(uint8_t page_num, uint32_t ** pp_page_addr)
Ble_flash.c (nrf51822\source\ble):    *pp_page_addr = (uint32_t *)(BLE_FLASH_PAGE_SIZE * page_num);
Ble_flash.c (nrf51822\source\ble):    for(index = 0; index < flash_page_to_erase_Q_len; index ++) { // if this page aready exist here, ignore new request
Ble_flash.c (nrf51822\source\ble):        return NRF_ERROR_INVALID_ADDR;
Ble_flash.c (nrf51822\source\ble):uint32_t radio_inactive_time;
Ble_flash.c (nrf51822\source\ble):* erase when slow advertising & long connection interval 
Ble_flash.c (nrf51822\source\ble):    //add this jusge for assurance, because this function is scheduled while
Ble_flash.c (nrf51822\source\ble):    //radio is working, so   get_global_bluetooth_status() == NotWork may never
Ble_flash.c (nrf51822\source\ble):    if((get_global_bluetooth_status() == SlowAdvertising) || (get_global_bluetooth_status() == LongConnectInterval)) {
Ble_flash.c (nrf51822\source\ble):        if(NRF_RTC1->COUNTER > radio_inactive_time)
Ble_flash.c (nrf51822\source\ble):            inactive_last_time = NRF_RTC1->COUNTER - radio_inactive_time;
Ble_flash.c (nrf51822\source\ble):            inactive_last_time = NRF_RTC1->COUNTER - radio_inactive_time + MAX_RTC_COUNTER_VAL;
Ble_flash.c (nrf51822\source\ble):bool ble_radio_active(void)
Ble_flash.c (nrf51822\source\ble):    return m_radio_active;
Ble_flash.c (nrf51822\source\ble):void ble_flash_on_radio_active_evt(bool radio_active)
Ble_flash.c (nrf51822\source\ble):    m_radio_active = radio_active;
Ble_flash.c (nrf51822\source\ble):    if( !m_radio_active && flash_page_to_erase_Q_len) {
Ble_flash.c (nrf51822\source\ble):        radio_inactive_time = NRF_RTC1->COUNTER;
Ble_flash.c (nrf51822\source\ble):        LOG(LEVEL_INFO,"-m_radio_active: %d,rtc: %d\r\n",m_radio_active,radio_inactive_time);
Ble_flash.c (nrf51822\source\ble):void radio_disable(void)
Ble_flash.c (nrf51822\source\ble):    NRF_RADIO->SHORTS          = 0;
Ble_flash.c (nrf51822\source\ble):    NRF_RADIO->EVENTS_DISABLED = 0;
Ble_flash.c (nrf51822\source\ble):    NRF_RADIO->TEST            = 0;
Ble_flash.c (nrf51822\source\ble):    NRF_RADIO->TASKS_DISABLE   = 1;
Ble_flash.c (nrf51822\source\ble):    while (NRF_RADIO->EVENTS_DISABLED == 0) {
Ble_flash.c (nrf51822\source\ble):    NRF_RADIO->EVENTS_DISABLED = 0;
Ble_flash.c (nrf51822\source\ble):    set_radio_active_flag(false);
Ble_flash.c (nrf51822\source\ble):* This function should only be called after stop radio 
Ble_flash.c (nrf51822\source\ble):void set_radio_active_flag(bool value)
Ble_flash.c (nrf51822\source\ble):        m_radio_active = false;
Ble_flash.h (nrf51822\include\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_flash.h (nrf51822\include\ble): * @details It contains functions for reading, writing and erasing one page in flash.
Ble_flash.h (nrf51822\include\ble):#define BLE_FLASH_EMPTY_MASK    0xFFFFFFFF                          /**< Bit mask that defines an empty address in flash. */
Ble_flash.h (nrf51822\include\ble):* flash page header, two words : |magic + crc| word_count | 
Ble_flash.h (nrf51822\include\ble):#define FLASH_PAGE_HEADER_LEN   (2)
Ble_flash.h (nrf51822\include\ble): *             to the application. If a bootloader is used, the end will be the start of the 
Ble_flash.h (nrf51822\include\ble): *             bootloader region. Otherwise, the end will be the size of the flash. 
Ble_flash.h (nrf51822\include\ble):    ((NRF_UICR->BOOTLOADERADDR != BLE_FLASH_EMPTY_MASK) \
Ble_flash.h (nrf51822\include\ble):        ? (NRF_UICR->BOOTLOADERADDR / BLE_FLASH_PAGE_SIZE) \
Ble_flash.h (nrf51822\include\ble):/**@brief Function for reading data from flash to RAM.
Ble_flash.h (nrf51822\include\ble): * @param[in]  page_num       Page number to read.
Ble_flash.h (nrf51822\include\ble): * @param[out] p_word_count   Number of 32 bits words read.
Ble_flash.h (nrf51822\include\ble): * @return     NRF_SUCCESS on successful upload, NRF_ERROR_NOT_FOUND if no valid data has been found
Ble_flash.h (nrf51822\include\ble):uint32_t ble_flash_page_read(uint8_t page_num, uint32_t * p_out_array, uint8_t * p_word_count);
Ble_flash.h (nrf51822\include\ble): * @note This operation blocks the CPU, so it should not be done while the radio is running!
Ble_flash.h (nrf51822\include\ble): * @note This operation record flash page erase request, and will execute right after radio is not active!
Ble_flash.h (nrf51822\include\ble): * @param[in]  p_address   Pointer to flash location to be written.
Ble_flash.h (nrf51822\include\ble):uint32_t ble_flash_word_write(uint32_t * p_address, uint32_t value);
Ble_flash.h (nrf51822\include\ble): * @param[in]  p_address    Pointer to start of flash location to be written.
Ble_flash.h (nrf51822\include\ble):uint32_t ble_flash_block_write(uint32_t * p_address, uint32_t * p_in_array, uint16_t word_count);
Ble_flash.h (nrf51822\include\ble): * @param[out] pp_page_addr   Pointer to start of flash page.
Ble_flash.h (nrf51822\include\ble):uint32_t ble_flash_page_addr(uint8_t page_num, uint32_t ** pp_page_addr);
Ble_flash.h (nrf51822\include\ble):/**@brief Function for handling flashing module Radio Notification event.
Ble_flash.h (nrf51822\include\ble): * @note For flash writing to work safely while in a connection or while advertising, this function
Ble_flash.h (nrf51822\include\ble): *       MUST be called from the Radio Notification module's event handler (see
Ble_flash.h (nrf51822\include\ble): *       @ref ble_radio_notification for details).
Ble_flash.h (nrf51822\include\ble): * @param[in]  radio_active   TRUE if radio is active (or about to become active), FALSE otherwise.
Ble_flash.h (nrf51822\include\ble):void ble_flash_on_radio_active_evt(bool radio_active);
Ble_flash.h (nrf51822\include\ble):bool ble_radio_active(void);
Ble_flash.h (nrf51822\include\ble):uint32_t bd_flash_read_page(uint8_t page_num, uint32_t * p_out_array, uint8_t * p_word_count);
Ble_flash.h (nrf51822\include\ble):uint32_t check_is_flash_erased(uint32_t * address ,uint16_t wordCount);
Ble_flash.h (nrf51822\include\ble):void radio_disable(void);
Ble_flash.h (nrf51822\include\ble):void set_radio_active_flag(bool value);
Ble_gap.h (nrf51822\include\ble\softdevice):  @addtogroup BLE_GAP Generic Access Profile (GAP)
Ble_gap.h (nrf51822\include\ble\softdevice):  SD_BLE_GAP_ADDRESS_SET  = BLE_GAP_SVC_BASE,  /**< Set own Bluetooth Address. */
Ble_gap.h (nrf51822\include\ble\softdevice):  SD_BLE_GAP_ADDRESS_GET,                      /**< Get own Bluetooth Address. */
Ble_gap.h (nrf51822\include\ble\softdevice):  SD_BLE_GAP_ADV_DATA_SET,                     /**< Set Advertisement Data. */
Ble_gap.h (nrf51822\include\ble\softdevice):  SD_BLE_GAP_ADV_START,                        /**< Start Advertising. */
Ble_gap.h (nrf51822\include\ble\softdevice):  SD_BLE_GAP_ADV_STOP,                         /**< Stop Advertising. */
Ble_gap.h (nrf51822\include\ble\softdevice):/** @addtogroup BLE_GAP_DEFINES Defines
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST   (NRF_GAP_ERR_BASE + 0x001)  /**< Use of Whitelist not permitted with discoverable advertising. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_ERROR_GAP_INVALID_BLE_ADDR              (NRF_GAP_ERR_BASE + 0x002)  /**< The upper two bits of the address do not correspond to the specified address type. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_TIMEOUT_SRC_ADVERTISEMENT              0x00 /**< Advertisement timeout. */
Ble_gap.h (nrf51822\include\ble\softdevice):/** @defgroup BLE_GAP_ADDR_TYPES GAP Address types
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADDR_TYPE_PUBLIC                        0x00 /**< Public address. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADDR_TYPE_RANDOM_STATIC                 0x01 /**< Random Static address. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE     0x02 /**< Private Resolvable address. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE 0x03 /**< Private Non-Resolvable address. */
Ble_gap.h (nrf51822\include\ble\softdevice):/** @brief BLE address length. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADDR_LEN            6
Ble_gap.h (nrf51822\include\ble\softdevice):/** @defgroup BLE_GAP_AD_TYPE_DEFINITIONS GAP Advertising and Scan Response Data format
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_FLAGS                               0x01 /**< Flags for discoverability. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE   0x02 /**< Partial list of 16 bit service UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE         0x03 /**< Complete list of 16 bit service UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_MORE_AVAILABLE   0x04 /**< Partial list of 32 bit service UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_COMPLETE         0x05 /**< Complete list of 32 bit service UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE  0x06 /**< Partial list of 128 bit service UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE        0x07 /**< Complete list of 128 bit service UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME                    0x08 /**< Short local device name. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME                 0x09 /**< Complete local device name. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_TX_POWER_LEVEL                      0x0A /**< Transmit power level. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_CLASS_OF_DEVICE                     0x0D /**< Class of device. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C               0x0E /**< Simple Pairing Hash C. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R         0x0F /**< Simple Pairing Randomizer R. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_TK_VALUE           0x10 /**< Security Manager TK Value. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_OOB_FLAGS          0x11 /**< Security Manager Out Of Band Flags. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE     0x12 /**< Slave Connection Interval Range. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT       0x14 /**< List of 16-bit Service Solicitation UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT      0x15 /**< List of 128-bit Service Solicitation UUIDs. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_SERVICE_DATA                        0x16 /**< Service Data. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_PUBLIC_TARGET_ADDRESS               0x17 /**< Public Target Address. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_RANDOM_TARGET_ADDRESS               0x18 /**< Random Target Address. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_APPEARANCE                          0x19 /**< Appearance. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA          0xFF /**< Manufacturer Specific Data. */
Ble_gap.h (nrf51822\include\ble\softdevice):/** @defgroup BLE_GAP_ADV_FLAGS GAP Advertisement Flags
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE         (0x01)   /**< LE Limited Discoverable Mode. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE         (0x02)   /**< LE General Discoverable Mode. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED         (0x04)   /**< BR/EDR not supported. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_FLAG_LE_BR_EDR_CONTROLLER         (0x08)   /**< Simultaneous LE and BR/EDR, Controller. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_FLAG_LE_BR_EDR_HOST               (0x10)   /**< Simultaneous LE and BR/EDR, Host. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE   (BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)   /**< LE Limited Discoverable Mode, BR/EDR not supported. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE   (BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)   /**< LE General Discoverable Mode, BR/EDR not supported. */
Ble_gap.h (nrf51822\include\ble\softdevice):/** @defgroup BLE_GAP_ADV_INTERVALS GAP Advertising interval max and min
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_INTERVAL_MIN        0x0020 /**< Minimum Advertising interval in 625 us units, i.e. 20 ms. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_NONCON_INTERVAL_MIN 0x00A0 /**< Minimum Advertising interval in 625 us units for non connectable mode, i.e. 100 ms. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_INTERVAL_MAX        0x4000 /**< Maximum Advertising interval in 625 us units, i.e. 10.24 s. */
Ble_gap.h (nrf51822\include\ble\softdevice):/** @brief Maximum size of advertising data in octets. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define  BLE_GAP_ADV_MAX_SIZE       31
Ble_gap.h (nrf51822\include\ble\softdevice):/** @defgroup BLE_GAP_ADV_TYPES GAP Advertising types
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_TYPE_ADV_IND          0x00   /**< Connectable undirected. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_TYPE_ADV_DIRECT_IND   0x01   /**< Connectable directed. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_TYPE_ADV_SCAN_IND     0x02   /**< Scannable undirected. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_TYPE_ADV_NONCONN_IND  0x03   /**< Non connectable undirected. */
Ble_gap.h (nrf51822\include\ble\softdevice):/** @defgroup BLE_GAP_ADV_FILTER_POLICIES GAP Advertising filter policies
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_FP_ANY                0x00   /**< Allow scan requests and connect requests from any device. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_FP_FILTER_SCANREQ     0x01   /**< Filter scan requests with whitelist. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_FP_FILTER_CONNREQ     0x02   /**< Filter connect requests with whitelist. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_FP_FILTER_BOTH        0x03   /**< Filter both scan and connect requests with whitelist. */
Ble_gap.h (nrf51822\include\ble\softdevice):/** @defgroup BLE_GAP_ADV_TIMEOUT_VALUES GAP Advertising timeout values
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_TIMEOUT_LIMITED_MAX      180 /**< Maximum advertising time in limited discoverable mode (TGAP(lim_adv_timeout) = 180s in spec (Addendum 2)). */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_ADV_TIMEOUT_GENERAL_UNLIMITED  0 /**< Unlimited advertising in general discoverable mode. */
Ble_gap.h (nrf51822\include\ble\softdevice):/**@brief Maximum amount of addresses in a whitelist. */
Ble_gap.h (nrf51822\include\ble\softdevice):#define BLE_GAP_WHITELIST_ADDR_MAX_COUNT (8)
Ble_gap.h (nrf51822\include\ble\softdevice):/**@brief Bluetooth Low Energy address. */
Ble_gap.h (nrf51822\include\ble\softdevice):  uint8_t addr_type;                    /**< See @ref BLE_GAP_ADDR_TYPES. */
Ble_gap.h (nrf51822\include\ble\softdevice):  uint8_t addr[BLE_GAP_ADDR_LEN];       /**< 48-bit address, LSB format. */
Ble_gap.h (nrf51822\include\ble\softdevice):} ble_gap_addr_t;
Ble_gap.h (nrf51822\include\ble\softdevice):  ble_gap_addr_t   ** pp_addrs;        /**< Pointer to array of device address pointers, pointing to addresses to be used in whitelist. NULL if none are given. */
Ble_gap.h (nrf51822\include\ble\softdevice):  uint8_t             addr_count;      /**< Count of device addresses in array, up to @ref BLE_GAP_WHITELIST_ADDR_MAX_COUNT. */
Ble_gap.h (nrf51822\include\ble\softdevice):/**@brief GAP advertising parameters.*/
Ble_gap.h (nrf51822\include\ble\softdevice):  uint8_t               type;                 /**< See @ref BLE_GAP_ADV_TYPES. */
Ble_gap.h (nrf51822\include\ble\softdevice):  ble_gap_addr_t*       p_peer_addr;          /**< For BLE_GAP_CONN_MODE_DIRECTED mode only, known peer address. */
Ble_gap.h (nrf51822\include\ble\softdevice):  uint8_t               fp;                   /**< Filter Policy, see @ref BLE_GAP_ADV_FILTER_POLICIES. */
Ble_gap.h (nrf51822\include\ble\softdevice):  uint16_t              interval;             /**< Advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20ms to 10.24s), see @ref BLE_GAP_ADV_INTERVALS. This parameter must be set to 0 if type equals @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND. */
Ble_gap.h (nrf51822\include\ble\softdevice):  uint16_t              timeout;              /**< Advertising timeout between 0x0001 and 0x3FFF in seconds, 0x0000 disables timeout. See also @ref BLE_GAP_ADV_TIMEOUT_VALUES. This parameter must be set to 0 if type equals @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND. */
Ble_gap.h (nrf51822\include\ble\softdevice):} ble_gap_adv_params_t;
Ble_gap.h (nrf51822\include\ble\softdevice):  ble_gap_addr_t  addr;                       /**< Bluetooth address to which this key applies. */
Ble_gap.h (nrf51822\include\ble\softdevice):  ble_gap_addr_t        peer_addr;              /**< Bluetooth address of the peer device. */
Ble_gap.h (nrf51822\include\ble\softdevice):  uint8_t               irk_match :1;           /**< If 1, peer device's address resolved using an IRK. */
Ble_gap.h (nrf51822\include\ble\softdevice):  uint8_t               irk_match_idx  :7;      /**< Index in IRK list where the address was matched. */
Ble_gap.h (nrf51822\include\ble\softdevice):  ble_gap_addr_t peer_addr;                     /**< Bluetooth address of the peer device. */
Ble_gap.h (nrf51822\include\ble\softdevice):  ble_gap_addr_t peer_addr;                     /**< Bluetooth address of the peer device. */
Ble_gap.h (nrf51822\include\ble\softdevice):  uint8_t address   : 1;                        /**< Public or static random address. */
Ble_gap.h (nrf51822\include\ble\softdevice):    ble_gap_addr_t        id_info;              /**< Central's Identity Info. */
Ble_gap.h (nrf51822\include\ble\softdevice):/** @brief Event data for advertisement report event. */
Ble_gap.h (nrf51822\include\ble\softdevice):/**@brief Set local Bluetooth address.
Ble_gap.h (nrf51822\include\ble\softdevice): * @param[in] p_addr Pointer to address structure.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS Address successfully set.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address.
Ble_gap.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_GAP_ADDRESS_SET, uint32_t, sd_ble_gap_address_set(ble_gap_addr_t const * const p_addr));
Ble_gap.h (nrf51822\include\ble\softdevice):/**@brief Get local Bluetooth address.
Ble_gap.h (nrf51822\include\ble\softdevice): * @param[out] p_addr Pointer to address structure.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS Address successfully retrieved.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gap.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_GAP_ADDRESS_GET, uint32_t, sd_ble_gap_address_get(ble_gap_addr_t * const p_addr));
Ble_gap.h (nrf51822\include\ble\softdevice):/**@brief Set, clear or update advertisement and scan response data.
Ble_gap.h (nrf51822\include\ble\softdevice): * @note The format of the advertisement data will be checked by this call to ensure interoperability.
Ble_gap.h (nrf51822\include\ble\softdevice): *       duplicating the local name in the advertisement data and scan response data. 
Ble_gap.h (nrf51822\include\ble\softdevice): * @note: To clear the advertisement data and set it to a 0-length packet, simply provide a valid pointer (p_data/p_sr_data) with its corresponding 
Ble_gap.h (nrf51822\include\ble\softdevice): * @param[in] p_data    Raw data to be placed in advertisement packet. If NULL, no changes are made to the current advertisement packet data.
Ble_gap.h (nrf51822\include\ble\softdevice): * @param[in] dlen      Data length for p_data. Max size: @ref BLE_GAP_ADV_MAX_SIZE octets. Should be 0 if p_data is NULL, can be 0 if p_data is not NULL.
Ble_gap.h (nrf51822\include\ble\softdevice): * @param[in] p_sr_data Raw data to be placed in scan response packet. If NULL, no changes are made to the current scan response packet data.
Ble_gap.h (nrf51822\include\ble\softdevice): * @param[in] srdlen    Data length for p_sr_data. Max size: @ref BLE_GAP_ADV_MAX_SIZE octets. Should be 0 if p_sr_data is NULL, can be 0 if p_data is not NULL.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS Advertisement data successfully updated or cleared.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_FLAGS Invalid combination of advertising flags supplied.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_DATA Invalid data type(s) supplied, check the advertising data format specification.
Ble_gap.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_GAP_ADV_DATA_SET, uint32_t, sd_ble_gap_adv_data_set(uint8_t const * const p_data, uint8_t dlen, uint8_t const * const p_sr_data, uint8_t srdlen));
Ble_gap.h (nrf51822\include\ble\softdevice):/**@brief Start advertising (GAP Discoverable, Connectable modes, Broadcast Procedure).
Ble_gap.h (nrf51822\include\ble\softdevice): * @param[in] p_adv_params Pointer to advertising parameters structure.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS The BLE stack has started advertising.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid Bluetooth address supplied.
Ble_gap.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_GAP_ADV_START, uint32_t, sd_ble_gap_adv_start(ble_gap_adv_params_t const * const p_adv_params));
Ble_gap.h (nrf51822\include\ble\softdevice):/**@brief Stop advertising (GAP Discoverable, Connectable modes, Broadcast Procedure).
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS The BLE stack has stopped advertising.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation (most probably not in advertising state).
Ble_gap.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_GAP_ADV_STOP, uint32_t, sd_ble_gap_adv_stop(void));
Ble_gap.h (nrf51822\include\ble\softdevice): *                           the parameters in the PPCP characteristic of the GAP service will be used instead.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_BUSY Procedure already in progress or not allowed at this time, process pending events and retry.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation (disconnection is already in progress or not connected at all).
Ble_gap.h (nrf51822\include\ble\softdevice):/**@brief Set the radio's transmit power.
Ble_gap.h (nrf51822\include\ble\softdevice): * @param[in] tx_power Radio transmit power in dBm (accepted values are -40, -30, -20, -16, -12, -8, -4, 0, and 4 dBm).
Ble_gap.h (nrf51822\include\ble\softdevice): * @note -40 dBm will not actually give -40 dBm, but will instead be remapped to -30 dBm.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gatt.h (nrf51822\include\ble\softdevice):  @addtogroup BLE_GATT Generic Attribute Profile (GATT) Common
Ble_gatt.h (nrf51822\include\ble\softdevice):/** @addtogroup BLE_GATT_DEFINES Defines
Ble_gatt.h (nrf51822\include\ble\softdevice):#define BLE_GATT_STATUS_ATTERR_READ_NOT_PERMITTED         0x0102  /**< ATT Error: Read not permitted. */
Ble_gatt.h (nrf51822\include\ble\softdevice):#define BLE_GATT_STATUS_ATTERR_ATTRIBUTE_NOT_LONG         0x010B  /**< ATT Error: Attribute cannot be read or written using read/write blob requests. */
Ble_gatt.h (nrf51822\include\ble\softdevice):#define BLE_GATT_STATUS_ATTERR_CPS_PROC_ALR_IN_PROG       0x01FE  /**< ATT Common Profile and Service Error: Procedure Already in Progress. */
Ble_gatt.h (nrf51822\include\ble\softdevice):  uint8_t broadcast       :1; /**< Broadcasting of value permitted. */
Ble_gatt.h (nrf51822\include\ble\softdevice):  uint8_t read            :1; /**< Reading value permitted. */
Ble_gattc.h (nrf51822\include\ble\softdevice):  @addtogroup BLE_GATTC Generic Attribute Profile (GATT) Client
Ble_gattc.h (nrf51822\include\ble\softdevice):  SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ,                        /**< Read Characteristic Value by UUID. */
Ble_gattc.h (nrf51822\include\ble\softdevice):  SD_BLE_GATTC_READ,                                           /**< Generic read. */
Ble_gattc.h (nrf51822\include\ble\softdevice):  SD_BLE_GATTC_CHAR_VALUES_READ,                               /**< Read multiple Characteristic Values. */
Ble_gattc.h (nrf51822\include\ble\softdevice):/** @addtogroup BLE_GATTC_DEFINES Defines
Ble_gattc.h (nrf51822\include\ble\softdevice):  BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP,                /**< Read By UUID Response event. */
Ble_gattc.h (nrf51822\include\ble\softdevice):  BLE_GATTC_EVT_READ_RSP,                                 /**< Read Response event. */
Ble_gattc.h (nrf51822\include\ble\softdevice):  BLE_GATTC_EVT_CHAR_VALS_READ_RSP,                       /**< Read multiple Response event. */
Ble_gattc.h (nrf51822\include\ble\softdevice):/**@brief GATT read by UUID handle value pair. */
Ble_gattc.h (nrf51822\include\ble\softdevice):  uint8_t             *p_value;        /**< Pointer to value, variable length (length available as value_len in ble_gattc_evt_read_by_uuid_rsp_t). 
Ble_gattc.h (nrf51822\include\ble\softdevice):/**@brief Event structure for BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP. */
Ble_gattc.h (nrf51822\include\ble\softdevice):} ble_gattc_evt_char_val_by_uuid_read_rsp_t;
Ble_gattc.h (nrf51822\include\ble\softdevice):/**@brief Event structure for BLE_GATTC_EVT_READ_RSP. */
Ble_gattc.h (nrf51822\include\ble\softdevice):} ble_gattc_evt_read_rsp_t;
Ble_gattc.h (nrf51822\include\ble\softdevice):/**@brief Event structure for BLE_GATTC_EVT_CHAR_VALS_READ_RSP. */
Ble_gattc.h (nrf51822\include\ble\softdevice):} ble_gattc_evt_char_vals_read_rsp_t;
Ble_gattc.h (nrf51822\include\ble\softdevice):    ble_gattc_evt_char_val_by_uuid_read_rsp_t   char_val_by_uuid_read_rsp;  /**< Characteristic Value Read by UUID Response Event Parameters. */
Ble_gattc.h (nrf51822\include\ble\softdevice):    ble_gattc_evt_read_rsp_t                    read_rsp;                   /**< Read Response Event Parameters. */
Ble_gattc.h (nrf51822\include\ble\softdevice):    ble_gattc_evt_char_vals_read_rsp_t          char_vals_read_rsp;         /**< Characteristic Values Read Response Event Parameters. */
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
Ble_gattc.h (nrf51822\include\ble\softdevice):/**@brief Initiate or continue a GATT Read using Characteristic UUID procedure.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @details This function initiates the Read using Characteristic UUID procedure. If the last Characteristic has not been reached,
Ble_gattc.h (nrf51822\include\ble\softdevice): * @param[in] p_uuid Pointer to a Characteristic value UUID to read.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS Successfully started or resumed the Read using Characteristic UUID procedure.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
Ble_gattc.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ, uint32_t, sd_ble_gattc_char_value_by_uuid_read(uint16_t conn_handle, ble_uuid_t const * const p_uuid, ble_gattc_handle_range_t const * const p_handle_range));
Ble_gattc.h (nrf51822\include\ble\softdevice):/**@brief Initiate or continue a GATT Read (Long) Characteristic or Descriptor procedure.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @details This function initiates a GATT Read (Long) Characteristic or Descriptor procedure. If the Characteristic or Descriptor
Ble_gattc.h (nrf51822\include\ble\softdevice): *          to be read is longer than GATT_MTU - 1, this function must be called multiple times with appropriate offset to read the 
Ble_gattc.h (nrf51822\include\ble\softdevice): * @param[in] handle The handle of the attribute to be read.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @param[in] offset Offset into the attribute value to be read.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS Successfully started or resumed the Read (Long) procedure.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
Ble_gattc.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_GATTC_READ, uint32_t, sd_ble_gattc_read(uint16_t conn_handle, uint16_t handle, uint16_t offset));
Ble_gattc.h (nrf51822\include\ble\softdevice):/**@brief Initiate a GATT Read Multiple Characteristic Values procedure.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @details This function initiates a GATT Read Multiple Characteristic Values procedure. 
Ble_gattc.h (nrf51822\include\ble\softdevice): * @param[in] p_handles A pointer to the handle(s) of the attribute(s) to be read.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS Successfully started the Read Multiple Characteristic Values procedure.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
Ble_gattc.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_GATTC_CHAR_VALUES_READ, uint32_t, sd_ble_gattc_char_values_read(uint16_t conn_handle, uint16_t const * const p_handles, uint16_t handle_count));
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gattc.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_BUSY Procedure already in progress.
Ble_gatts.h (nrf51822\include\ble\softdevice):  @addtogroup BLE_GATTS Generic Attribute Profile (GATT) Server
Ble_gatts.h (nrf51822\include\ble\softdevice):  SD_BLE_GATTS_SERVICE_ADD = BLE_GATTS_SVC_BASE, /**< Add a service. */
Ble_gatts.h (nrf51822\include\ble\softdevice):  SD_BLE_GATTS_INCLUDE_ADD,                      /**< Add an included service. */
Ble_gatts.h (nrf51822\include\ble\softdevice):  SD_BLE_GATTS_CHARACTERISTIC_ADD,               /**< Add a characteristic. */
Ble_gatts.h (nrf51822\include\ble\softdevice):  SD_BLE_GATTS_DESCRIPTOR_ADD,                   /**< Add a generic attribute. */
Ble_gatts.h (nrf51822\include\ble\softdevice):  SD_BLE_GATTS_RW_AUTHORIZE_REPLY,               /**< Reply to an authorization request for a read or write operation on one or more attributes. */ 
Ble_gatts.h (nrf51822\include\ble\softdevice):/** @addtogroup BLE_GATTS_DEFINES Defines
Ble_gatts.h (nrf51822\include\ble\softdevice):                                                will read and write directly to the memory using the pointer provided in the APIs. There are no alignment requirements for the buffer. */
Ble_gatts.h (nrf51822\include\ble\softdevice):#define BLE_GATTS_AUTHORIZE_TYPE_READ       0x01  /**< Authorize a Read Operation. */
Ble_gatts.h (nrf51822\include\ble\softdevice):/**@brief Attribute metadata. */
Ble_gatts.h (nrf51822\include\ble\softdevice):  ble_gap_conn_sec_mode_t read_perm;       /**< Read permissions. */
Ble_gatts.h (nrf51822\include\ble\softdevice):  uint8_t                 rd_auth    :1;   /**< Read Authorization and value will be requested from the application on every read operation. */ 
Ble_gatts.h (nrf51822\include\ble\softdevice):  ble_gatts_attr_md_t* p_attr_md;       /**< Pointer to the attribute metadata structure. */
Ble_gatts.h (nrf51822\include\ble\softdevice):  uint8_t*             p_value;         /**< Pointer to the attribute data. Please note that if the @ref BLE_GATTS_VLOC_USER value location is selected in the attribute metadata, this will have to point to a buffer
Ble_gatts.h (nrf51822\include\ble\softdevice):/**@brief GATT Characteristic metadata. */
Ble_gatts.h (nrf51822\include\ble\softdevice):  ble_gatts_attr_md_t*        p_user_desc_md;           /**< Attribute metadata for the User Description descriptor, or NULL for default values. */
Ble_gatts.h (nrf51822\include\ble\softdevice):  ble_gatts_attr_md_t*        p_cccd_md;                /**< Attribute metadata for the Client Characteristic Configuration Descriptor, or NULL for default values. */
Ble_gatts.h (nrf51822\include\ble\softdevice):  ble_gatts_attr_md_t*        p_sccd_md;                /**< Attribute metadata for the Server Characteristic Configuration Descriptor, or NULL for default values. */
Ble_gatts.h (nrf51822\include\ble\softdevice):/**@brief GATT Read Authorization parameters. */
Ble_gatts.h (nrf51822\include\ble\softdevice):} ble_gatts_read_authorize_params_t;
Ble_gatts.h (nrf51822\include\ble\softdevice):/**@brief GATT Read or Write Authorize Reply parameters. */
Ble_gatts.h (nrf51822\include\ble\softdevice):    ble_gatts_read_authorize_params_t   read;   /**< Read authorization parameters. */
Ble_gatts.h (nrf51822\include\ble\softdevice):  BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST,             /**< Read/Write Authorization request. */
Ble_gatts.h (nrf51822\include\ble\softdevice):/**@brief Event structure for authorize read request. */
Ble_gatts.h (nrf51822\include\ble\softdevice):  uint16_t                    offset;             /**< Offset for the read operation. */
Ble_gatts.h (nrf51822\include\ble\softdevice):} ble_gatts_evt_read_t;
Ble_gatts.h (nrf51822\include\ble\softdevice):    ble_gatts_evt_read_t      read;             /**< Attribute Read Parameters. */
Ble_gatts.h (nrf51822\include\ble\softdevice):    ble_gatts_evt_rw_authorize_request_t  authorize_request;  /**< Read or Write Authorize Request Parameters. */
Ble_gatts.h (nrf51822\include\ble\softdevice):/**@brief Add a service declaration to the local server ATT table.
Ble_gatts.h (nrf51822\include\ble\softdevice): *       add a secondary service declaration that is not referenced by another service later in the ATT table.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS Successfully added a service declaration.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gatts.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_GATTS_SERVICE_ADD, uint32_t, sd_ble_gatts_service_add(uint8_t type, ble_uuid_t const*const p_uuid, uint16_t *const p_handle));
Ble_gatts.h (nrf51822\include\ble\softdevice):/**@brief Add an include declaration to the local server ATT table.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @note It is currently only possible to add an include declaration to the last added service (i.e. only sequential addition is supported at this time). 
Ble_gatts.h (nrf51822\include\ble\softdevice): * @note The included service must already be present in the ATT table prior to this call.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS Successfully added an include declaration.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, handle values need to match previously added services.
Ble_gatts.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_GATTS_INCLUDE_ADD, uint32_t, sd_ble_gatts_include_add(uint16_t service_handle, uint16_t inc_srvc_handle, uint16_t *const p_include_handle));
Ble_gatts.h (nrf51822\include\ble\softdevice):/**@brief Add a characteristic declaration, a characteristic value declaration and optional characteristic descriptor declarations to the local server ATT table.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @note It is currently only possible to add a characteristic to the last added service (i.e. only sequential addition is supported at this time). 
Ble_gatts.h (nrf51822\include\ble\softdevice): *       readable (no security) and writeable (selectable) CCCDs and SCCDs and valid presentation format values.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @note If no metadata is provided for the optional descriptors, their permissions will be derived from the characteristic permissions.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @param[in] p_char_md         Characteristic metadata.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS Successfully added a characteristic.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, service handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints.
Ble_gatts.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_GATTS_CHARACTERISTIC_ADD, uint32_t, sd_ble_gatts_characteristic_add(uint16_t service_handle, ble_gatts_char_md_t const*const p_char_md, ble_gatts_attr_t const*const p_attr_char_value, ble_gatts_char_handles_t *const p_handles));
Ble_gatts.h (nrf51822\include\ble\softdevice):/**@brief Add a descriptor to the local server ATT table.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @note It is currently only possible to add a descriptor to the last added characteristic (i.e. only sequential addition is supported at this time). 
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_SUCCESS Successfully added a descriptor.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, characteristic handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints.
Ble_gatts.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_GATTS_DESCRIPTOR_ADD, uint32_t, sd_ble_gatts_descriptor_add(uint16_t char_handle, ble_gatts_attr_t const * const p_attr, uint16_t* const p_handle));
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @param[in] offset     Offset in bytes to read from.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @param[in,out] p_len  Length in bytes to be read, length in bytes read after successful return.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle(s) supplied. Only attributes added directly by the application are available to notify and indicate.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_BUSY Procedure already in progress.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_BUSY Procedure already in progress.
Ble_gatts.h (nrf51822\include\ble\softdevice):/**@brief Respond to a Read/Write authorization request.
Ble_gatts.h (nrf51822\include\ble\softdevice): *                                         or for Read Authorization reply: requested handles not replied with,
Ble_gatts.h (nrf51822\include\ble\softdevice): *          made immediately after a connection is established and the bond identified.
Ble_gatts.h (nrf51822\include\ble\softdevice): *          after a connection has been terminated. When a new connection is made to the same bond, the values
Ble_gatts.h (nrf51822\include\ble\softdevice): *          The data should be read before any new advertising is started, or any new connection established. The connection handle for
Ble_gatts.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_gls.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_gls.c (nrf51822\source\ble\ble_services):#define GLS_NACK_PROC_ALREADY_IN_PROGRESS   BLE_GATT_STATUS_ATTERR_APP_BEGIN + 0
Ble_gls.c (nrf51822\source\ble\ble_services):/**@brief Function for setting the next sequence number by reading the last record in the data base.
Ble_gls.c (nrf51822\source\ble\ble_services):/**@brief Function for adding the characteristic for a glucose measurement.
Ble_gls.c (nrf51822\source\ble\ble_services): * @return      NRF_SUCCESS if characteristic was successfully added, otherwise an error code.
Ble_gls.c (nrf51822\source\ble\ble_services):static uint32_t glucose_measurement_char_add(ble_gls_t * p_gls)
Ble_gls.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.read_perm);
Ble_gls.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&attr_md.read_perm);
Ble_gls.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_gls->service_handle,
Ble_gls.c (nrf51822\source\ble\ble_services):/**@brief Function for adding the characteristic for a glucose feature.
Ble_gls.c (nrf51822\source\ble\ble_services): * @return      NRF_SUCCESS if characteristic was successfully added, otherwise an error code.
Ble_gls.c (nrf51822\source\ble\ble_services):static uint32_t glucose_feature_char_add(ble_gls_t * p_gls)
Ble_gls.c (nrf51822\source\ble\ble_services):    char_md.char_props.read  = 1;    
Ble_gls.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&attr_md.read_perm);
Ble_gls.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_gls->service_handle,
Ble_gls.c (nrf51822\source\ble\ble_services):/**@brief Function for adding the characteristic for a record access control point.
Ble_gls.c (nrf51822\source\ble\ble_services): * @return      NRF_SUCCESS if characteristic was successfully added, otherwise an error code.
Ble_gls.c (nrf51822\source\ble\ble_services):static uint32_t record_access_control_point_char_add(ble_gls_t * p_gls)
Ble_gls.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.read_perm);
Ble_gls.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&attr_md.read_perm);
Ble_gls.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_gls->service_handle,
Ble_gls.c (nrf51822\source\ble\ble_services):    // Add service
Ble_gls.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_gls->service_handle);
Ble_gls.c (nrf51822\source\ble\ble_services):    // Add glucose measurement characteristic
Ble_gls.c (nrf51822\source\ble\ble_services):    err_code = glucose_measurement_char_add(p_gls);
Ble_gls.c (nrf51822\source\ble\ble_services):    // Add glucose measurement feature characteristic
Ble_gls.c (nrf51822\source\ble\ble_services):    err_code = glucose_feature_char_add(p_gls);
Ble_gls.c (nrf51822\source\ble\ble_services):    // Add record control access point characteristic
Ble_gls.c (nrf51822\source\ble\ble_services):    err_code = record_access_control_point_char_add(p_gls);
Ble_gls.c (nrf51822\source\ble\ble_services):        auth_reply.params.write.gatt_status = GLS_NACK_PROC_ALREADY_IN_PROGRESS;
Ble_gls.c (nrf51822\source\ble\ble_services):    switch (p_ble_evt->header.evt_id)
Ble_gls.c (nrf51822\source\ble\ble_services):    return ble_gls_db_record_add(p_rec);
Ble_gls.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_gls.h (nrf51822\include\ble\ble_services):#define BLE_GLS_FEATURE_READ_INT                       0x0080  /**< Sensor Read Interrupt Detection Supported */
Ble_gls.h (nrf51822\include\ble\ble_services):#define BLE_GLS_MEAS_STATUS_STRIP_PULL                 0x0200  /**< Sensor read interrupted because strip was pulled too soon at time of measurement */
Ble_gls_db.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_gls_db.c (nrf51822\source\ble\ble_services):uint32_t ble_gls_db_record_add(ble_gls_rec_t * p_rec)
Ble_gls_db.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_gls_db.h (nrf51822\include\ble\ble_services):/**@brief Function for adding a record at the end of the database.
Ble_gls_db.h (nrf51822\include\ble\ble_services): * @details This call adds a record as the last record in the database.
Ble_gls_db.h (nrf51822\include\ble\ble_services): * @param[in]   p_rec   Pointer to record to add to database.
Ble_gls_db.h (nrf51822\include\ble\ble_services):uint32_t ble_gls_db_record_add(ble_gls_rec_t * p_rec);
Ble_hci.h (nrf51822\include\ble\softdevice):  @addtogroup BLE_COMMON 
Ble_hci.h (nrf51822\include\ble\softdevice):0x0B ACL Connection Already Exists*/
Ble_hci.h (nrf51822\include\ble\softdevice):0x0F Connection Rejected due to Unacceptable BD_ADDR
Ble_hci.h (nrf51822\include\ble\softdevice):#define BLE_HCI_DIRECTED_ADVERTISER_TIMEOUT            0x3C
Ble_hids.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_hids.c (nrf51822\source\ble\ble_services):    switch (p_ble_evt->header.evt_id)
Ble_hids.c (nrf51822\source\ble\ble_services):/**@brief Function for adding Protocol Mode characteristics.
Ble_hids.c (nrf51822\source\ble\ble_services):static uint32_t protocol_mode_char_add(ble_hids_t                    * p_hids,
Ble_hids.c (nrf51822\source\ble\ble_services):    char_md.char_props.read          = 1;
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_sec_mode->read_perm;
Ble_hids.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_hids->service_handle,
Ble_hids.c (nrf51822\source\ble\ble_services):/**@brief Function for adding report characteristics.
Ble_hids.c (nrf51822\source\ble\ble_services):static uint32_t rep_char_add(ble_hids_t *                   p_hids,
Ble_hids.c (nrf51822\source\ble\ble_services):    // Add Report characteristic
Ble_hids.c (nrf51822\source\ble\ble_services):        BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.read_perm);
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_rep_ref_attr_md->read_perm;
Ble_hids.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_characteristic_add(p_hids->service_handle,
Ble_hids.c (nrf51822\source\ble\ble_services):    // Add Report Reference descriptor
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_rep_ref_attr_md->read_perm;
Ble_hids.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_descriptor_add(p_rep_char->char_handles.value_handle,
Ble_hids.c (nrf51822\source\ble\ble_services):/**@brief Function for adding Report Map characteristics.
Ble_hids.c (nrf51822\source\ble\ble_services):static uint32_t rep_map_char_add(ble_hids_t * p_hids, const ble_hids_init_t * p_hids_init)
Ble_hids.c (nrf51822\source\ble\ble_services):    // Add Report Map characteristic
Ble_hids.c (nrf51822\source\ble\ble_services):    char_md.char_props.read  = 1;
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_hids_init->rep_map.security_mode.read_perm;
Ble_hids.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_characteristic_add(p_hids->service_handle,
Ble_hids.c (nrf51822\source\ble\ble_services):        // Add External Report Reference descriptor
Ble_hids.c (nrf51822\source\ble\ble_services):        BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&attr_md.read_perm);
Ble_hids.c (nrf51822\source\ble\ble_services):        err_code = sd_ble_gatts_descriptor_add(p_hids->rep_map_handles.value_handle,
Ble_hids.c (nrf51822\source\ble\ble_services):/**@brief Function for adding Input Report characteristics.
Ble_hids.c (nrf51822\source\ble\ble_services): * @param[in]   uuid             UUID of report characteristic to be added.
Ble_hids.c (nrf51822\source\ble\ble_services):static uint32_t boot_inp_rep_char_add(ble_hids_t *                         p_hids,
Ble_hids.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.read_perm);
Ble_hids.c (nrf51822\source\ble\ble_services):    char_md.char_props.read   = 1;
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_sec_mode->read_perm;
Ble_hids.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_hids->service_handle,
Ble_hids.c (nrf51822\source\ble\ble_services):/**@brief Function for adding Boot Keyboard Output Report characteristics.
Ble_hids.c (nrf51822\source\ble\ble_services):static uint32_t boot_kb_outp_rep_char_add(ble_hids_t * p_hids, const ble_hids_init_t * p_hids_init)
Ble_hids.c (nrf51822\source\ble\ble_services):    char_md.char_props.read          = 1;
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_hids_init->security_mode_boot_kb_outp_rep.read_perm;
Ble_hids.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_hids->service_handle, &char_md, &attr_char_value,
Ble_hids.c (nrf51822\source\ble\ble_services):/**@brief Function for adding HID Information characteristics.
Ble_hids.c (nrf51822\source\ble\ble_services):static uint32_t hid_information_char_add(ble_hids_t * p_hids, const ble_hids_init_t * p_hids_init)
Ble_hids.c (nrf51822\source\ble\ble_services):    char_md.char_props.read  = 1;
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_hids_init->hid_information.security_mode.read_perm;
Ble_hids.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_hids->service_handle, &char_md, 
Ble_hids.c (nrf51822\source\ble\ble_services):/**@brief Function for adding HID Control Point characteristics.
Ble_hids.c (nrf51822\source\ble\ble_services):static uint32_t hid_control_point_char_add(ble_hids_t *                    p_hids,
Ble_hids.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_sec_mode->read_perm;
Ble_hids.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_hids->service_handle, &char_md, 
Ble_hids.c (nrf51822\source\ble\ble_services):/**@brief Function for adding input report characteristics.
Ble_hids.c (nrf51822\source\ble\ble_services):static uint32_t inp_rep_characteristics_add(ble_hids_t *            p_hids,
Ble_hids.c (nrf51822\source\ble\ble_services):            properties.read   = true;
Ble_hids.c (nrf51822\source\ble\ble_services):            err_code = rep_char_add(p_hids, 
Ble_hids.c (nrf51822\source\ble\ble_services):/**@brief Function for adding output report characteristics.
Ble_hids.c (nrf51822\source\ble\ble_services):static uint32_t outp_rep_characteristics_add(ble_hids_t *            p_hids,
Ble_hids.c (nrf51822\source\ble\ble_services):            properties.read          = true;
Ble_hids.c (nrf51822\source\ble\ble_services):            err_code = rep_char_add(p_hids, 
Ble_hids.c (nrf51822\source\ble\ble_services):/**@brief Function for adding feature report characteristics.
Ble_hids.c (nrf51822\source\ble\ble_services):static uint32_t feature_rep_characteristics_add(ble_hids_t *            p_hids,
Ble_hids.c (nrf51822\source\ble\ble_services):            properties.read  = true;
Ble_hids.c (nrf51822\source\ble\ble_services):            err_code = rep_char_add(p_hids, 
Ble_hids.c (nrf51822\source\ble\ble_services):/**@brief Function for adding included services.
Ble_hids.c (nrf51822\source\ble\ble_services):static uint32_t includes_add(ble_hids_t * p_hids, const ble_hids_init_t * p_hids_init)
Ble_hids.c (nrf51822\source\ble\ble_services):        err_code = sd_ble_gatts_include_add(p_hids->service_handle,
Ble_hids.c (nrf51822\source\ble\ble_services):    // Add service.
Ble_hids.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY,
Ble_hids.c (nrf51822\source\ble\ble_services):    // Add includes.
Ble_hids.c (nrf51822\source\ble\ble_services):    err_code = includes_add(p_hids, p_hids_init);
Ble_hids.c (nrf51822\source\ble\ble_services):        // Add Protocol Mode characteristic.
Ble_hids.c (nrf51822\source\ble\ble_services):        err_code = protocol_mode_char_add(p_hids, &p_hids_init->security_mode_protocol);
Ble_hids.c (nrf51822\source\ble\ble_services):    // Add Input Report characteristics (if any).
Ble_hids.c (nrf51822\source\ble\ble_services):    err_code = inp_rep_characteristics_add(p_hids, p_hids_init);
Ble_hids.c (nrf51822\source\ble\ble_services):    // Add Output Report characteristics (if any).
Ble_hids.c (nrf51822\source\ble\ble_services):    err_code = outp_rep_characteristics_add(p_hids, p_hids_init);
Ble_hids.c (nrf51822\source\ble\ble_services):    // Add Feature Report characteristic (if any).
Ble_hids.c (nrf51822\source\ble\ble_services):    err_code = feature_rep_characteristics_add(p_hids, p_hids_init);
Ble_hids.c (nrf51822\source\ble\ble_services):    // Add Report Map characteristic.
Ble_hids.c (nrf51822\source\ble\ble_services):    err_code = rep_map_char_add(p_hids, p_hids_init);
Ble_hids.c (nrf51822\source\ble\ble_services):        // Add Boot Keyboard Input Report characteristic.
Ble_hids.c (nrf51822\source\ble\ble_services):        err_code = boot_inp_rep_char_add(p_hids,
Ble_hids.c (nrf51822\source\ble\ble_services):        // Add Boot Keyboard Output Report characteristic.
Ble_hids.c (nrf51822\source\ble\ble_services):        err_code = boot_kb_outp_rep_char_add(p_hids, p_hids_init);
Ble_hids.c (nrf51822\source\ble\ble_services):        // Add Boot Mouse Input Report characteristic.
Ble_hids.c (nrf51822\source\ble\ble_services):        err_code = boot_inp_rep_char_add(p_hids,
Ble_hids.c (nrf51822\source\ble\ble_services):    // Add HID Information characteristic.
Ble_hids.c (nrf51822\source\ble\ble_services):    err_code = hid_information_char_add(p_hids, p_hids_init);
Ble_hids.c (nrf51822\source\ble\ble_services):    // Add HID Control Point characteristic.
Ble_hids.c (nrf51822\source\ble\ble_services):    err_code = hid_control_point_char_add(p_hids, &p_hids_init->security_mode_ctrl_point);
Ble_hids.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_hids.h (nrf51822\include\ble\ble_services): *          characteristics. During initialization it adds the Human Interface Device Service and 
Ble_hids.h (nrf51822\include\ble\ble_services):    ble_uuid_t *                  p_ext_rep_ref;    /**< Optional External Report Reference descriptor (will be added if != NULL). */
Ble_hids.h (nrf51822\include\ble\ble_services): * @param[in]   offset      Offset in bytes to read from.
Ble_hids.h (nrf51822\include\ble\ble_services): * @return      NRF_SUCCESS on successful read of the report, otherwise an error code.
Ble_hrs.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_hrs.c (nrf51822\source\ble\ble_services):    switch (p_ble_evt->header.evt_id)
Ble_hrs.c (nrf51822\source\ble\ble_services):    // Add flags
Ble_hrs.c (nrf51822\source\ble\ble_services):/**@brief Function for adding the Heart Rate Measurement characteristic.
Ble_hrs.c (nrf51822\source\ble\ble_services):static uint32_t heart_rate_measurement_char_add(ble_hrs_t *            p_hrs,
Ble_hrs.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.read_perm);
Ble_hrs.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_hrs_init->hrs_hrm_attr_md.read_perm;
Ble_hrs.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_hrs->service_handle,
Ble_hrs.c (nrf51822\source\ble\ble_services):/**@brief Function for adding the Body Sensor Location characteristic.
Ble_hrs.c (nrf51822\source\ble\ble_services):static uint32_t body_sensor_location_char_add(ble_hrs_t * p_hrs, const ble_hrs_init_t * p_hrs_init)
Ble_hrs.c (nrf51822\source\ble\ble_services):    char_md.char_props.read  = 1;
Ble_hrs.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_hrs_init->hrs_bsl_attr_md.read_perm;
Ble_hrs.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_hrs->service_handle,
Ble_hrs.c (nrf51822\source\ble\ble_services):    // Add service
Ble_hrs.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_hrs->service_handle);
Ble_hrs.c (nrf51822\source\ble\ble_services):    // Add heart rate measurement characteristic
Ble_hrs.c (nrf51822\source\ble\ble_services):    err_code = heart_rate_measurement_char_add(p_hrs, p_hrs_init);
Ble_hrs.c (nrf51822\source\ble\ble_services):        // Add body sensor location characteristic
Ble_hrs.c (nrf51822\source\ble\ble_services):        err_code = body_sensor_location_char_add(p_hrs, p_hrs_init);
Ble_hrs.c (nrf51822\source\ble\ble_services):void ble_hrs_rr_interval_add(ble_hrs_t * p_hrs, uint16_t rr_interval)
Ble_hrs.c (nrf51822\source\ble\ble_services):    // Add new value
Ble_hrs.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_hrs.h (nrf51822\include\ble\ble_services): *          During initialization it adds the Heart Rate Service and Heart Rate Measurement
Ble_hrs.h (nrf51822\include\ble\ble_services): *          characteristic to the BLE stack database. Optionally it also adds the
Ble_hrs.h (nrf51822\include\ble\ble_services):/**@brief Function for adding a RR Interval measurement to the RR Interval buffer.
Ble_hrs.h (nrf51822\include\ble\ble_services):void ble_hrs_rr_interval_add(ble_hrs_t * p_hrs, uint16_t rr_interval);
Ble_hrs.h (nrf51822\include\ble\ble_services): *          to the client the next time the client reads the Body Sensor Location characteristic.
Ble_hts.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_hts.c (nrf51822\source\ble\ble_services):    switch (p_ble_evt->header.evt_id)
Ble_hts.c (nrf51822\source\ble\ble_services):/**@brief Function for adding Health Thermometer Measurement characteristics.
Ble_hts.c (nrf51822\source\ble\ble_services):static uint32_t hts_measurement_char_add(ble_hts_t * p_hts, const ble_hts_init_t * p_hts_init)
Ble_hts.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.read_perm);
Ble_hts.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_hts_init->hts_meas_attr_md.read_perm;
Ble_hts.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_hts->service_handle,
Ble_hts.c (nrf51822\source\ble\ble_services):/**@brief Function for adding Temperature Type characteristics.
Ble_hts.c (nrf51822\source\ble\ble_services):static uint32_t hts_temp_type_char_add(ble_hts_t * p_hts, const ble_hts_init_t * p_hts_init)
Ble_hts.c (nrf51822\source\ble\ble_services):    char_md.char_props.read  = 1;
Ble_hts.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_hts_init->hts_temp_type_attr_md.read_perm;
Ble_hts.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_hts->service_handle,
Ble_hts.c (nrf51822\source\ble\ble_services):    // Add service
Ble_hts.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_hts->service_handle);
Ble_hts.c (nrf51822\source\ble\ble_services):    // Add measurement characteristic
Ble_hts.c (nrf51822\source\ble\ble_services):    err_code = hts_measurement_char_add(p_hts, p_hts_init);
Ble_hts.c (nrf51822\source\ble\ble_services):    // Add temperature type characteristic
Ble_hts.c (nrf51822\source\ble\ble_services):        err_code = hts_temp_type_char_add(p_hts, p_hts_init);
Ble_hts.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_ias.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_ias.c (nrf51822\source\ble\ble_services):    switch (p_ble_evt->header.evt_id)
Ble_ias.c (nrf51822\source\ble\ble_services):/**@brief Function for adding Alert Level characteristics.
Ble_ias.c (nrf51822\source\ble\ble_services):static uint32_t alert_level_char_add(ble_ias_t * p_ias)
Ble_ias.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&attr_md.read_perm);
Ble_ias.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_ias->service_handle,
Ble_ias.c (nrf51822\source\ble\ble_services):    // Add service
Ble_ias.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_ias->service_handle);
Ble_ias.c (nrf51822\source\ble\ble_services):    // Add alert level characteristic
Ble_ias.c (nrf51822\source\ble\ble_services):    return alert_level_char_add(p_ias);
Ble_ias.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_ias.h (nrf51822\include\ble\ble_services): *          During initialization it adds the Immediate Alert Service and Alert Level characteristic
Ble_ias_c.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_ias_c.c (nrf51822\source\ble\ble_services):    // The following values will be re-initialized when a new connection is made.
Ble_ias_c.c (nrf51822\source\ble\ble_services):    switch (p_ble_evt->header.evt_id)
Ble_ias_c.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_l2cap.h (nrf51822\include\ble\softdevice):  @addtogroup BLE_L2CAP Logical Link Control and Adaptation Protocol (L2CAP)
Ble_l2cap.h (nrf51822\include\ble\softdevice):/**@addtogroup BLE_L2CAP_DEFINES Defines
Ble_l2cap.h (nrf51822\include\ble\softdevice):#define BLE_ERROR_L2CAP_CID_IN_USE            (NRF_L2CAP_ERR_BASE + 0x000)  /**< CID already in use. */
Ble_l2cap.h (nrf51822\include\ble\softdevice):/**@brief Packet header format for L2CAP transmission. */
Ble_l2cap.h (nrf51822\include\ble\softdevice):} ble_l2cap_header_t;
Ble_l2cap.h (nrf51822\include\ble\softdevice):  ble_l2cap_header_t header;                      /** L2CAP packet header. */
Ble_l2cap.h (nrf51822\include\ble\softdevice): * @return @ref BLE_ERROR_L2CAP_CID_IN_USE L2CAP CID already in use.
Ble_l2cap.h (nrf51822\include\ble\softdevice): * @param[in] p_header    Pointer to a packet header containing length and CID.
Ble_l2cap.h (nrf51822\include\ble\softdevice): * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
Ble_l2cap.h (nrf51822\include\ble\softdevice):SVCALL(SD_BLE_L2CAP_TX, uint32_t, sd_ble_l2cap_tx(uint16_t conn_handle, ble_l2cap_header_t const * const p_header, uint8_t const * const p_data));
Ble_lls.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_lls.c (nrf51822\source\ble\ble_services):    switch (p_ble_evt->header.evt_id)
Ble_lls.c (nrf51822\source\ble\ble_services):/**@brief Function for adding Alert Level characteristics.
Ble_lls.c (nrf51822\source\ble\ble_services):static uint32_t alert_level_char_add(ble_lls_t * p_lls, const ble_lls_init_t * p_lls_init)
Ble_lls.c (nrf51822\source\ble\ble_services):    char_md.char_props.read  = 1;
Ble_lls.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_lls_init->lls_attr_md.read_perm;
Ble_lls.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_lls->service_handle,
Ble_lls.c (nrf51822\source\ble\ble_services):    // Add service
Ble_lls.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_lls->service_handle);
Ble_lls.c (nrf51822\source\ble\ble_services):    // Add alert level characteristic
Ble_lls.c (nrf51822\source\ble\ble_services):    return alert_level_char_add(p_lls, p_lls_init);
Ble_lls.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_lls.h (nrf51822\include\ble\ble_services): *          During initialization it adds the Link Loss Service and Alert Level characteristic
Ble_racp.c (nrf51822\source\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_racp.h (nrf51822\include\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_radio_notification.c (nrf51822\source\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_radio_notification.c (nrf51822\source\ble):#include "ble_radio_notification.h"
Ble_radio_notification.c (nrf51822\source\ble):static bool                                 m_radio_active = false;     /**< Current radio state. */
Ble_radio_notification.c (nrf51822\source\ble):static ble_radio_notification_evt_handler_t m_evt_handler  = NULL;      /**< Application event handler for handling Radio Notification events. */
Ble_radio_notification.c (nrf51822\source\ble):    m_radio_active = !m_radio_active;
Ble_radio_notification.c (nrf51822\source\ble):        m_evt_handler(m_radio_active);
Ble_radio_notification.c (nrf51822\source\ble):uint32_t ble_radio_notification_init(nrf_app_irq_priority_t               irq_priority,
Ble_radio_notification.c (nrf51822\source\ble):                                     nrf_radio_notification_distance_t    distance,
Ble_radio_notification.c (nrf51822\source\ble):                                     ble_radio_notification_evt_handler_t evt_handler)
Ble_radio_notification.c (nrf51822\source\ble):    // Initialize Radio Notification software interrupt
Ble_radio_notification.c (nrf51822\source\ble):    return sd_radio_notification_cfg_set(NRF_RADIO_NOTIFICATION_TYPE_INT_ON_BOTH, distance);
Ble_radio_notification.h (nrf51822\include\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_radio_notification.h (nrf51822\include\ble): * @defgroup ble_radio_notification Radio Notification Event Handler
Ble_radio_notification.h (nrf51822\include\ble): * @brief Module for propagating Radio Notification events to the application.
Ble_radio_notification.h (nrf51822\include\ble):#ifndef BLE_RADIO_NOTIFICATION_H__
Ble_radio_notification.h (nrf51822\include\ble):#define BLE_RADIO_NOTIFICATION_H__
Ble_radio_notification.h (nrf51822\include\ble):/**@brief Application radio notification event handler type. */
Ble_radio_notification.h (nrf51822\include\ble):typedef void (*ble_radio_notification_evt_handler_t) (bool radio_active);
Ble_radio_notification.h (nrf51822\include\ble):/**@brief Function for initializing the Radio Notification module.
Ble_radio_notification.h (nrf51822\include\ble): * @param[in]  irq_priority   Interrupt priority for the Radio Notification interrupt handler.
Ble_radio_notification.h (nrf51822\include\ble): * @param[in]  distance       The time from an Active event until the radio is activated.
Ble_radio_notification.h (nrf51822\include\ble): * @param[in]  evt_handler    Handler to be executed when a radio notification event has been
Ble_radio_notification.h (nrf51822\include\ble):uint32_t ble_radio_notification_init(nrf_app_irq_priority_t               irq_priority,
Ble_radio_notification.h (nrf51822\include\ble):                                     nrf_radio_notification_distance_t    distance,
Ble_radio_notification.h (nrf51822\include\ble):                                     ble_radio_notification_evt_handler_t evt_handler);
Ble_radio_notification.h (nrf51822\include\ble):* used to describe bluetooth state relate to flash read & write
Ble_radio_notification.h (nrf51822\include\ble):    NotWork = 0,                /* represent  not conncet and not begin to advertising */
Ble_radio_notification.h (nrf51822\include\ble):    FastAdvertising = 1,        /* Fast advertising */
Ble_radio_notification.h (nrf51822\include\ble):    SlowAdvertising = 2,        /* Slow advertising */
Ble_radio_notification.h (nrf51822\include\ble):#endif // BLE_RADIO_NOTIFICATION_H__
Ble_ranges.h (nrf51822\include\ble\softdevice):  @addtogroup BLE_COMMON
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):        // Additional data in response packet.
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):    uint32_t  rpc_cmd_length_read;
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):    err_code = hci_transport_rx_pkt_extract(&p_rpc_cmd_buffer, &rpc_cmd_length_read);
Ble_rpc_cmd_decoder.c (nrf51822\source\ble\rpc):    err_code = command_process(&p_rpc_cmd_buffer[RPC_CMD_RESP_OP_CODE_POS], rpc_cmd_length_read);
Ble_rpc_cmd_decoder.h (nrf51822\include\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_cmd_decoder.h (nrf51822\include\ble\rpc):/**@brief Function for sending a command response with additional data to the Application Chip through
Ble_rpc_cmd_decoder.h (nrf51822\include\ble\rpc): * @param[in]   data_len       The length of the additional data.
Ble_rpc_cmd_decoder.h (nrf51822\include\ble\rpc):/**@brief Function for scheduling an RPC command event to be processed in main-thread.
Ble_rpc_cmd_decoder.h (nrf51822\include\ble\rpc): * @details     The function will read the arrived packet from the transport layer
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):/**@brief Function for decoding a ble_gap_addr_t from an input buffer.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc): * @param[out]  p_addr          The pointer to the decode result structure.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in]   p_buffer        The buffer containing the encoded ble_gap_addr_t.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):static uint8_t addr_decode(ble_gap_addr_t * const p_addr, const uint8_t * const p_buffer)
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    p_addr->addr_type = p_buffer[index++];
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    memcpy(p_addr->addr, &(p_buffer[index]), BLE_GAP_ADDR_LEN);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    index += BLE_GAP_ADDR_LEN;
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    static ble_gap_addr_t * p_addresses[BLE_GAP_WHITELIST_ADDR_MAX_COUNT];
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    static ble_gap_addr_t   addresses[BLE_GAP_WHITELIST_ADDR_MAX_COUNT];
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    p_wl->addr_count = p_buffer[index++];
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    if (p_wl->addr_count > BLE_GAP_WHITELIST_ADDR_MAX_COUNT)
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):        for (i = 0; i < p_wl->addr_count; i++)
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):            index          += addr_decode(&(addresses[i]), &(p_buffer[index]));
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):            p_addresses[i]  = &(addresses[i]);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):        p_wl->pp_addrs = (p_wl->addr_count != 0) ? p_addresses : NULL;
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):/**@brief Function for decoding a command packet with RPC_SD_BLE_GAP_ADV_START opcode.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):static uint32_t gap_adv_start_handle(uint8_t * p_command, uint32_t command_len)
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    ble_gap_adv_params_t adv_params;
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    ble_gap_addr_t       directed_peer_address;
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    adv_params.type = p_command[index++];
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GAP_ADV_START);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):        // Peer Address Present. Decode the peer address.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):        index                  += addr_decode(&directed_peer_address, &(p_command[index]));
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):        adv_params.p_peer_addr  = &(directed_peer_address);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):        RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GAP_ADV_START);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):        adv_params.p_peer_addr = NULL;
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    adv_params.fp = p_command[index++];
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GAP_ADV_START);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):            return ble_rpc_cmd_resp_send(SD_BLE_GAP_ADV_START, err_code);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):        RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GAP_ADV_START);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):        adv_params.p_whitelist = &white_list;
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):        RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GAP_ADV_START);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):        adv_params.p_whitelist = NULL;
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    adv_params.interval = uint16_decode(&p_command[index]);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GAP_ADV_START);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    adv_params.timeout  = uint16_decode(&p_command[index]);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GAP_ADV_START);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    uint32_t err_code   = sd_ble_gap_adv_start(&adv_params);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    return ble_rpc_cmd_resp_send(SD_BLE_GAP_ADV_START, err_code);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):/**@brief Function for decoding a command packet with RPC_SD_BLE_GAP_ADV_DATA_SET opcode.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):static uint32_t gap_adv_data_set_handle(const uint8_t * const p_command, uint32_t command_len)
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    RPC_DECODER_LENGTH_CHECK(command_len, (index + dlen), SD_BLE_GAP_ADV_DATA_SET);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    RPC_DECODER_LENGTH_CHECK(command_len, (index + srdlen), SD_BLE_GAP_ADV_DATA_SET);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    uint32_t err_code = sd_ble_gap_adv_data_set(p_data, dlen, p_sr_data, srdlen);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):    return ble_rpc_cmd_resp_send(SD_BLE_GAP_ADV_DATA_SET, err_code);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):        case SD_BLE_GAP_ADV_START:
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):            err_code = gap_adv_start_handle(p_command, command_len);
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):        case SD_BLE_GAP_ADV_DATA_SET:
Ble_rpc_cmd_decoder_gap.c (nrf51822\source\ble\rpc):            err_code = gap_adv_data_set_handle(p_command, command_len);
Ble_rpc_cmd_decoder_gap.h (nrf51822\include\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc): *       Chip SoftDevice is not able to refer to a memory address on the Application Chip.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    p_attr_md->read_perm.sm     = ((p_buffer[index]   >> 0) & 0xF);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    p_attr_md->read_perm.lv     = ((p_buffer[index++] >> 4) & 0xF);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):/**@brief Function for decoding a command packet with RPC_SD_BLE_GATTS_SERVICE_ADD opcode.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):static uint32_t gatts_service_add_handle(const uint8_t * const p_command, uint32_t command_len)
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GATTS_SERVICE_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GATTS_SERVICE_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GATTS_SERVICE_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GATTS_SERVICE_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    err_code = sd_ble_gatts_service_add(type, p_uuid, p_handle);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        return ble_rpc_cmd_resp_data_send(SD_BLE_GATTS_SERVICE_ADD,
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        return ble_rpc_cmd_resp_send(SD_BLE_GATTS_SERVICE_ADD, err_code);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):/**@brief Function for decoding a command packet with RPC_SD_BLE_GATTS_CHARACTERISTIC_ADD opcode.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc): * @param[in] command_len       The length of the encoded command read from transport layer.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):static uint32_t gatts_characteristic_add_handle(uint8_t * const p_command, uint32_t command_len)
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GATTS_CHARACTERISTIC_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    // Char Metadata present.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        char_md.char_props.broadcast       = ((p_command[index]   >> 0) & 1);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        char_md.char_props.read            = ((p_command[index]   >> 1) & 1);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):                                 SD_BLE_GATTS_CHARACTERISTIC_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GATTS_CHARACTERISTIC_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GATTS_CHARACTERISTIC_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        // User descriptor metadata.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):                                     SD_BLE_GATTS_CHARACTERISTIC_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):                return ble_rpc_cmd_resp_send(SD_BLE_GATTS_CHARACTERISTIC_ADD, err_code);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        // CCCD metadata.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):                                     SD_BLE_GATTS_CHARACTERISTIC_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):                return ble_rpc_cmd_resp_send(SD_BLE_GATTS_CHARACTERISTIC_ADD, err_code);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        // SCCD metadata.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):                                     SD_BLE_GATTS_CHARACTERISTIC_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):                return ble_rpc_cmd_resp_send(SD_BLE_GATTS_CHARACTERISTIC_ADD, err_code);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GATTS_CHARACTERISTIC_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GATTS_CHARACTERISTIC_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        // Attribute metadata present.
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):                                     SD_BLE_GATTS_CHARACTERISTIC_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):                return ble_rpc_cmd_resp_send(SD_BLE_GATTS_CHARACTERISTIC_ADD, err_code);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GATTS_CHARACTERISTIC_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):                                     SD_BLE_GATTS_CHARACTERISTIC_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GATTS_CHARACTERISTIC_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    RPC_DECODER_LENGTH_CHECK(command_len, index, SD_BLE_GATTS_CHARACTERISTIC_ADD);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    err_code = sd_ble_gatts_characteristic_add(service_handle,
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        return ble_rpc_cmd_resp_data_send(SD_BLE_GATTS_CHARACTERISTIC_ADD,
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):    return ble_rpc_cmd_resp_send(SD_BLE_GATTS_CHARACTERISTIC_ADD, err_code);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        case SD_BLE_GATTS_SERVICE_ADD:
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):            err_code = gatts_service_add_handle(p_command, command_len);
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):        case SD_BLE_GATTS_CHARACTERISTIC_ADD:
Ble_rpc_cmd_decoder_gatts.c (nrf51822\source\ble\rpc):            err_code = gatts_characteristic_add_handle(p_command, command_len);
Ble_rpc_cmd_decoder_gatts.h (nrf51822\include\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_cmd_encoder.c (nrf51822\source\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_cmd_encoder.h (nrf51822\include\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):/**@brief       Function for encoding the peer address into the packet array provided and returning
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc): * @param[in]   p_packet        Pointer to the memory location where the encoded peer address should
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc): *                              @ref BLE_GAP_ADDR_LEN + addr_type of data (7 bytes total).
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc): * @param[in]   p_peer_address  Pointer to the peer address that should be encoded.
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):static uint32_t peer_address_encode(uint8_t *                    p_packet,
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):                                    const ble_gap_addr_t * const p_peer_address)
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):    p_packet[index++] = p_peer_address->addr_type;
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):    for (i = 0; i < BLE_GAP_ADDR_LEN; i++)
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):        p_packet[index++] = p_peer_address->addr[i];
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc): * @param[in]   p_packet     Pointer to the memory location where the encoded peer address should
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc): *                           be stored. The memory location should hold at minimum the address and 
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc): *                           IRK counters (2 bytes), (@ref BLE_GAP_ADDR_LEN + addr_type) *
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc): *                           @ref BLE_GAP_WHITELIST_ADDR_MAX_COUNT of data (56 bytes), and
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc): * @param[in]   p_whitelist  Pointer to the peer address that should be encoded.
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):    p_packet[index++] = p_whitelist->addr_count;
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):    for (i = 0; i < p_whitelist->addr_count; i++)
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):        p_packet[index++] = p_whitelist->pp_addrs[i]->addr_type;
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):        for (j = 0; j < BLE_GAP_ADDR_LEN; j++)
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):            p_packet[index++] = p_whitelist->pp_addrs[i]->addr[j];
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):uint32_t sd_ble_gap_adv_start(ble_gap_adv_params_t const * const p_adv_params)
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):    g_cmd_buffer[index++] = SD_BLE_GAP_ADV_START;
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):    g_cmd_buffer[index++] = p_adv_params->type;
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):    if (p_adv_params->p_peer_addr == NULL)
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):        index                += peer_address_encode(&g_cmd_buffer[index],
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):                                                    p_adv_params->p_peer_addr);
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):    g_cmd_buffer[index++] = p_adv_params->fp;
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):    if (p_adv_params->p_whitelist == NULL)
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):        index                += whitelist_encode(&g_cmd_buffer[index], p_adv_params->p_whitelist);
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):    index += uint16_encode(p_adv_params->interval, &g_cmd_buffer[index]);
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):    index += uint16_encode(p_adv_params->timeout, &g_cmd_buffer[index]);
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):    err_code = ble_rpc_cmd_resp_wait(SD_BLE_GAP_ADV_START);
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):uint32_t sd_ble_gap_adv_data_set(uint8_t const * const p_data,
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):    g_cmd_buffer[index++] = SD_BLE_GAP_ADV_DATA_SET;
Ble_rpc_cmd_encoder_gap.c (nrf51822\source\ble\rpc):    err_code = ble_rpc_cmd_resp_wait(SD_BLE_GAP_ADV_DATA_SET);
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):/**@brief Function for encoding characteristics in the SD_BLE_GATTS_CHARACTERISTIC_ADD command.
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):    p_packet[index++] = (p_gatts_attr_md->read_perm.sm  | p_gatts_attr_md->read_perm.lv << 4 );
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):uint32_t sd_ble_gatts_service_add(uint8_t                  type,
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):    g_cmd_buffer[index++] = SD_BLE_GATTS_SERVICE_ADD;
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):    err_code = ble_rpc_cmd_resp_wait(SD_BLE_GATTS_SERVICE_ADD);
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):uint32_t sd_ble_gatts_characteristic_add(uint16_t                    service_handle,
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):    g_cmd_buffer[index++] = SD_BLE_GATTS_CHARACTERISTIC_ADD;
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):        g_cmd_buffer[index++] = ((p_char_md->char_props.broadcast      << 0)|
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):                                 (p_char_md->char_props.read           << 1)|
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):    err_code = ble_rpc_cmd_resp_wait(SD_BLE_GATTS_CHARACTERISTIC_ADD);
Ble_rpc_cmd_encoder_gatts.c (nrf51822\source\ble\rpc):uint32_t sd_ble_gatts_descriptor_add(uint16_t                       char_handle,
Ble_rpc_defines.h (nrf51822\include\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_event_decoder.c (nrf51822\source\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_event_decoder.c (nrf51822\source\ble\rpc):static uint8_t                m_packet_queue_read_index;          /**< Read index for oldest packet in the queue. */
Ble_rpc_event_decoder.c (nrf51822\source\ble\rpc):        return NRF_ERROR_INVALID_ADDR;
Ble_rpc_event_decoder.c (nrf51822\source\ble\rpc):        return NRF_ERROR_INVALID_ADDR;
Ble_rpc_event_decoder.c (nrf51822\source\ble\rpc):    pop_index      = m_packet_queue_read_index;
Ble_rpc_event_decoder.c (nrf51822\source\ble\rpc):        if (++m_packet_queue_read_index >= EVENT_QUEUE_SIZE)
Ble_rpc_event_decoder.c (nrf51822\source\ble\rpc):            m_packet_queue_read_index = 0;
Ble_rpc_event_decoder.c (nrf51822\source\ble\rpc):        p_ble_evt->header.evt_len = evt_length;
Ble_rpc_event_decoder.c (nrf51822\source\ble\rpc):        if (++m_packet_queue_read_index >= EVENT_QUEUE_SIZE)
Ble_rpc_event_decoder.c (nrf51822\source\ble\rpc):            m_packet_queue_read_index = 0;
Ble_rpc_event_decoder.h (nrf51822\include\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):/** @brief Function for decoding the event header id from an encoded event.
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in, out]  p_evt_hdr   The pointer to the decoded event header.
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):static uint8_t evt_header_id_decode(const uint8_t * const p_evt, ble_evt_hdr_t * const p_evt_hdr)
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):/** @brief Function for decoding a Bluetooth device address.
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in]       p_encoded_ble_addr The pointer to the encoded Bluetooth device address.
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc): * @param[in, out]  p_addr             The pointer to the decoded address.
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):static uint8_t ble_addr_decode(const uint8_t * const  p_encoded_ble_addr,
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):                               ble_gap_addr_t * const p_addr)
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    p_addr->addr_type = p_encoded_ble_addr[index++];
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    memcpy(p_addr->addr, &(p_encoded_ble_addr[index]), BLE_GAP_ADDR_LEN);
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    index += BLE_GAP_ADDR_LEN;
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    index += ble_addr_decode(p_evt_data, &(p_decoded_evt->peer_addr));
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    index += ble_addr_decode(p_evt_data, &(p_decoded_evt->peer_addr));
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    p_decoded_evt->periph_kex.address     = (p_evt_data[index] >> 3) & 0x01;
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    p_decoded_evt->central_kex.address    = (p_evt_data[index] >> 1) & 0x01;
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    p_decoded_evt->central_keys.id_info.addr_type = p_evt_data[index++];
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    for (i = 0; i < BLE_GAP_ADDR_LEN; i++)
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):        p_decoded_evt->central_keys.id_info.addr[i] = p_evt_data[index++];
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    p_decoded_evt->peer_addr.addr_type = p_evt_data[index++];
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    p_decoded_evt->peer_addr.addr[0]   = p_evt_data[index++];
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    p_decoded_evt->peer_addr.addr[1]   = p_evt_data[index++];
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    p_decoded_evt->peer_addr.addr[2]   = p_evt_data[index++];
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    p_decoded_evt->peer_addr.addr[3]   = p_evt_data[index++];
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    p_decoded_evt->peer_addr.addr[4]   = p_evt_data[index++];
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    p_decoded_evt->peer_addr.addr[5]   = p_evt_data[index++];
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    //lint -e526 -e628 -e516 -save // Symbol '__INTADDR__()' not defined
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):                                   // no argument information provided for function '__INTADDR__()'
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):                                   // Symbol '__INTADDR__()' has arg. type conflict
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    index += evt_header_id_decode(&p_packet[index], &(p_ble_evt->header));
Ble_rpc_event_decoder_gap.c (nrf51822\source\ble\rpc):    switch (p_ble_evt->header.evt_id)
Ble_rpc_event_decoder_gap.h (nrf51822\include\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc):/** @brief Function for decoding the event header id from an encoded event.
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc): * @param[out]  p_evt_hdr   The pointer to where the decoded event header will be stored.
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc):static uint8_t evt_header_id_decode(const uint8_t * const p_evt, ble_evt_hdr_t * const p_evt_hdr)
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc):    //lint -e526 -e628 -e516 -save // Symbol '__INTADDR__()' not defined
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc):                                   // no argument information provided for function '__INTADDR__()'
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc):                                   // Symbol '__INTADDR__()' has arg. type conflict
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc):            // Additional data, One byte is already counted in the structure itself.
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc):    index += evt_header_id_decode(&p_packet[index], &(p_ble_evt->header));
Ble_rpc_event_decoder_gatts.c (nrf51822\source\ble\rpc):    switch (p_ble_evt->header.evt_id)
Ble_rpc_event_decoder_gatts.h (nrf51822\include\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_event_encoder.c (nrf51822\source\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_event_encoder.c (nrf51822\source\ble\rpc):    uint16_t event_id = p_ble_evt->header.evt_id;
Ble_rpc_event_encoder.h (nrf51822\include\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):/**@brief Function for encoding a peer address.
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc): * @param[out]  p_buffer        Pointer to the buffer used for the encoded ble_gap_addr_t.
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc): * @param[in]   p_peer_address  Pointer to the structure to be encoded.
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):static uint32_t peer_address_encode(uint8_t * const              p_buffer,
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):                                    const ble_gap_addr_t * const p_peer_address)
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):    p_buffer[index++] = p_peer_address->addr_type;
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):    for (i = 0; i < BLE_GAP_ADDR_LEN; i++)
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):        p_buffer[index++] = p_peer_address->addr[i];
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):    index += peer_address_encode(&p_buffer[index],
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):                                 &(p_ble_evt->evt.gap_evt.params.connected.peer_addr));
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):    index += peer_address_encode(&p_buffer[index],
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):                                 &(p_ble_evt->evt.gap_evt.params.disconnected.peer_addr));
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):    index += peer_address_encode(&p_buffer[index], &(p_sec_info_request->peer_addr));
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):                        (p_auth_status->periph_kex.address   << 3) |
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):                        (p_auth_status->central_kex.address   << 3) |
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):    index += peer_address_encode(&p_buffer[index], &(p_auth_status->central_keys.id_info));
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):    // Encode header.
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):    index += uint16_encode(p_ble_evt->header.evt_id,  &p_buffer[index]);
Ble_rpc_event_encoder_gap.c (nrf51822\source\ble\rpc):    switch (p_ble_evt->header.evt_id)
Ble_rpc_event_encoder_gap.h (nrf51822\include\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_event_encoder_gatts.c (nrf51822\source\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_event_encoder_gatts.c (nrf51822\source\ble\rpc):    // Encode header.
Ble_rpc_event_encoder_gatts.c (nrf51822\source\ble\rpc):    index += uint16_encode(p_ble_evt->header.evt_id,  &p_buffer[index]);
Ble_rpc_event_encoder_gatts.c (nrf51822\source\ble\rpc):    switch (p_ble_evt->header.evt_id)
Ble_rpc_event_encoder_gatts.h (nrf51822\include\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_pkt_receiver.c (nrf51822\source\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_pkt_receiver.h (nrf51822\include\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_sd_stub.c (nrf51822\source\ble\rpc): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rpc_sd_stub.c (nrf51822\source\ble\rpc):uint32_t sd_radio_notification_cfg_set(nrf_radio_notification_type_t     type,
Ble_rpc_sd_stub.c (nrf51822\source\ble\rpc):                                       nrf_radio_notification_distance_t distance)
Ble_rscs.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rscs.c (nrf51822\source\ble\ble_services):#define OPCODE_LENGTH  1                                                    /**< Length of opcode inside Running Speed and Cadence Measurement packet. */
Ble_rscs.c (nrf51822\source\ble\ble_services):#define HANDLE_LENGTH  2                                                    /**< Length of handle inside Running Speed and Cadence Measurement packet. */
Ble_rscs.c (nrf51822\source\ble\ble_services):#define MAX_RSCM_LEN   (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH)  /**< Maximum size of a transmitted Running Speed and Cadence Measurement. */
Ble_rscs.c (nrf51822\source\ble\ble_services):// Running Speed and Cadence Measurement flag bits
Ble_rscs.c (nrf51822\source\ble\ble_services): * @param[in]   p_rscs      Running Speed and Cadence Service structure.
Ble_rscs.c (nrf51822\source\ble\ble_services): * @param[in]   p_rscs      Running Speed and Cadence Service structure.
Ble_rscs.c (nrf51822\source\ble\ble_services): * @param[in]   p_rscs        Running Speed and Cadence Service structure.
Ble_rscs.c (nrf51822\source\ble\ble_services): * @param[in]   p_rscs      Running Speed and Cadence Service structure.
Ble_rscs.c (nrf51822\source\ble\ble_services):    switch (p_ble_evt->header.evt_id)
Ble_rscs.c (nrf51822\source\ble\ble_services): * @param[in]   p_rscs              Running Speed and Cadence Service structure.
Ble_rscs.c (nrf51822\source\ble\ble_services):    // Instantaneous cadence field
Ble_rscs.c (nrf51822\source\ble\ble_services):    p_encoded_buffer[len++] = p_rsc_measurement->inst_cadence;
Ble_rscs.c (nrf51822\source\ble\ble_services):/**@brief Function for adding RSC Measurement characteristics.
Ble_rscs.c (nrf51822\source\ble\ble_services): * @param[in]   p_rscs        Running Speed and Cadence Service structure.
Ble_rscs.c (nrf51822\source\ble\ble_services):static uint32_t rsc_measurement_char_add(ble_rscs_t * p_rscs, const ble_rscs_init_t * p_rscs_init)
Ble_rscs.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.read_perm);
Ble_rscs.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_rscs_init->rsc_meas_attr_md.read_perm;
Ble_rscs.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_rscs->service_handle,
Ble_rscs.c (nrf51822\source\ble\ble_services):/**@brief Function for adding RSC Feature characteristics.
Ble_rscs.c (nrf51822\source\ble\ble_services): * @param[in]   p_rscs        Running Speed and Cadence Service structure.
Ble_rscs.c (nrf51822\source\ble\ble_services):static uint32_t rsc_feature_char_add(ble_rscs_t * p_rscs, const ble_rscs_init_t * p_rscs_init)
Ble_rscs.c (nrf51822\source\ble\ble_services):    char_md.char_props.read  = 1;
Ble_rscs.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_rscs_init->rsc_feature_attr_md.read_perm;
Ble_rscs.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_rscs->service_handle,
Ble_rscs.c (nrf51822\source\ble\ble_services):    // Add service
Ble_rscs.c (nrf51822\source\ble\ble_services):    BLE_UUID_BLE_ASSIGN(ble_uuid, BLE_UUID_RUNNING_SPEED_AND_CADENCE);
Ble_rscs.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_rscs->service_handle);
Ble_rscs.c (nrf51822\source\ble\ble_services):    // Add measurement characteristic
Ble_rscs.c (nrf51822\source\ble\ble_services):    err_code = rsc_measurement_char_add(p_rscs, p_rscs_init);
Ble_rscs.c (nrf51822\source\ble\ble_services):    // Add feature characteristic
Ble_rscs.c (nrf51822\source\ble\ble_services):    err_code = rsc_feature_char_add(p_rscs, p_rscs_init);
Ble_rscs.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_rscs.h (nrf51822\include\ble\ble_services): * @defgroup ble_sdk_srv_rsc Running Speed and Cadence Service
Ble_rscs.h (nrf51822\include\ble\ble_services): * @brief Running Speed and Cadence Service module.
Ble_rscs.h (nrf51822\include\ble\ble_services): * @details This module implements the Running Speed and Cadence Service. If enabled, notification
Ble_rscs.h (nrf51822\include\ble\ble_services): *          of the Running Speead and Candence Measurement is performed when the application
Ble_rscs.h (nrf51822\include\ble\ble_services): *          If an event handler is supplied by the application, the Running Speed and Cadence
Ble_rscs.h (nrf51822\include\ble\ble_services): *          Service will generate Running Speed and Cadence Service events to the application.
Ble_rscs.h (nrf51822\include\ble\ble_services): * @note The application must propagate BLE stack events to the Running Speead and Candence Service
Ble_rscs.h (nrf51822\include\ble\ble_services):/**@brief Running Speed and Cadence Service feature bits. */
Ble_rscs.h (nrf51822\include\ble\ble_services):/**@brief Running Speed and Cadence Service event type. */
Ble_rscs.h (nrf51822\include\ble\ble_services):    BLE_RSCS_EVT_NOTIFICATION_ENABLED,                                      /**< Running Speed and Cadence value notification enabled event. */
Ble_rscs.h (nrf51822\include\ble\ble_services):    BLE_RSCS_EVT_NOTIFICATION_DISABLED                                      /**< Running Speed and Cadence value notification disabled event. */
Ble_rscs.h (nrf51822\include\ble\ble_services):/**@brief Running Speed and Cadence Service event. */
Ble_rscs.h (nrf51822\include\ble\ble_services):/**@brief Running Speed and Cadence Service event handler type. */
Ble_rscs.h (nrf51822\include\ble\ble_services):/**@brief Running Speed and Cadence Service init structure. This contains all options and data
Ble_rscs.h (nrf51822\include\ble\ble_services):    ble_rscs_evt_handler_t       evt_handler;                               /**< Event handler to be called for handling events in the Running Speed and Cadence Service. */
Ble_rscs.h (nrf51822\include\ble\ble_services):    ble_srv_cccd_security_mode_t rsc_meas_attr_md;                          /**< Initial security level for running speed and cadence measurement attribute */
Ble_rscs.h (nrf51822\include\ble\ble_services):/**@brief Running Speed and Cadence Service structure. This contains various status information for
Ble_rscs.h (nrf51822\include\ble\ble_services):    ble_rscs_evt_handler_t       evt_handler;                               /**< Event handler to be called for handling events in the Running Speed and Cadence Service. */
Ble_rscs.h (nrf51822\include\ble\ble_services):    uint16_t                     service_handle;                            /**< Handle of Running Speed and Cadence Service (as provided by the BLE stack). */
Ble_rscs.h (nrf51822\include\ble\ble_services):    ble_gatts_char_handles_t     meas_handles;                              /**< Handles related to the Running Speed and Cadence Measurement characteristic. */
Ble_rscs.h (nrf51822\include\ble\ble_services):    ble_gatts_char_handles_t     feature_handles;                           /**< Handles related to the Running Speed and Cadence feature characteristic. */
Ble_rscs.h (nrf51822\include\ble\ble_services):/**@brief Running Speed and Cadence Service measurement structure. This contains a Running Speed and
Ble_rscs.h (nrf51822\include\ble\ble_services): *        Cadence measurement. */
Ble_rscs.h (nrf51822\include\ble\ble_services):    uint8_t     inst_cadence;                                               /**< Instantaneous Cadence. */
Ble_rscs.h (nrf51822\include\ble\ble_services):/**@brief Function for initializing the Running Speed and Cadence Service.
Ble_rscs.h (nrf51822\include\ble\ble_services): * @param[out]  p_rscs      Running Speed and Cadence Service structure. This structure will have to
Ble_rscs.h (nrf51822\include\ble\ble_services): * @details Handles all events from the BLE stack of interest to the Running Speed and Cadence
Ble_rscs.h (nrf51822\include\ble\ble_services): * @param[in]   p_rscs     Running Speed and Cadence Service structure.
Ble_rscs.h (nrf51822\include\ble\ble_services):/**@brief Function for sending running speed and cadence measurement if notification has been enabled.
Ble_rscs.h (nrf51822\include\ble\ble_services): * @details The application calls this function after having performed a Running Speed and Cadence
Ble_rscs.h (nrf51822\include\ble\ble_services): * @param[in]   p_rscs         Running Speed and Cadence Service structure.
Ble_rscs.h (nrf51822\include\ble\ble_services): * @param[in]   p_measurement  Pointer to new running speed and cadence measurement.
Ble_sc_ctrlpt.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_sc_ctrlpt.c (nrf51822\source\ble\ble_services):#define SC_CTRLPT_NACK_PROC_ALREADY_IN_PROGRESS   (BLE_GATT_STATUS_ATTERR_APP_BEGIN + 0)
Ble_sc_ctrlpt.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&cccd_md.read_perm);
Ble_sc_ctrlpt.c (nrf51822\source\ble\ble_services):    BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(&attr_md.read_perm);
Ble_sc_ctrlpt.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_sc_ctrlpt->service_handle,
Ble_sc_ctrlpt.c (nrf51822\source\ble\ble_services):/**@brief Handle a write event to the Speed and Cadence Control Point.
Ble_sc_ctrlpt.c (nrf51822\source\ble\ble_services):            auth_reply.params.write.gatt_status = SC_CTRLPT_NACK_PROC_ALREADY_IN_PROGRESS;
Ble_sc_ctrlpt.c (nrf51822\source\ble\ble_services):    switch (p_ble_evt->header.evt_id)
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services): * @defgroup ble_sdk_srv_sc_ctrlpt Speed and Cadence Control Point
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services): * @brief Speed and Cadence Control Point module.
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services): * @details This module implements the Speed and Cadence control point behavior. It is used
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):#define BLE_SC_CTRLPT_MAX_LEN                                      19                     /**< maximum lenght for Speed and cadence control point characteristic value. */
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):#define BLE_SC_CTRLPT_MIN_LEN                                      1                      /**< minimum length for Speed and cadence control point characteristic value. */
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):/**@brief Speed and Cadence Control Point event type. */
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):    BLE_SC_CTRLPT_EVT_UPDATE_LOCATION,                                                    /**< rcvd update location opcode (the control point handles the change of location automatically, the event just informs the application in case it needs to adjust its algorithm). */
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):/**@brief Speed and Cadence Control point event. */
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):/** Speed and Cadence Control Point operator code  (see RSC service specification)*/
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):/** Speed and Cadence Control Point response parameter  (see RSC service specification)*/
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):/** Speed and Cadence Control Point procedure status (indicates is a procedure is in progress or not and which procedure is in progress*/
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):/**@brief Speed and Cadence Control point event handler type. */
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):/**@brief Speed and Cadence Control Point init structure. This contains all options and data
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):*         needed for initialization of the Speed and Cadence Control Point module. */
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):    ble_srv_cccd_security_mode_t sc_ctrlpt_attr_md;                                       /**< Initial security level for cycling speed and cadence control point attribute */
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):/**@brief Speed and Cadence Control Point response indication structure. */
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):/**@brief Speed and Cadence Control Point structure. This contains various status information for
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services): *        the Speed and Cadence Control Point behavior. */
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):    ble_gatts_char_handles_t     sc_ctrlpt_handles;                                       /**< Handles related to the Speed and Cadence Control Point characteristic. */
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):/**@brief Function for Initializing the Speed and Cadence Control Point.
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services): * @details Function for Initializing the Speed and Cadence Control Point.
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services): * @param[in]   p_sc_ctrlpt   Speed and Cadence Control Point structure.
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services): * @param[in]   p_sc_ctrlpt      Speed and Cadence Control Point structure.
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services):/**@brief Speed and Cadence Control Point BLE stack event handler.
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services): * @details Handles all events from the BLE stack of interest to the Speed and Cadence Control Point.
Ble_sc_ctrlpt.h (nrf51822\include\ble\ble_services): * @param[in]   p_sc_ctrlpt   Speed and Cadence Control Point structure.
Ble_sensorsim.c (nrf51822\source\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_sensorsim.h (nrf51822\include\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_sensor_location.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_srv_common.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_srv_common.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_CYCLING_SPEED_AND_CADENCE                       0x1816     /**< Cycling Speed and Cadence service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_RUNNING_SPEED_AND_CADENCE                       0x1814     /**< Running Speed and Cadence service UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_UNREAD_ALERT_CHAR                               0x2A45     /**< Unread Alert characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_SUPPORTED_UNREAD_ALERT_CATEGORY_CHAR            0x2A48     /**< Supported Unread Alert Category characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_CSC_FEATURE_CHAR                                0x2A5C     /**< Cycling Speed and Cadence Feature characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_CSC_MEASUREMENT_CHAR                            0x2A5B     /**< Cycling Speed and Cadence Measurement characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_RSC_FEATURE_CHAR                                0x2A54     /**< Running Speed and Cadence Feature characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_SC_CTRLPT_CHAR                                  0x2A55     /**< Speed and Cadence Control Point UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):#define BLE_UUID_RSC_MEASUREMENT_CHAR                            0x2A53     /**< Running Speed and Cadence Measurement characteristic UUID. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):    ble_gap_conn_sec_mode_t read_perm;                  /**< Read permissions. */
Ble_srv_common.h (nrf51822\include\ble\ble_services):    ble_gap_conn_sec_mode_t read_perm;                  /**< Read permissions. */
Ble_stack_handler.c (nrf51822\source\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_stack_handler.c (nrf51822\source\ble):    // Enable BLE event interrupt (interrupt priority has already been set by the stack)
Ble_stack_handler.c (nrf51822\source\ble): * @details This function is called whenever an event is ready to be pulled.
Ble_stack_handler.h (nrf51822\include\ble): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_stack_handler.h (nrf51822\include\ble): * @details It will handle dimensioning and allocation of the memory buffer required for reading
Ble_tps.c (nrf51822\source\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_tps.c (nrf51822\source\ble\ble_services):/**@brief Function for adding TX Power Level characteristics.
Ble_tps.c (nrf51822\source\ble\ble_services):static uint32_t tx_power_level_char_add(ble_tps_t *            p_tps, 
Ble_tps.c (nrf51822\source\ble\ble_services):    char_md.char_props.read  = 1;
Ble_tps.c (nrf51822\source\ble\ble_services):    attr_md.read_perm  = p_tps_init->tps_attr_md.read_perm;
Ble_tps.c (nrf51822\source\ble\ble_services):    return sd_ble_gatts_characteristic_add(p_tps->service_handle,
Ble_tps.c (nrf51822\source\ble\ble_services):    // Add service
Ble_tps.c (nrf51822\source\ble\ble_services):    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_tps->service_handle);
Ble_tps.c (nrf51822\source\ble\ble_services):    // Add TX Power Level characteristic
Ble_tps.c (nrf51822\source\ble\ble_services):    return tx_power_level_char_add(p_tps, p_tps_init);
Ble_tps.h (nrf51822\include\ble\ble_services): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ble_tps.h (nrf51822\include\ble\ble_services): *          During initialization it adds the TX Power Service and TX Power Level characteristic
Ble_types.h (nrf51822\include\ble\softdevice):  @addtogroup BLE_COMMON
Ble_types.h (nrf51822\include\ble\softdevice):/** @addtogroup BLE_COMMON_DEFINES Defines
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_UUID_GAP_CHARACTERISTIC_RECONN_ADDR       0x2A03 /**< Reconnection Address Characteristic. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_APPEARANCE_HID_GAMEPAD                          964 /**< Gamepad (HID Subtype). */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_APPEARANCE_HID_CARD_READER                      966 /**< Card Reader (HID Subtype). */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_APPEARANCE_CYCLING_CADENCE_SENSOR              1155 /**< Cycling: Cadence Sensor. */
Ble_types.h (nrf51822\include\ble\softdevice):#define BLE_APPEARANCE_CYCLING_SPEED_CADENCE_SENSOR        1157 /**< Cycling: Speed and Cadence Sensor. */
Boards.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):static uint8_t m_transmitted_keys[CHERRY8x16_MAX_NUM_OF_PRESSED_KEYS]; //!< Array holding the keys that have already been transmitted.
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):static const uint8_t volatile * m_row_port; //!< Pointer to location where row IO can be read
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):static bool cherry8x16_keymatrix_read(uint8_t *pressed_keys, uint8_t *number_of_pressed_keys);
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):static void cherry8x16_keypacket_addkey(uint8_t key);
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):static uint8_t cherry8x16_row_read(void);
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):  if (cherry8x16_keymatrix_read(m_currently_pressed_keys, &m_num_of_currently_pressed_keys))
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16): * @brief Function for reading and returning keyboard matrix row state.
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):static uint8_t cherry8x16_row_read(void)
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16): * @brief Function for reading the keyboard matrix state and stores the pressed keys to an array.
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):static bool cherry8x16_keymatrix_read(uint8_t *pressed_keys, uint8_t *number_of_pressed_keys)
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):    row_state[column] = cherry8x16_row_read();
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):      // Loop through rows, check for active rows and add pressed keys to the array
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16): * @brief Function for remapping the keypad, F11 and F12 keys in case when Fn key is pressed.
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x62; //Keypad 0
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x63; //Keypad .
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x54; //Keypad /
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x59; //Keypad 1
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x5A; //Keypad 2
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x5B; //Keypad 3
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x57; //Keypad +
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x58; //Keypad enter
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x5C; //Keypad 4
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x5D; //Keypad 5
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x5E; //Keypad 6
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x56; //Keypad -
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x5F; //Keypad 7
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x60; //Keypad 8
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x61; //Keypad 9
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        keys[i] = 0x55; //Keypad *
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16): * @brief Function for adding a key to the key packet.
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16): * If key is found to be in the packet, it will not be added twice.
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16): * Attempts to add more keys than the buffer capacity allows will be silently ignored.
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16): * @param key Key to add
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):static void cherry8x16_keypacket_addkey(uint8_t key)
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):  // Give priority to keys that were already pressed when we transmitted them the last time.
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):        cherry8x16_keypacket_addkey(m_currently_pressed_keys[j]);
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):  // Detect if Fn is pressed, detect modifier keys, and add rest of the keys to the packet
Cherry8x16.c (nrf51822\source\ext_sensors\cherry8x16):      cherry8x16_keypacket_addkey(m_currently_pressed_keys[i]);
Cherry8x16.h (nrf51822\include\ext_sensors): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Cherry8x16.h (nrf51822\include\ext_sensors): * @param row_port Pointer to GPIO port address that is used as key matrix row input.
Cherry8x16.h (nrf51822\include\ext_sensors): * @param column_port Pointer to GPIO port address that is used as key matrix column output.
Common.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Common.h (nrf51822\include):* @brief Common header file for generic macros and definitions
Common.h (nrf51822\include): * GPIO glue macros, this can be used to define a pin number in source/header file and use that macro for pin
Compiler_abstraction.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Config.h (source\inc):#define ADV_INTERVAL_SLOW_LED_PIN_NO      BAIDU_LED_4                                     /**< Is on when we are doing slow advertising. */
Config.h (source\inc):#define APP_ADV_INTERVAL_FAST             0x0050                                            /**< Fast advertising interval (in units of 0.625 ms. This value corresponds to 50 ms.). */
Config.h (source\inc):#define APP_ADV_INTERVAL_SLOW             0x0640                                            /**< Slow advertising interval (in units of 0.625 ms. This value corrsponds to 1 seconds). */
Config.h (source\inc):#define APP_SLOW_ADV_TIMEOUT              180                                               /**< The duration of the slow advertising period (in seconds). */
Config.h (source\inc):#define APP_FAST_ADV_TIMEOUT              40                                                /**< The duration of the fast advertising period (in seconds). */
Config.h (source\inc):#define APP_FAST_ADV_WHITELIST_TIMEOUT    20                                                /**< The duration of the fast advertising with whitelist period (in seconds). */
Config.h (source\inc):#define TX_POWER_LEVEL                    (-4)                                              /**< TX Power Level value. This will be set both in the TX Power service, in the advertising data, and also used to set the radio transmit power. */
Config.h (source\inc):#define FLASH_PAGE_ERROR_LOG       (NRF_FICR->CODESIZE-21)                           /**< Address in flash where stack trace can be stored. */
Config.h (source\inc):#define DEAD_BEEF                         0xDEADBEEF                                        /**< Value used as error code on stack dump, can be used to identify stack location on stack unwind. */
Config.h (source\inc):    BLE_DISCONNECTED,                                                                             /**< No advertising running. */
Config.h (source\inc):* add codes for enalbe app schedule
Console.c (nrf51822\source\console): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Console.c (nrf51822\source\console):static const char hex_tab[] = "0123456789ABCDEF";    /*!< Table of ASCII hexadecimal digits */
Console.c (nrf51822\source\console):    *string = 0;   /* Add zero terminator */
Console.c (nrf51822\source\console):    /* Read (and discard) also rest of newline sequence if we found the start of if */
Console.c (nrf51822\source\console):    /* This is were we may discard characters we should not, se the comments in the header file. */
Console.c (nrf51822\source\console):    /* NOTE: We really should check what we read, and notify the caller if it is not really the newline sequence. */
Console.c (nrf51822\source\console):      for( m = 0; m < NEWLINE_INPUT_LEN - 1; m++)   /* We have already read the first character */
Console.c (nrf51822\source\console):      /* We have read a newline, and since echo is enabled, we should also echo back a newline. */
Console.c (nrf51822\source\console):      /* But this should be the output newline, which may differ from the input newline we read. */
Console.c (nrf51822\source\console):                                             /* made sure (above) that its value will fit. */
Console.c (nrf51822\source\console):                                              /* made sure (above) that its value will fit. */
Console.c (nrf51822\source\console):      /** @note We have encountered something that is not a hexadecimal digit.
Console.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Console.h (nrf51822\include): * Higher-level functions for writing to, and reading from, the UART.
Console.h (nrf51822\include): * Functions for writing to the UART have a "put" infix, functions for reading 
Console.h (nrf51822\include): * A note on input-to-output echo and newline: If echo is enabled and an input newline is read,
Console.h (nrf51822\include):/** \brief Function for reading a number of characters (octets) and append zero-termination.
Console.h (nrf51822\include): * \param[in] num_chars Number of characters to read.
Console.h (nrf51822\include):/** \brief Function for reading a line.
Console.h (nrf51822\include): * Read characters until end of line or until a maximum number
Console.h (nrf51822\include): * of characters have been read, whatever comes first.
Console.h (nrf51822\include): * The characters read are returned as a zero-terminated string
Console.h (nrf51822\include): * follow.  The consequence of this is that if a leading part of the newline 
Console.h (nrf51822\include): * sequence (the "leading part") is found in the input, followed by something 
Console.h (nrf51822\include): * that is not the rest of the newline sequence, both the leading part and 
Console.h (nrf51822\include): * provide a means of "putting back" already read characters.  It is 
Console.h (nrf51822\include):/** \brief Function for reading a number of characters (octets).
Console.h (nrf51822\include): * \param[in] num_chars Number of characters to read
Console.h (nrf51822\include): * hal_uart_putchar() directly instead.
Console.h (nrf51822\include):/** \brief Function for reading a single character (octet).
Console.h (nrf51822\include): * This function is a wrapper for hal_uart_getchar(), with the additional opption
Console.h (nrf51822\include): * \return Read character
Console.h (nrf51822\include): * functions to write hexadecimal representations.
Console.h (nrf51822\include): * functions to write hexadecimal representations.
Console.h (nrf51822\include): * functions to write hexadecimal representations.
Console.h (nrf51822\include):/** \brief Function for printing the hexadecimal ASCII representation of a nibble (half an octet, four bits).
Console.h (nrf51822\include): * Four bits (a nibble) equals one hexadecimal digit.
Console.h (nrf51822\include):/** \brief Function for printing the hexadecimal ASCII representation of a byte (an octet).
Console.h (nrf51822\include):/** \brief Function for printing the hexadecimal ASCII representation of a word (two octets).
Console.h (nrf51822\include):/** \brief Function for reading one hexadecimal digit.
Console.h (nrf51822\include): * Read the hexadecimal ASCII representation of a nibble (half an octet, four bits)
Console.h (nrf51822\include): * hexadecimal digit).
Console.h (nrf51822\include):/** \brief Function for reading two hexadecimal digits.
Console.h (nrf51822\include): * Read the hexadecimal ASCII representation of a byte (an octet)
Console.h (nrf51822\include): * \warning: Invalid input: Input characters that are not hexadecimal digits 
Console.h (nrf51822\include): * are treated as the hexadecimal digit zero.
Console.h (nrf51822\include):/** \brief Function for reading four hexadecimal digits.
Console.h (nrf51822\include): * Read the hexadecimal ASCII representation of a word (16 bits)
Console.h (nrf51822\include): * \warning: Invalid input: Input characters that are not hexadecimal digits 
Console.h (nrf51822\include): * are treated as the hexadecimal digit zero.
Crc16.c (nrf51822\source\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Crc16.h (nrf51822\include\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Drv2605.h (source\src):#define DRV2605_ADDR (0x5A) 
Drv2605.h (source\src):#define HAPTIC_CMDID_REG_READ   	0x0a
Drv2605.h (source\src):#define DIAG_BAD            (1 << 3)
Drv2605.h (source\src):#define MODE_READY                  1 // default
Drv2605.h (source\src):	char read_val;
Drv2605.h (source\src):	char *pReadValue;
Drv2605.h (source\src):	int ReadLen;
Ds1624.c (nrf51822\source\ext_sensors\ds1624): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ds1624.c (nrf51822\source\ext_sensors\ds1624):#define DS1634_BASE_ADDRESS 0x90 //!< 4 MSBs of the DS1624 TWI address
Ds1624.c (nrf51822\source\ext_sensors\ds1624):static uint8_t m_device_address; //!< Device address in bits [7:1]
Ds1624.c (nrf51822\source\ext_sensors\ds1624):const uint8_t command_access_memory = 0x17; //!< Reads or writes to 256-byte EEPROM memory
Ds1624.c (nrf51822\source\ext_sensors\ds1624):const uint8_t command_access_config = 0xAC; //!< Reads or writes configuration data to configuration register 
Ds1624.c (nrf51822\source\ext_sensors\ds1624):const uint8_t command_read_temp = 0xAA; //!< Reads last converted temperature value from temperature register
Ds1624.c (nrf51822\source\ext_sensors\ds1624): * @brief Function for reading the current configuration of the sensor.
Ds1624.c (nrf51822\source\ext_sensors\ds1624):static uint8_t ds1624_config_read(void)
Ds1624.c (nrf51822\source\ext_sensors\ds1624):  if (twi_master_transfer(m_device_address, (uint8_t*)&command_access_config, 1, TWI_DONT_ISSUE_STOP))
Ds1624.c (nrf51822\source\ext_sensors\ds1624):    if (twi_master_transfer(m_device_address | TWI_READ_BIT, &config, 1, TWI_ISSUE_STOP)) // Read: current configuration
Ds1624.c (nrf51822\source\ext_sensors\ds1624):      // Read succeeded, configuration stored to variable "config"
Ds1624.c (nrf51822\source\ext_sensors\ds1624):      // Read failed
Ds1624.c (nrf51822\source\ext_sensors\ds1624):bool ds1624_init(uint8_t device_address)
Ds1624.c (nrf51822\source\ext_sensors\ds1624):  m_device_address = DS1634_BASE_ADDRESS + (uint8_t)(device_address << 1);
Ds1624.c (nrf51822\source\ext_sensors\ds1624):  uint8_t config = ds1624_config_read();  
Ds1624.c (nrf51822\source\ext_sensors\ds1624):    // Configure DS1624 for 1SHOT mode if not done so already.
Ds1624.c (nrf51822\source\ext_sensors\ds1624):      transfer_succeeded &= twi_master_transfer(m_device_address, data_buffer, 2, TWI_ISSUE_STOP);
Ds1624.c (nrf51822\source\ext_sensors\ds1624):  return twi_master_transfer(m_device_address, (uint8_t*)&command_start_convert_temp, 1, TWI_ISSUE_STOP);
Ds1624.c (nrf51822\source\ext_sensors\ds1624):  uint8_t config = ds1624_config_read();
Ds1624.c (nrf51822\source\ext_sensors\ds1624):bool ds1624_temp_read(int8_t *temperature_in_celcius, int8_t *temperature_fraction)
Ds1624.c (nrf51822\source\ext_sensors\ds1624):  // Write: Begin read temperature command
Ds1624.c (nrf51822\source\ext_sensors\ds1624):  if (twi_master_transfer(m_device_address, (uint8_t*)&command_read_temp, 1, TWI_DONT_ISSUE_STOP))
Ds1624.c (nrf51822\source\ext_sensors\ds1624):    // Read: 2 temperature bytes to data_buffer
Ds1624.c (nrf51822\source\ext_sensors\ds1624):    if (twi_master_transfer(m_device_address | TWI_READ_BIT, data_buffer, 2, TWI_ISSUE_STOP)) 
Ds1624.h (nrf51822\include\ext_sensors): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Ds1624.h (nrf51822\include\ext_sensors): * @param device_address Bits [2:0] for the device address. All other bits must be zero.
Ds1624.h (nrf51822\include\ext_sensors):bool ds1624_init(uint8_t device_address);
Ds1624.h (nrf51822\include\ext_sensors): * @brief Function for reading temperature from the sensor.
Ds1624.h (nrf51822\include\ext_sensors): * @retval true Temperature was successfully read
Ds1624.h (nrf51822\include\ext_sensors): * @retval false Temperature reading failed or conversion was not yet complete
Ds1624.h (nrf51822\include\ext_sensors):bool ds1624_temp_read(int8_t *temperature_in_celcius, int8_t *temperature_fraction);
Dvk6310_board_config_pins.h (source\inc):#define DEVICE_NAME                       "DuLife"        /**< Name of device. Will be included in the advertising data. */
Dvk6310_board_config_pins.h (source\inc):#define BATTERY_VOLTAGE_ADJUSTMENT           60               /**< Adjustment for charging */
Dvk6310_board_config_pins.h (source\inc):#define ADVERTISING_LED_PIN_NO      BAIDU_LED_0
Hci_mem_pool.c (nrf51822\source\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Hci_mem_pool.c (nrf51822\source\app_common):    uint32_t           read_available_count;                        /**< Read area element count. */
Hci_mem_pool.c (nrf51822\source\app_common):    uint32_t           read_index;                                  /**< Read position index. */                                                                            
Hci_mem_pool.c (nrf51822\source\app_common):    m_rx_buffer_queue.read_available_count = 0;
Hci_mem_pool.c (nrf51822\source\app_common):    m_rx_buffer_queue.read_index           = 0;        
Hci_mem_pool.c (nrf51822\source\app_common):            ++(m_rx_buffer_queue.read_available_count);            
Hci_mem_pool.c (nrf51822\source\app_common):            // @note: Adjust the write_index making use of the fact that the buffer size is of 
Hci_mem_pool.c (nrf51822\source\app_common):        // Start at read_index minus free_available_count and then increment until read index.
Hci_mem_pool.c (nrf51822\source\app_common):        err_code      = NRF_ERROR_INVALID_ADDR;
Hci_mem_pool.c (nrf51822\source\app_common):        consume_index = (m_rx_buffer_queue.read_index - m_rx_buffer_queue.free_available_count) & 
Hci_mem_pool.c (nrf51822\source\app_common):        while (consume_index != m_rx_buffer_queue.read_index);
Hci_mem_pool.c (nrf51822\source\app_common):    // @note: Adjust the write_index making use of the fact that the buffer size is of power
Hci_mem_pool.c (nrf51822\source\app_common):    if (m_rx_buffer_queue.read_available_count != 0)
Hci_mem_pool.c (nrf51822\source\app_common):        --(m_rx_buffer_queue.read_available_count);
Hci_mem_pool.c (nrf51822\source\app_common):            m_rx_buffer_queue.p_buffer[m_rx_buffer_queue.read_index].rx_buffer;
Hci_mem_pool.c (nrf51822\source\app_common):            m_rx_buffer_queue.p_buffer[m_rx_buffer_queue.read_index].length;
Hci_mem_pool.c (nrf51822\source\app_common):        // @note: Adjust the write_index making use of the fact that the buffer size is of power
Hci_mem_pool.c (nrf51822\source\app_common):        m_rx_buffer_queue.read_index = 
Hci_mem_pool.c (nrf51822\source\app_common):            (m_rx_buffer_queue.read_index + 1u) & (RX_BUF_QUEUE_SIZE - 1u); 
Hci_mem_pool.h (nrf51822\include\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Hci_mem_pool.h (nrf51822\include\app_common): * The memory managed by the pool is allocated from static storage instead of heap. The internal 
Hci_mem_pool.h (nrf51822\include\app_common):/**@brief Function for extracting a packet, which has been filled with read data, for further 
Hci_mem_pool.h (nrf51822\include\app_common):/**@brief Function for freeing previously extracted packet, which has been filled with read data.
Hci_mem_pool.h (nrf51822\include\app_common): * @retval NRF_ERROR_INVALID_ADDR  Operation failure. Not a valid pointer. 
Hci_mem_pool_internal.h (nrf51822\include\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Hci_slip.c (nrf51822\source\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Hci_slip.c (nrf51822\source\app_common):#define APP_SLIP_ESC_END    0xDC                            /**< SLIP special code. When this code follows 0xDB, this character is interpreted as payload data 0xC0.. */
Hci_slip.c (nrf51822\source\app_common):#define APP_SLIP_ESC_ESC    0xDD                            /**< SLIP special code. When this code follows 0xDB, this character is interpreted as payload data 0xDB. */
Hci_slip.c (nrf51822\source\app_common):    SLIP_READY,                                             /**< SLIP state ON. */
Hci_slip.c (nrf51822\source\app_common):        m_current_state = SLIP_READY;
Hci_slip.c (nrf51822\source\app_common):        m_current_state = SLIP_READY;
Hci_slip.c (nrf51822\source\app_common):        return NRF_ERROR_INVALID_ADDR;
Hci_slip.c (nrf51822\source\app_common):        case SLIP_READY:
Hci_slip.h (nrf51822\include\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Hci_slip.h (nrf51822\include\app_common):    HCI_SLIP_RX_RDY,                        /**< An event indicating that an RX packet is ready to be read. */
Hci_slip.h (nrf51822\include\app_common): * @retval NRF_SUCCESS              Operation success. Packet was encoded and added to the 
Hci_slip.h (nrf51822\include\app_common): *                                  added to the transmission queue. Application shall wait for
Hci_slip.h (nrf51822\include\app_common): * @retval NRF_ERROR_INVALID_ADDR   If a NULL pointer is provided.
Hci_transport.c (nrf51822\source\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Hci_transport.c (nrf51822\source\app_common):#define PKT_HDR_SIZE                    4u                                                                 /**< Packet header size in number of bytes. */
Hci_transport.c (nrf51822\source\app_common):#define DATA_INTEGRITY_MASK             (1u << 6u)                                                         /**< Mask for data integrity bit in the packet header. */
Hci_transport.c (nrf51822\source\app_common):#define RELIABLE_PKT_MASK               (1u << 7u)                                                         /**< Mask for reliable packet bit in the packet header. */
Hci_transport.c (nrf51822\source\app_common):static bool                            m_is_slip_decode_ready;       /**< Boolean to determine has slip decode been completed or not. */
Hci_transport.c (nrf51822\source\app_common):    // - verify header checksum
Hci_transport.c (nrf51822\source\app_common):    // - verify payload length field
Hci_transport.c (nrf51822\source\app_common):/**@brief Function for calculating a packet header checksum.
Hci_transport.c (nrf51822\source\app_common): * @param[in] p_hdr Pointer to the packet header.
Hci_transport.c (nrf51822\source\app_common):static uint8_t header_checksum_calculate(const uint8_t * p_hdr)
Hci_transport.c (nrf51822\source\app_common):    // @note: no pointer validation check needed as already checked by calling function.
Hci_transport.c (nrf51822\source\app_common):    // - Payload Length set to 0
Hci_transport.c (nrf51822\source\app_common):    // - Header checksum calculated
Hci_transport.c (nrf51822\source\app_common):    ack_packet[3] = header_checksum_calculate(ack_packet); 
Hci_transport.c (nrf51822\source\app_common):    // - acknowledged by possible future application packet as acknowledgement number header field 
Hci_transport.c (nrf51822\source\app_common): * @return sequence number field of the packet header with unrelated data masked out.
Hci_transport.c (nrf51822\source\app_common):    // @note: no pointer validation check needed as allready checked by calling function.
Hci_transport.c (nrf51822\source\app_common):    // @note: no pointer validation check needed as allready checked by calling function.
Hci_transport.c (nrf51822\source\app_common):            m_is_slip_decode_ready = true;            
Hci_transport.c (nrf51822\source\app_common): * that the header checksum is correct. 
Hci_transport.c (nrf51822\source\app_common):    // @note: no pointer validation check needed as allready checked by calling function.
Hci_transport.c (nrf51822\source\app_common):    // Verify header checksum.
Hci_transport.c (nrf51822\source\app_common):    m_is_slip_decode_ready       = false;
Hci_transport.c (nrf51822\source\app_common):        // @note: conduct required interface adjustment.
Hci_transport.c (nrf51822\source\app_common):        // @note: conduct required interface adjustment.
Hci_transport.c (nrf51822\source\app_common):        // @note: no need to validate pp_memory against null as validation has allready been done 
Hci_transport.c (nrf51822\source\app_common):/**@brief Function for constructing 1st byte of the packet header of the packet to be transmitted.
Hci_transport.c (nrf51822\source\app_common): * @return 1st byte of the packet header of the packet to be transmitted
Hci_transport.c (nrf51822\source\app_common):    // Set packet header fields.
Hci_transport.c (nrf51822\source\app_common):    mp_tx_buffer[3] = header_checksum_calculate(mp_tx_buffer);
Hci_transport.c (nrf51822\source\app_common):        if (m_is_slip_decode_ready)
Hci_transport.c (nrf51822\source\app_common):            m_is_slip_decode_ready = false;
Hci_transport.h (nrf51822\include\app_common): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Hci_transport.h (nrf51822\include\app_common):    HCI_TRANSPORT_RX_RDY,               /**< An event indicating that RX packet is ready for read. */
Hci_transport.h (nrf51822\include\app_common): * @warning Must not be called for a channel which has been allready opened. 
Hci_transport.h (nrf51822\include\app_common): *       module specific headers.  
Hci_transport.h (nrf51822\include\app_common): * @retval NRF_SUCCESS              Operation success. Packet was added to the transmission queue 
Hci_transport.h (nrf51822\include\app_common): *                                  added to the transmission queue. User should wait for 
Hci_transport.h (nrf51822\include\app_common): * @retval NRF_ERROR_INVALID_ADDR   Operation failure. Not a valid pointer. 
Health-algorithm.h (source\lib-inc): *       NOTE, when you call pass sensor data in A thread ,if algorithm detected new step, this callback will be called in A thread
Main.c (source\src): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Main.c (source\src): * It demonstrates the use of fast and slow advertising intervals.
Main.c (source\src):#include "ble_advdata.h"
Main.c (source\src):#include "ble_radio_notification.h"
Main.c (source\src):    BLE_NO_ADV,                                                                             /**< No advertising running. */
Main.c (source\src):    BLE_FAST_ADV_WHITELIST,                                                                 /**< Advertising whith whitelist. */
Main.c (source\src):    BLE_FAST_ADV,                                                                           /**< Fast advertising running. */
Main.c (source\src):    BLE_SLOW_ADV,                                                                           /**< Slow advertising running. */
Main.c (source\src):} ble_advertising_mode_t;
Main.c (source\src):static ble_advertising_mode_t             m_advertising_mode;                               /**< Variable to keep track of when we are advertising. */
Main.c (source\src):static void advertising_init(uint8_t adv_flags);
Main.c (source\src):    //                The flash write will happen EVEN if the radio is active, thus interrupting
Main.c (source\src):    app_error_handler(DEAD_BEEF, line_num, p_file_name);
Main.c (source\src):/**@brief Start advertising.
Main.c (source\src):static void advertising_start(void)
Main.c (source\src):    ble_gap_adv_params_t adv_params;
Main.c (source\src):    // Initialize advertising parameters with defaults values
Main.c (source\src):    memset(&adv_params, 0, sizeof(adv_params));
Main.c (source\src):    adv_params.type        = BLE_GAP_ADV_TYPE_ADV_IND;
Main.c (source\src):    adv_params.p_peer_addr = NULL;
Main.c (source\src):    adv_params.fp          = BLE_GAP_ADV_FP_ANY;
Main.c (source\src):    adv_params.p_whitelist = NULL;
Main.c (source\src):    // Configure advertisement according to current advertising state
Main.c (source\src):    switch (m_advertising_mode) {
Main.c (source\src):        case BLE_NO_ADV:
Main.c (source\src):            m_advertising_mode = BLE_FAST_ADV;
Main.c (source\src):        case BLE_FAST_ADV_WHITELIST:
Main.c (source\src):            if ((whitelist.addr_count != 0) || (whitelist.irk_count != 0)) {
Main.c (source\src):                adv_params.fp          = BLE_GAP_ADV_FP_FILTER_CONNREQ;
Main.c (source\src):                adv_params.p_whitelist = &whitelist;
Main.c (source\src):                advertising_init(BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED);
Main.c (source\src):                m_advertising_mode = BLE_FAST_ADV;
Main.c (source\src):                m_advertising_mode = BLE_SLOW_ADV;
Main.c (source\src):            adv_params.interval = APP_ADV_INTERVAL_FAST;
Main.c (source\src):            adv_params.timeout  = APP_FAST_ADV_WHITELIST_TIMEOUT;
Main.c (source\src):            set_global_bluetooth_status(FastAdvertising);
Main.c (source\src):        case BLE_FAST_ADV:
Main.c (source\src):            advertising_init(BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE);
Main.c (source\src):            adv_params.interval = APP_ADV_INTERVAL_FAST;
Main.c (source\src):            adv_params.timeout  = APP_FAST_ADV_TIMEOUT;
Main.c (source\src):            m_advertising_mode  = BLE_SLOW_ADV;
Main.c (source\src):            set_global_bluetooth_status(FastAdvertising);
Main.c (source\src):        case BLE_SLOW_ADV:
Main.c (source\src):            advertising_init(BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE);
Main.c (source\src):            adv_params.interval = APP_ADV_INTERVAL_SLOW;
Main.c (source\src):            adv_params.timeout  = APP_SLOW_ADV_TIMEOUT;
Main.c (source\src):            m_advertising_mode  = BLE_SLOW_ADV;
Main.c (source\src):            set_global_bluetooth_status(SlowAdvertising);
Main.c (source\src):    // Start advertising
Main.c (source\src):    err_code = sd_ble_gap_adv_start(&adv_params);
Main.c (source\src):/**@brief Advertising functionality initialization.
Main.c (source\src): * @details Encodes the required advertising data and passes it to the stack.
Main.c (source\src): *          Also builds a structure to be passed to the stack when starting advertising.
Main.c (source\src): * @param[in]  adv_flags  Indicates which type of advertisement to use, see @ref BLE_GAP_DISC_MODES.
Main.c (source\src):static void advertising_init(uint8_t adv_flags)
Main.c (source\src):    ble_advdata_t advdata;
Main.c (source\src):    m_advertising_mode = BLE_FAST_ADV;
Main.c (source\src):    // Build and set advertising data
Main.c (source\src):    memset(&advdata, 0, sizeof(advdata));
Main.c (source\src):    advdata.name_type               = BLE_ADVDATA_FULL_NAME;
Main.c (source\src):    advdata.include_appearance      = true;
Main.c (source\src):    advdata.flags.size              = sizeof(adv_flags);
Main.c (source\src):    advdata.flags.p_data            = &adv_flags;
Main.c (source\src):    advdata.p_tx_power_level        = &tx_power_level;
Main.c (source\src):    advdata.uuids_complete.uuid_cnt = 0;
Main.c (source\src):    advdata.uuids_complete.p_uuids  = NULL;
Main.c (source\src):    advdata.uuids_more_available.uuid_cnt = 0;
Main.c (source\src):    advdata.uuids_solicited.uuid_cnt = 0;
Main.c (source\src):    advdata.p_slave_conn_int        = NULL;
Main.c (source\src):    * Mac address
Main.c (source\src):    uint64_t mac_address;
Main.c (source\src):    mac_address = ((((uint64_t)(NRF_FICR->DEVICEADDR[1] & 0xFFFF)) << 32) | ((uint64_t)NRF_FICR->DEVICEADDR[0]));
Main.c (source\src):    uint8_t mac_add_array[4];
Main.c (source\src):        mac_add_array[3 - i] =  (mac_address >> 8*i) & 0xff;
Main.c (source\src):    ble_advdata_manuf_data_t adv_manu;
Main.c (source\src):    adv_manu.data.p_data = mac_add_array;
Main.c (source\src):    adv_manu.data.size = 4;
Main.c (source\src):    adv_manu.company_identifier = (((NRF_FICR->DEVICEADDR[1] & 0xff ) << 8) | ((NRF_FICR->DEVICEADDR[1] & 0xFF00) >> 8)); //device info
Main.c (source\src):    advdata.p_manuf_specific_data = &adv_manu;
Main.c (source\src):    err_code = ble_advdata_set(&advdata, NULL);
Main.c (source\src):    BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(&tps_init_obj.tps_attr_md.read_perm);
Main.c (source\src):    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&bas_init_obj.battery_level_char_attr_md.read_perm);
Main.c (source\src):    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&bas_init_obj.battery_level_report_read_perm);
Main.c (source\src):    uint32_t *addr;
Main.c (source\src):    ble_flash_page_addr(FLASH_PAGE_SN_FACTORY_FLAG, &addr );
Main.c (source\src):            serial_num[i] = *(((uint8_t *) (addr)) + i);
Main.c (source\src):    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&dis_init.dis_attr_md.read_perm);
Main.c (source\src):extern  SleepHead_t  mSleepHead;
Main.c (source\src):    mSleepHead.length = 6;
Main.c (source\src):    switch (p_ble_evt->header.evt_id) {
Main.c (source\src):            m_advertising_mode = BLE_FAST_ADV;
Main.c (source\src):                // Since we are not in a connection and have not started advertising, store bonds
Main.c (source\src):            advertising_start();
Main.c (source\src):            if (p_ble_evt->evt.gap_evt.params.timeout.src == BLE_GAP_TIMEOUT_SRC_ADVERTISEMENT) {
Main.c (source\src):                if (m_advertising_mode == BLE_SLEEP) {
Main.c (source\src):                    m_advertising_mode = BLE_SLOW_ADV;
Main.c (source\src):                advertising_start();
Main.c (source\src):    if(p_ble_evt->header.evt_id == BLE_GAP_EVT_CONNECTED) {
Main.c (source\src):    } else if(p_ble_evt->header.evt_id == BLE_GAP_EVT_DISCONNECTED) {
Main.c (source\src):        set_global_bluetooth_status(NotWork); //disconnected and not start advertising
Main.c (source\src):/**@brief Initialize Radio Notification event handler.
Main.c (source\src):static void radio_notification_init(void)
Main.c (source\src):    err_code = ble_radio_notification_init(NRF_APP_PRIORITY_HIGH,
Main.c (source\src):                                           NRF_RADIO_NOTIFICATION_DISTANCE_4560US,
Main.c (source\src):                                           ble_flash_on_radio_active_evt);
Main.c (source\src):#ifndef ADC_WRONG
Main.c (source\src):    battery_adc_dev_init();
Main.c (source\src):    advertising_init(BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE);
Main.c (source\src):    radio_notification_init();
Main.c (source\src):    err_code = bond_read_user_id();
Main.c (source\src):#ifndef ADC_WRONG
Main.c (source\src):    //read time and erase page before advertising start
Main.c (source\src):            load_alarm();
Main.c (source\src):            load_user_profile();
Main.c (source\src):            load_daily_target();
Main.c (source\src):        LOG(LEVEL_INFO," no time read from flash\n");
Main.c (source\src):        //   simple_uart_putstring((const uint8_t *) "\t\t[main] no time read from flash\r\n");
Main.c (source\src):    uint32_t * log_address = 0;
Main.c (source\src):    ble_flash_page_addr(FLASH_PAGE_ERROR_LOG,&log_address);
Main.c (source\src):    if(log_address) {
Main.c (source\src):            if(*(log_address + i) != 0xFFFFFFFF) {
Main.c (source\src):            ble_flash_word_write((log_address + i),0);
Main.c (source\src):            if(*(log_address + i) != 0) {
Main.c (source\src):    advertising_start();
Main.c (source\src):    LOG(LEVEL_INFO,"advertising_start ed\n");
Main.c (source\src):    //  simple_uart_putstring((const uint8_t *)"\t\t[main]advertising_start ed\r\n");
Mpu6050.c (nrf51822\source\ext_sensors\mpu6050): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Mpu6050.c (nrf51822\source\ext_sensors\mpu6050):#define ADDRESS_WHO_AM_I (0x75U) //!< WHO_AM_I register identifies the device. Expected value is 0x68.
Mpu6050.c (nrf51822\source\ext_sensors\mpu6050):#define ADDRESS_SIGNAL_PATH_RESET (0x68U) //!< 
Mpu6050.c (nrf51822\source\ext_sensors\mpu6050):static uint8_t m_device_address; //!< Device address in bits [7:1]
Mpu6050.c (nrf51822\source\ext_sensors\mpu6050):bool mpu6050_init(uint8_t device_address)
Mpu6050.c (nrf51822\source\ext_sensors\mpu6050):  m_device_address = (uint8_t)(device_address << 1);
Mpu6050.c (nrf51822\source\ext_sensors\mpu6050):  transfer_succeeded &= mpu6050_register_write(ADDRESS_SIGNAL_PATH_RESET, reset_value);
Mpu6050.c (nrf51822\source\ext_sensors\mpu6050):  // Read and verify product ID
Mpu6050.c (nrf51822\source\ext_sensors\mpu6050):  if (mpu6050_register_read(ADDRESS_WHO_AM_I, &who_am_i, 1))
Mpu6050.c (nrf51822\source\ext_sensors\mpu6050):bool mpu6050_register_write(uint8_t register_address, uint8_t value)
Mpu6050.c (nrf51822\source\ext_sensors\mpu6050):	w2_data[0] = register_address;
Mpu6050.c (nrf51822\source\ext_sensors\mpu6050):  return twi_master_transfer(m_device_address, w2_data, 2, TWI_ISSUE_STOP);	  
Mpu6050.c (nrf51822\source\ext_sensors\mpu6050):bool mpu6050_register_read(uint8_t register_address, uint8_t *destination, uint8_t number_of_bytes)
Mpu6050.c (nrf51822\source\ext_sensors\mpu6050):  transfer_succeeded = twi_master_transfer(m_device_address, &register_address, 1, TWI_DONT_ISSUE_STOP);
Mpu6050.c (nrf51822\source\ext_sensors\mpu6050):  transfer_succeeded &= twi_master_transfer(m_device_address|TWI_READ_BIT, destination, number_of_bytes, TWI_ISSUE_STOP);
Mpu6050.h (nrf51822\include\ext_sensors): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Mpu6050.h (nrf51822\include\ext_sensors): * @param device_address Device TWI address in bits [6:0].
Mpu6050.h (nrf51822\include\ext_sensors): * @retval true MPU6050 found on the bus and ready for operation.
Mpu6050.h (nrf51822\include\ext_sensors):bool mpu6050_init(uint8_t device_address);
Mpu6050.h (nrf51822\include\ext_sensors):  @param[in]  register_address Register address to start writing to
Mpu6050.h (nrf51822\include\ext_sensors):bool mpu6050_register_write(uint8_t register_address, const uint8_t value);
Mpu6050.h (nrf51822\include\ext_sensors):  @brief Function for reading MPU6050 register contents over TWI.
Mpu6050.h (nrf51822\include\ext_sensors):  Reads one or more consecutive registers.
Mpu6050.h (nrf51822\include\ext_sensors):  @param[in]  register_address Register address to start reading from
Mpu6050.h (nrf51822\include\ext_sensors):  @param[in]  number_of_bytes Number of bytes to read
Mpu6050.h (nrf51822\include\ext_sensors):  @param[out] destination Pointer to a data buffer where read data will be stored
Mpu6050.h (nrf51822\include\ext_sensors):  @retval true Register read succeeded
Mpu6050.h (nrf51822\include\ext_sensors):  @retval false Register read failed
Mpu6050.h (nrf51822\include\ext_sensors):bool mpu6050_register_read(uint8_t register_address, uint8_t *destination, uint8_t number_of_bytes);
Mpu6050.h (nrf51822\include\ext_sensors):  @brief Function for reading and verifying MPU6050 product ID.
Nordic_common.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf51.h (nrf51822\include): * @brief    CMSIS Cortex-M0 Peripheral Access Layer Header File for
Nrf51.h (nrf51822\include): *           WARRANTY of ANY KIND is provided. This heading must NOT be removed from 
Nrf51.h (nrf51822\include):/** @addtogroup Nordic Semiconductor
Nrf51.h (nrf51822\include):/** @addtogroup nRF51
Nrf51.h (nrf51822\include):  RADIO_IRQn                    =   1,              /*!<   1  RADIO                                                            */
Nrf51.h (nrf51822\include):  ADC_IRQn                      =   7,              /*!<   7  ADC                                                              */
Nrf51.h (nrf51822\include):/** @addtogroup Configuration_of_CMSIS
Nrf51.h (nrf51822\include):/** @addtogroup Device_Peripheral_Registers
Nrf51.h (nrf51822\include):  __IO uint32_t  RADIO;                             /*!< Configurable priority configuration register for RADIO.               */
Nrf51.h (nrf51822\include):  __IO uint32_t  PROTENSET0;                        /*!< Protection bit enable set register for low addresses.                 */
Nrf51.h (nrf51822\include):  __IO uint32_t  PROTENSET1;                        /*!< Protection bit enable set register for high addresses.                */
Nrf51.h (nrf51822\include):  __IO uint32_t  REPLACEADDR[8];                    /*!< Address of first instruction to replace.                              */
Nrf51.h (nrf51822\include):  __IO uint32_t  PATCHADDR[8];                      /*!< Relative address of patch instructions.                               */
Nrf51.h (nrf51822\include):/* ================                      RADIO                     ================ */
Nrf51.h (nrf51822\include):  * @brief The radio. (RADIO)
Nrf51.h (nrf51822\include):typedef struct {                                    /*!< RADIO Structure                                                       */
Nrf51.h (nrf51822\include):  __O  uint32_t  TASKS_TXEN;                        /*!< Enable radio in TX mode.                                              */
Nrf51.h (nrf51822\include):  __O  uint32_t  TASKS_RXEN;                        /*!< Enable radio in RX mode.                                              */
Nrf51.h (nrf51822\include):  __O  uint32_t  TASKS_START;                       /*!< Start radio.                                                          */
Nrf51.h (nrf51822\include):  __O  uint32_t  TASKS_STOP;                        /*!< Stop radio.                                                           */
Nrf51.h (nrf51822\include):  __O  uint32_t  TASKS_DISABLE;                     /*!< Disable radio.                                                        */
Nrf51.h (nrf51822\include):  __IO uint32_t  EVENTS_READY;                      /*!< Ready event.                                                          */
Nrf51.h (nrf51822\include):  __IO uint32_t  EVENTS_ADDRESS;                    /*!< Address event.                                                        */
Nrf51.h (nrf51822\include):  __IO uint32_t  EVENTS_PAYLOAD;                    /*!< Payload event.                                                        */
Nrf51.h (nrf51822\include):  __IO uint32_t  EVENTS_DEVMATCH;                   /*!< A device address match occurred on the last received packet.          */
Nrf51.h (nrf51822\include):  __IO uint32_t  EVENTS_DEVMISS;                    /*!< No device address match occurred on the last received packet.         */
Nrf51.h (nrf51822\include):                                                         sample is ready for readout at the RSSISAMPLE register.               */
Nrf51.h (nrf51822\include):  __IO uint32_t  SHORTS;                            /*!< Shortcut for the radio.                                               */
Nrf51.h (nrf51822\include):  __I  uint32_t  RXMATCH;                           /*!< Received address.                                                     */
Nrf51.h (nrf51822\include):  __IO uint32_t  DAI;                               /*!< Device address match index.                                           */
Nrf51.h (nrf51822\include):  __IO uint32_t  BASE0;                             /*!< Radio base address 0. Decision point: START task.                     */
Nrf51.h (nrf51822\include):  __IO uint32_t  BASE1;                             /*!< Radio base address 1. Decision point: START task.                     */
Nrf51.h (nrf51822\include):  __IO uint32_t  PREFIX0;                           /*!< Prefixes bytes for logical addresses 0 to 3.                          */
Nrf51.h (nrf51822\include):  __IO uint32_t  PREFIX1;                           /*!< Prefixes bytes for logical addresses 4 to 7.                          */
Nrf51.h (nrf51822\include):  __IO uint32_t  TXADDRESS;                         /*!< Transmit address select.                                              */
Nrf51.h (nrf51822\include):  __IO uint32_t  RXADDRESSES;                       /*!< Receive address select.                                               */
Nrf51.h (nrf51822\include):  __I  uint32_t  STATE;                             /*!< Current radio state.                                                  */
Nrf51.h (nrf51822\include):  __IO uint32_t  DAB[8];                            /*!< Device address base segment.                                          */
Nrf51.h (nrf51822\include):  __IO uint32_t  DAP[8];                            /*!< Device address prefix.                                                */
Nrf51.h (nrf51822\include):  __IO uint32_t  DACNF;                             /*!< Device address match configuration.                                   */
Nrf51.h (nrf51822\include):} NRF_RADIO_Type;
Nrf51.h (nrf51822\include):  __I  uint32_t  RXD;                               /*!< RXD register. On read action the buffer pointer is displaced.
Nrf51.h (nrf51822\include):                                                         Once read the character is consummed. If read when no character
Nrf51.h (nrf51822\include):  __IO uint32_t  EVENTS_READY;                      /*!< TXD byte sent and RXD byte received.                                  */
Nrf51.h (nrf51822\include):  __IO uint32_t  EVENTS_RXDREADY;                   /*!< Two-wire ready to deliver new RXD byte received.                      */
Nrf51.h (nrf51822\include):  __IO uint32_t  ADDRESS;                           /*!< Address used in the two-wire transfer.                                */
Nrf51.h (nrf51822\include):  __IO uint32_t  ORC;                               /*!< Over-read character.                                                  */
Nrf51.h (nrf51822\include):/* ================                       ADC                      ================ */
Nrf51.h (nrf51822\include):  * @brief Analog to digital converter. (ADC)
Nrf51.h (nrf51822\include):typedef struct {                                    /*!< ADC Structure                                                         */
Nrf51.h (nrf51822\include):  __O  uint32_t  TASKS_START;                       /*!< Start an ADC conversion.                                              */
Nrf51.h (nrf51822\include):  __O  uint32_t  TASKS_STOP;                        /*!< Stop ADC.                                                             */
Nrf51.h (nrf51822\include):  __IO uint32_t  EVENTS_END;                        /*!< ADC conversion complete.                                              */
Nrf51.h (nrf51822\include):  __I  uint32_t  BUSY;                              /*!< ADC busy register.                                                    */
Nrf51.h (nrf51822\include):  __IO uint32_t  ENABLE;                            /*!< ADC enable.                                                           */
Nrf51.h (nrf51822\include):  __IO uint32_t  CONFIG;                            /*!< ADC configuration register.                                           */
Nrf51.h (nrf51822\include):  __I  uint32_t  RESULT;                            /*!< Result of ADC conversion.                                             */
Nrf51.h (nrf51822\include):} NRF_ADC_Type;
Nrf51.h (nrf51822\include):  __IO uint32_t  EVTENSET;                          /*!< Enable events routing to PPI. The reading of this register gives
Nrf51.h (nrf51822\include):  __IO uint32_t  EVTENCLR;                          /*!< Disable events routing to PPI. The reading of this register
Nrf51.h (nrf51822\include):  __IO uint32_t  EVENTS_DATARDY;                    /*!< Temperature measurement complete, data ready event.                   */
Nrf51.h (nrf51822\include):  * @brief Accelerated Address Resolver. (AAR)
Nrf51.h (nrf51822\include):  __O  uint32_t  TASKS_START;                       /*!< Start resolving addresses based on IRKs specified in the IRK
Nrf51.h (nrf51822\include):  __O  uint32_t  TASKS_STOP;                        /*!< Stop resolving addresses.                                             */
Nrf51.h (nrf51822\include):  __IO uint32_t  EVENTS_END;                        /*!< Address resolution procedure completed.                               */
Nrf51.h (nrf51822\include):  __IO uint32_t  EVENTS_RESOLVED;                   /*!< Address resolved.                                                     */
Nrf51.h (nrf51822\include):  __IO uint32_t  EVENTS_NOTRESOLVED;                /*!< Address not resolved.                                                 */
Nrf51.h (nrf51822\include):  __IO uint32_t  ADDRPTR;                           /*!< Pointer to the resolvable address (6 bytes).                          */
Nrf51.h (nrf51822\include):  __IO uint32_t  CRV;                               /*!< Counter reload value in number of 32kiHz clock cycles.                */
Nrf51.h (nrf51822\include):  __IO uint32_t  RREN;                              /*!< Reload request enable.                                                */
Nrf51.h (nrf51822\include):  __O  uint32_t  RR[8];                             /*!< Reload requests registers.                                            */
Nrf51.h (nrf51822\include):  __O  uint32_t  TASKS_START;                       /*!< Start the quadrature decoder.                                         */
Nrf51.h (nrf51822\include):  __O  uint32_t  TASKS_STOP;                        /*!< Stop the quadrature decoder.                                          */
Nrf51.h (nrf51822\include):  __O  uint32_t  TASKS_READCLRACC;                  /*!< Transfers the content from ACC registers to ACCREAD registers,
Nrf51.h (nrf51822\include):  __I  int32_t   ACCREAD;                           /*!< Snapshot of ACC register. Value generated by the TASKS_READCLEACC
Nrf51.h (nrf51822\include):  __I  uint32_t  ACCDBLREAD;                        /*!< Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC
Nrf51.h (nrf51822\include):  __IO uint32_t  EVENTS_READY;                      /*!< LPCOMP is ready and output is valid.                                  */
Nrf51.h (nrf51822\include):  __IO uint32_t  ANADETECT;                         /*!< Analog detect configuration.                                          */
Nrf51.h (nrf51822\include):  __IO uint32_t  EVENTS_READY;                      /*!< COMP is ready and output is valid.                                    */
Nrf51.h (nrf51822\include):  __I  uint32_t  READY;                             /*!< Ready flag.                                                           */
Nrf51.h (nrf51822\include):  __I  uint32_t  DEVICEADDRTYPE;                    /*!< Device address type.                                                  */
Nrf51.h (nrf51822\include):  __I  uint32_t  DEVICEADDR[2];                     /*!< Device address.                                                       */
Nrf51.h (nrf51822\include):  __I  uint32_t  OVERRIDEEN;                        /*!< Radio calibration override enable.                                    */
Nrf51.h (nrf51822\include):  __I  uint32_t  BLE_1MBIT[5];                      /*!< Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit
Nrf51.h (nrf51822\include):  __IO uint32_t  RBPCONF;                           /*!< Readback protection configuration.                                    */
Nrf51.h (nrf51822\include):  __IO uint32_t  BOOTLOADERADDR;                    /*!< Bootloader start address.                                             */
Nrf51.h (nrf51822\include):  __I  uint32_t  IN;                                /*!< Read GPIO port.                                                       */
Nrf51.h (nrf51822\include):#define NRF_RADIO_BASE                  0x40001000UL
Nrf51.h (nrf51822\include):#define NRF_ADC_BASE                    0x40007000UL
Nrf51.h (nrf51822\include):#define NRF_RADIO                       ((NRF_RADIO_Type          *) NRF_RADIO_BASE)
Nrf51.h (nrf51822\include):#define NRF_ADC                         ((NRF_ADC_Type            *) NRF_ADC_BASE)
Nrf51.xml (nrf51822\svd):  <description>nRF51 reference description for radio MCU with ARM 32-bit Cortex-M0 Microcontroller at 16MHz CPU clock</description>
Nrf51.xml (nrf51822\svd):    WARRANTY of ANY KIND is provided. This heading must NOT be removed from \n
Nrf51.xml (nrf51822\svd):  <addressUnitBits>8</addressUnitBits>                            <!-- byte addressable memory -->
Nrf51.xml (nrf51822\svd):    <endian>little</endian>                                      <!-- little, big, configurable (headerfile: little, big, configurable (#ifdef compilerflag)   -->
Nrf51.xml (nrf51822\svd):  <headerSystemFilename>system_nrf51</headerSystemFilename>      <!-- System Header File overwrite -->
Nrf51.xml (nrf51822\svd):  <headerDefinitionsPrefix>NRF_</headerDefinitionsPrefix>        <!-- Prefix for all structs and #defines -->
Nrf51.xml (nrf51822\svd):    <FlashBaseAddress>0x00000000</FlashBaseAddress>                       <!-- Flash memory start/base address. [32 bit hexadecimal] -->
Nrf51.xml (nrf51822\svd):    <RamBaseAddress>0x20000000</RamBaseAddress>                           <!-- RAM start/base address. [32 bit hexadecimal] -->
Nrf51.xml (nrf51822\svd):    <InterruptVectorStartAddress>0x00000000</InterruptVectorStartAddress> <!-- Location of interrupt vectors. [32 bit hexadecimal] -->
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40000000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x078</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x07C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x108</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x400</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Reset from wake-up from OFF mode detected by the use of ANADETECT signal from LPCOMP.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x500</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x510</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x51C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x524</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x544</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x578</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40000000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x008</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x00C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x010</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x014</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x018</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x100</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x104</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x10C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x110</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x40C</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x418</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x518</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x538</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x550</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40000000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x528</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>RADIO</name>
Nrf51.xml (nrf51822\svd):              <description>RADIO region configuration.</description>
Nrf51.xml (nrf51822\svd):              <name>ADC</name>
Nrf51.xml (nrf51822\svd):              <description>ADC region configuration.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x52C</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Protection bit enable set register for low addresses.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x600</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <description>Protection bit enable set register for high addresses.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x604</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x608</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40000000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <name>REPLACEADDR[%s]</name>
Nrf51.xml (nrf51822\svd):          <description>Address of first instruction to replace.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x700</addressOffset>
Nrf51.xml (nrf51822\svd):          <name>PATCHADDR[%s]</name>
Nrf51.xml (nrf51822\svd):          <description>Relative address of patch instructions.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x780</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>PATCHADDR</name>
Nrf51.xml (nrf51822\svd):              <description>Relative address of patch instructions.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x800</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x804</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x808</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40000000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <headerStructName>AMLI_RAMPRI</headerStructName>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xE00</addressOffset>
Nrf51.xml (nrf51822\svd):            <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):            <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):            <name>RADIO</name>
Nrf51.xml (nrf51822\svd):            <description>Configurable priority configuration register for RADIO.</description>
Nrf51.xml (nrf51822\svd):            <addressOffset>0x008</addressOffset>
Nrf51.xml (nrf51822\svd):            <addressOffset>0x00C</addressOffset>
Nrf51.xml (nrf51822\svd):            <addressOffset>0x010</addressOffset>
Nrf51.xml (nrf51822\svd):            <addressOffset>0x014</addressOffset>
Nrf51.xml (nrf51822\svd):      <name>RADIO</name>
Nrf51.xml (nrf51822\svd):      <description>The radio.</description>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40001000</baseAddress>
Nrf51.xml (nrf51822\svd):      <groupName>RADIO</groupName>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):        <name>RADIO</name>
Nrf51.xml (nrf51822\svd):          <description>Enable radio in TX mode.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Enable radio in RX mode.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Start radio.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x008</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Stop radio.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x00C</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Disable radio.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x010</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x014</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x018</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x01C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x020</addressOffset>
Nrf51.xml (nrf51822\svd):          <name>EVENTS_READY</name>
Nrf51.xml (nrf51822\svd):          <description>Ready event.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x100</addressOffset>
Nrf51.xml (nrf51822\svd):          <name>EVENTS_ADDRESS</name>
Nrf51.xml (nrf51822\svd):          <description>Address event.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x104</addressOffset>
Nrf51.xml (nrf51822\svd):          <name>EVENTS_PAYLOAD</name>
Nrf51.xml (nrf51822\svd):          <description>Payload event.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x108</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x10C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x110</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>A device address match occurred on the last received packet.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x114</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>No device address match occurred on the last received packet.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x118</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Sampling of the receive signal strength complete. A new RSSI sample is ready for readout at the RSSISAMPLE register.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x11C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x128</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Shortcut for the radio.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x200</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>READY_START</name>
Nrf51.xml (nrf51822\svd):              <description>Shortcut between READY event and START task.</description>
Nrf51.xml (nrf51822\svd):              <name>ADDRESS_RSSISTART</name>
Nrf51.xml (nrf51822\svd):              <description>Shortcut between ADDRESS event and RSSISTART task.</description>
Nrf51.xml (nrf51822\svd):              <name>ADDRESS_BCSTART</name>
Nrf51.xml (nrf51822\svd):              <description>Shortcut between ADDRESS event and BCSTART task.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>READY</name>
Nrf51.xml (nrf51822\svd):              <description>Enable interrupt on READY event.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):              <name>ADDRESS</name>
Nrf51.xml (nrf51822\svd):              <description>Enable interrupt on ADDRESS event.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):              <name>PAYLOAD</name>
Nrf51.xml (nrf51822\svd):              <description>Enable interrupt on PAYLOAD event.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>READY</name>
Nrf51.xml (nrf51822\svd):              <description>Disable interrupt on READY event.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):              <name>ADDRESS</name>
Nrf51.xml (nrf51822\svd):              <description>Disable interrupt on ADDRESS event.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):              <name>PAYLOAD</name>
Nrf51.xml (nrf51822\svd):              <description>Disable interrupt on PAYLOAD event.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x400</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <description>Received address.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x408</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):              <description>Logical address in which previous packet was received.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x40C</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <description>Device address match index.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x410</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Index (n) of device address (see DAB[n] and DAP[n]) that got an address match.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x504</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Radio channel frequency offset in MHz: RF Frequency = 2400 + FREQUENCY (MHz). Decision point: TXEN or RXEN task. </description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x50C</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Radio output power. Decision point: TXEN task.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x510</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Radio data rate and modulation setting. Decision point: TXEN or RXEN task.</description>
Nrf51.xml (nrf51822\svd):                  <description>1Mbit/s Nordic propietary radio mode.</description>
Nrf51.xml (nrf51822\svd):                  <description>2Mbit/s Nordic propietary radio mode.</description>
Nrf51.xml (nrf51822\svd):                  <description>250kbit/s Nordic propietary radio mode.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x514</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x518</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Maximum length of packet payload in number of bytes.</description>
Nrf51.xml (nrf51822\svd):              <description>Base address length in number of bytes. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):          <description>Radio base address 0. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x51C</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Radio base address 1. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x520</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Prefixes bytes for logical addresses 0 to 3.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x524</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Address prefix 0. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):              <description>Address prefix 1. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):              <description>Address prefix 2. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):              <description>Address prefix 3. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):          <description>Prefixes bytes for logical addresses 4 to 7.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x528</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Address prefix 4. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):              <description>Address prefix 5. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):              <description>Address prefix 6. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):              <description>Address prefix 7. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):          <name>TXADDRESS</name>
Nrf51.xml (nrf51822\svd):          <description>Transmit address select.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x52C</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>TXADDRESS</name>
Nrf51.xml (nrf51822\svd):              <description>Logical address to be used when transmitting a packet. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):          <name>RXADDRESSES</name>
Nrf51.xml (nrf51822\svd):          <description>Receive address select.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x530</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>ADDR0</name>
Nrf51.xml (nrf51822\svd):              <description>Enable reception on logical address 0. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):              <name>ADDR1</name>
Nrf51.xml (nrf51822\svd):              <description>Enable reception on logical address 1. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):              <name>ADDR2</name>
Nrf51.xml (nrf51822\svd):              <description>Enable reception on logical address 2. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):              <name>ADDR3</name>
Nrf51.xml (nrf51822\svd):              <description>Enable reception on logical address 3. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):              <name>ADDR4</name>
Nrf51.xml (nrf51822\svd):              <description>Enable reception on logical address 4. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):              <name>ADDR5</name>
Nrf51.xml (nrf51822\svd):              <description>Enable reception on logical address 5. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):              <name>ADDR6</name>
Nrf51.xml (nrf51822\svd):              <description>Enable reception on logical address 6. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):              <name>ADDR7</name>
Nrf51.xml (nrf51822\svd):              <description>Enable reception on logical address 7. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x534</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>SKIP_ADDR</name>
Nrf51.xml (nrf51822\svd):              <description>Leave packet address field out of the CRC calculation. Decision point: START task.</description>
Nrf51.xml (nrf51822\svd):                  <description>Include packet address in CRC calculation.</description>
Nrf51.xml (nrf51822\svd):                  <description>Packet address is skipped in CRC calculation. The CRC calculation will start at the first byte after the address.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x538</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x53C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x540</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x544</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x548</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>RSSI sample result. The result is read as a positive value so that ReceivedSignalStrength = -RSSISAMPLE dBm</description>
Nrf51.xml (nrf51822\svd):          <description>Current radio state.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x550</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):              <description>Current radio state.</description>
Nrf51.xml (nrf51822\svd):                  <description>Radio is in the Disabled state.</description>
Nrf51.xml (nrf51822\svd):                  <description>Radio is in the Rx Ramp Up state.</description>
Nrf51.xml (nrf51822\svd):                  <description>Radio is in the Rx Idle state.</description>
Nrf51.xml (nrf51822\svd):                  <description>Radio is in the Rx state.</description>
Nrf51.xml (nrf51822\svd):                  <description>Radio is in the Rx Disable state.</description>
Nrf51.xml (nrf51822\svd):                  <description>Radio is in the Tx Ramp Up state.</description>
Nrf51.xml (nrf51822\svd):                  <description>Radio is in the Tx Idle state.</description>
Nrf51.xml (nrf51822\svd):                  <description>Radio is in the Tx state.</description>
Nrf51.xml (nrf51822\svd):                  <description>Radio is in the Tx Disable state.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x554</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Device address base segment.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x600</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Device address prefix.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x620</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Device address prefix.</description>
Nrf51.xml (nrf51822\svd):          <description>Device address match configuration.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x640</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Enable or disable device address matching using device address 0.</description>
Nrf51.xml (nrf51822\svd):              <description>Enable or disable device address matching using device address 1.</description>
Nrf51.xml (nrf51822\svd):              <description>Enable or disable device address matching using device address 2.</description>
Nrf51.xml (nrf51822\svd):              <description>Enable or disable device address matching using device address 3.</description>
Nrf51.xml (nrf51822\svd):              <description>Enable or disable device address matching using device address 4.</description>
Nrf51.xml (nrf51822\svd):              <description>Enable or disable device address matching using device address 5.</description>
Nrf51.xml (nrf51822\svd):              <description>Enable or disable device address matching using device address 6.</description>
Nrf51.xml (nrf51822\svd):              <description>Enable or disable device address matching using device address 7.</description>
Nrf51.xml (nrf51822\svd):              <name>TXADD0</name>
Nrf51.xml (nrf51822\svd):              <description>TxAdd for device address 0.</description>
Nrf51.xml (nrf51822\svd):              <name>TXADD1</name>
Nrf51.xml (nrf51822\svd):              <description>TxAdd for device address 1.</description>
Nrf51.xml (nrf51822\svd):              <name>TXADD2</name>
Nrf51.xml (nrf51822\svd):              <description>TxAdd for device address 2.</description>
Nrf51.xml (nrf51822\svd):              <name>TXADD3</name>
Nrf51.xml (nrf51822\svd):              <description>TxAdd for device address 3.</description>
Nrf51.xml (nrf51822\svd):              <name>TXADD4</name>
Nrf51.xml (nrf51822\svd):              <description>TxAdd for device address 4.</description>
Nrf51.xml (nrf51822\svd):              <name>TXADD5</name>
Nrf51.xml (nrf51822\svd):              <description>TxAdd for device address 5.</description>
Nrf51.xml (nrf51822\svd):              <name>TXADD6</name>
Nrf51.xml (nrf51822\svd):              <description>TxAdd for device address 6.</description>
Nrf51.xml (nrf51822\svd):              <name>TXADD7</name>
Nrf51.xml (nrf51822\svd):              <description>TxAdd for device address 7.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x560</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x724</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x728</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x72C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x730</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x734</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40002000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <headerStructName>UART</headerStructName>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x008</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x00C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x01C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x100</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x104</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x108</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x11C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x124</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x144</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x200</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x480</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):              <description>A character with bad parity is received. Only checked if HW parity control is enabled.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x500</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x50C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x510</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x514</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>RXD register. On read action the buffer pointer is displaced. Once read the character is consummed. If read when no character available, the UART will stop working.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x518</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <readAction>modifyExternal</readAction>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x51C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x524</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x56C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40003000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <headerStructName>SPI</headerStructName>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <name>EVENTS_READY</name>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x108</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>READY</name>
Nrf51.xml (nrf51822\svd):              <description>Enable interrupt on READY event.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>READY</name>
Nrf51.xml (nrf51822\svd):              <description>Disable interrupt on READY event.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x500</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x50C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x510</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x518</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x51C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x524</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x554</addressOffset>
Nrf51.xml (nrf51822\svd):                  <name>Leading</name>
Nrf51.xml (nrf51822\svd):                  <description>Sample on leading edge of the clock. Shift serial data on trailing edge.</description>
Nrf51.xml (nrf51822\svd):                  <description>Sample on trailing edge of the clock. Shift serial data on leading edge.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40003000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <headerStructName>TWI</headerStructName>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x008</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x014</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x01C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x020</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x104</addressOffset>
Nrf51.xml (nrf51822\svd):          <name>EVENTS_RXDREADY</name>
Nrf51.xml (nrf51822\svd):          <description>Two-wire ready to deliver new RXD byte received.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x108</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x11C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x124</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x138</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x200</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):              <name>RXDREADY</name>
Nrf51.xml (nrf51822\svd):              <description>Enable interrupt on READY event.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):              <name>RXDREADY</name>
Nrf51.xml (nrf51822\svd):              <description>Disable interrupt on RXDREADY event.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x4C4</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>NACK received after sending the address.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x500</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x50C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x518</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x51C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x524</addressOffset>
Nrf51.xml (nrf51822\svd):          <name>ADDRESS</name>
Nrf51.xml (nrf51822\svd):          <description>Address used in the two-wire transfer.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x588</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>ADDRESS</name>
Nrf51.xml (nrf51822\svd):              <description>Two-wire address.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40004000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40004000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40004000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <headerStructName>SPIS</headerStructName>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x024</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x028</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x104</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x128</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x200</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x400</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x440</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>OVERREAD</name>
Nrf51.xml (nrf51822\svd):              <description>TX buffer overread detected, and prevented.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x500</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x50C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x510</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x514</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x534</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x538</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x53C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x544</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x548</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x54C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x554</addressOffset>
Nrf51.xml (nrf51822\svd):                  <name>Leading</name>
Nrf51.xml (nrf51822\svd):                  <description>Sample on leading edge of the clock. Shift serial data on trailing edge.</description>
Nrf51.xml (nrf51822\svd):                  <description>Sample on trailing edge of the clock. Shift serial data on leading edge.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x55C</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Over-read character.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x5C0</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Over-read character.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40006000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x100</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x17C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x510</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <name>ADC</name>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40007000</baseAddress>
Nrf51.xml (nrf51822\svd):      <groupName>ADC</groupName>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):        <name>ADC</name>
Nrf51.xml (nrf51822\svd):          <description>Start an ADC conversion.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Stop ADC.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>ADC conversion complete.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x100</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <description>ADC busy register.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x400</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):              <description>ADC busy register.</description>
Nrf51.xml (nrf51822\svd):                  <name>Ready</name>
Nrf51.xml (nrf51822\svd):                  <description>No ongoing ADC conversion is taking place. ADC is ready.</description>
Nrf51.xml (nrf51822\svd):                  <description>An ADC conversion is taking place. ADC is busy.</description>
Nrf51.xml (nrf51822\svd):          <description>ADC enable.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x500</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>ADC enable.</description>
Nrf51.xml (nrf51822\svd):                  <description>ADC is disabled.</description>
Nrf51.xml (nrf51822\svd):                  <description>ADC is enabled. If an analog input pin is selected as source of the conversion, the selected pin is configured as an analog input.</description>
Nrf51.xml (nrf51822\svd):          <description>ADC configuration register.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x504</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>ADC resolution.</description>
Nrf51.xml (nrf51822\svd):                  <description>8bit ADC resolution.</description>
Nrf51.xml (nrf51822\svd):                  <description>9bit ADC resolution.</description>
Nrf51.xml (nrf51822\svd):                  <description>10bit ADC resolution.</description>
Nrf51.xml (nrf51822\svd):              <description>ADC input selection.</description>
Nrf51.xml (nrf51822\svd):              <description>ADC reference selection.</description>
Nrf51.xml (nrf51822\svd):              <description>ADC analog pin selection.</description>
Nrf51.xml (nrf51822\svd):              <description>ADC external reference pin selection.</description>
Nrf51.xml (nrf51822\svd):          <description>Result of ADC conversion.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):              <description>Result of ADC conversion.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40008000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <headerStructName>TIMER</headerStructName>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x008</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x00C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x040</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x140</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x200</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x504</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x510</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x540</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40009000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x4000A000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x4000B000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <headerStructName>RTC</headerStructName>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x008</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x00C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x100</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x104</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x140</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x340</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Enable events routing to PPI. The reading of this register gives the value of EVTEN.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x344</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <description>Disable events routing to PPI. The reading of this register gives the value of EVTEN.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x348</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x504</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x540</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x4000C000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Temperature measurement complete, data ready event.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x100</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x4000D000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x100</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x200</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x504</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x4000E000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x100</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x104</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x504</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <description>Accelerated Address Resolver.</description>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x4000F000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <description>Start resolving addresses based on IRKs specified in the IRK data structure.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Stop resolving addresses.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x008</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Address resolution procedure completed.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x100</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Address resolved.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x104</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Address not resolved.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x108</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x400</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):              <description>The IRK used last time an address was resolved.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x500</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x504</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <name>ADDRPTR</name>
Nrf51.xml (nrf51822\svd):          <description>Pointer to the resolvable address (6 bytes).</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x510</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x514</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x4000F000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x008</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x100</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x104</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x108</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x200</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x400</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x500</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x504</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x50C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x510</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x514</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40010000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x100</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x400</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x404</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):                  <description>RR[0] register is not enabled or has already requested reload.</description>
Nrf51.xml (nrf51822\svd):                  <description>RR[1] register is not enabled or has already requested reload.</description>
Nrf51.xml (nrf51822\svd):                  <description>RR[2] register is not enabled or has already requested reload.</description>
Nrf51.xml (nrf51822\svd):                  <description>RR[3] register is not enabled or has already requested reload.</description>
Nrf51.xml (nrf51822\svd):                  <description>RR[4] register is not enabled or has already requested reload.</description>
Nrf51.xml (nrf51822\svd):                  <description>RR[5] register is not enabled or has already requested reload.</description>
Nrf51.xml (nrf51822\svd):                  <description>RR[6] register is not enabled or has already requested reload.</description>
Nrf51.xml (nrf51822\svd):                  <description>RR[7] register is not enabled or has already requested reload.</description>
Nrf51.xml (nrf51822\svd):          <description>Counter reload value in number of 32kiHz clock cycles.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x504</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Reload request enable.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x50C</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Reload requests registers.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x600</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Reload register.</description>
Nrf51.xml (nrf51822\svd):                  <name>Reload</name>
Nrf51.xml (nrf51822\svd):                  <description>Value to request a reload of the watchdog timer.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40011000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40012000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <description>Start the quadrature decoder.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Stop the quadrature decoder.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):          <name>TASKS_READCLRACC</name>
Nrf51.xml (nrf51822\svd):          <description>Transfers the content from ACC registers to ACCREAD registers, and clears the ACC registers.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x008</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x100</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x104</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x108</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x200</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>REPORTRDY_READCLRACC</name>
Nrf51.xml (nrf51822\svd):              <description>Short-cut between REPORTRDY event and READCLRACC task.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x500</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x504</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x50C</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x510</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x514</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <name>ACCREAD</name>
Nrf51.xml (nrf51822\svd):          <description>Snapshot of ACC register. Value generated by the TASKS_READCLEACC task.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x518</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x51C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x520</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x524</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x528</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x540</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x544</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <name>ACCDBLREAD</name>
Nrf51.xml (nrf51822\svd):          <description>Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC task.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x548</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):              <name>ACCDBLREAD</name>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40013000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x008</addressOffset>
Nrf51.xml (nrf51822\svd):          <name>EVENTS_READY</name>
Nrf51.xml (nrf51822\svd):          <description>LPCOMP is ready and output is valid.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x100</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x104</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x108</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x10C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x200</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>READY_SAMPLE</name>
Nrf51.xml (nrf51822\svd):              <description>Short-cut between READY event and SAMPLE task.</description>
Nrf51.xml (nrf51822\svd):              <name>READY_STOP</name>
Nrf51.xml (nrf51822\svd):              <description>Short-cut between RADY event and STOP task.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>READY</name>
Nrf51.xml (nrf51822\svd):              <description>Enable interrupt on READY event.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>READY</name>
Nrf51.xml (nrf51822\svd):              <description>Disable interrupt on READY event.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x400</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x500</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x504</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x50C</addressOffset>
Nrf51.xml (nrf51822\svd):          <name>ANADETECT</name>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x520</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>ANADETECT</name>
Nrf51.xml (nrf51822\svd):                  <description>Generate ANADETEC on crossing, both upwards and downwards crossing.</description>
Nrf51.xml (nrf51822\svd):                  <description>Generate ANADETEC on upwards crossing only.</description>
Nrf51.xml (nrf51822\svd):                  <description>Generate ANADETEC on downwards crossing only.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40013000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x008</addressOffset>
Nrf51.xml (nrf51822\svd):          <name>EVENTS_READY</name>
Nrf51.xml (nrf51822\svd):          <description>COMP is ready and output is valid.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x100</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x104</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x108</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x10C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x200</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>READY_SAMPLE</name>
Nrf51.xml (nrf51822\svd):              <description>Short-cut between READY event and SAMPLE task.</description>
Nrf51.xml (nrf51822\svd):              <name>READY_STOP</name>
Nrf51.xml (nrf51822\svd):              <description>Short-cut between RADY event and STOP task.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x304</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>READY</name>
Nrf51.xml (nrf51822\svd):              <description>Enable interrupt on READY event.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x308</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>READY</name>
Nrf51.xml (nrf51822\svd):              <description>Disable interrupt on READY event.</description>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x400</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x500</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x504</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x50C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x530</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x534</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0xFFC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x40014000</baseAddress>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x4001E000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <name>READY</name>
Nrf51.xml (nrf51822\svd):          <description>Ready flag.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x400</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):              <name>READY</name>
Nrf51.xml (nrf51822\svd):              <description>NVMC ready.</description>
Nrf51.xml (nrf51822\svd):                  <name>Ready</name>
Nrf51.xml (nrf51822\svd):                  <description>NVMC is ready.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x504</addressOffset>
Nrf51.xml (nrf51822\svd):                  <description>Read only access.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x50C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x510</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x514</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x4001F000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <headerStructName>PPI_TASKS_CHG</headerStructName>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):            <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):            <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x500</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x504</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <headerStructName>PPI_CH</headerStructName>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x510</addressOffset>
Nrf51.xml (nrf51822\svd):            <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):            <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x800</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x10000000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-only</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x010</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x014</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x028</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x02C</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x034</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x038</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x05C</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Firmware Identification Number pre-loaded into the flash.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x060</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x080</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x090</addressOffset>
Nrf51.xml (nrf51822\svd):          <name>DEVICEADDRTYPE</name>
Nrf51.xml (nrf51822\svd):          <description>Device address type.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x0A0</addressOffset>
Nrf51.xml (nrf51822\svd):              <name>DEVICEADDRTYPE</name>
Nrf51.xml (nrf51822\svd):              <description>Device address type.</description>
Nrf51.xml (nrf51822\svd):                  <description>Public address.</description>
Nrf51.xml (nrf51822\svd):                  <description>Random address.</description>
Nrf51.xml (nrf51822\svd):          <name>DEVICEADDR[%s]</name>
Nrf51.xml (nrf51822\svd):          <description>Device address.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x0A4</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Radio calibration override enable.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x0AC</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit mode.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x0EC</addressOffset>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x10001000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x000</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Readback protection configuration.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x004</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Readback protect region 0. Will be ignored if pre-programmed factory code is present on the chip.</description>
Nrf51.xml (nrf51822\svd):              <description>Readback protect all code in the device.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x008</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x010</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):              <description>Identification number for the firmware loaded into the chip.</description>
Nrf51.xml (nrf51822\svd):          <name>BOOTLOADERADDR</name>
Nrf51.xml (nrf51822\svd):          <description>Bootloader start address.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x014</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x014</addressOffset>
Nrf51.xml (nrf51822\svd):          <description>Auto-loaded register values for PROTENSET0 after reset.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x018</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG0 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG1 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG2 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG3 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG4 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG5 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG6 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG7 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG8 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG9 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG10 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG11 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG12 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG13 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG14 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG15 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG16 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG17 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG18 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG19 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG20 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG21 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG22 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG23 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG24 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG25 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG26 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG27 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG28 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG29 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG30 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG31 field.</description>
Nrf51.xml (nrf51822\svd):          <description>Auto-loaded register values for PROTENSET0 after reset.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x01C</addressOffset>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG32 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG33 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG34 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG35 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG36 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG37 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG38 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG39 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG40 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG41 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG42 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG43 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG44 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG45 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG46 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG47 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG48 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG49 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG50 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG51 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG52 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG53 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG54 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG55 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG56 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG57 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG58 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG59 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG60 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG61 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG62 field.</description>
Nrf51.xml (nrf51822\svd):              <description>Auto-load value for PROTENSET0.PROTREG63 field.</description>
Nrf51.xml (nrf51822\svd):      <baseAddress>0x50000000</baseAddress>
Nrf51.xml (nrf51822\svd):      <access>read-write</access>
Nrf51.xml (nrf51822\svd):      <addressBlock>
Nrf51.xml (nrf51822\svd):      </addressBlock>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x504</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x508</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x50C</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <description>Read GPIO port.</description>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x510</addressOffset>
Nrf51.xml (nrf51822\svd):          <access>read-only</access>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x514</addressOffset>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x518</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x51C</addressOffset>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):                <usage>read</usage>
Nrf51.xml (nrf51822\svd):          <addressOffset>0x700</addressOffset>
Nrf51_bitfields.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf51_bitfields.h (nrf51822\include):/* Description: Accelerated Address Resolver. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 3..0 : The IRK used last time an address was resolved. */
Nrf51_bitfields.h (nrf51822\include):/* Peripheral: ADC */
Nrf51_bitfields.h (nrf51822\include):/* Register: ADC_INTENSET */
Nrf51_bitfields.h (nrf51822\include):#define ADC_INTENSET_END_Pos (0UL) /*!< Position of END field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_INTENSET_END_Msk (0x1UL << ADC_INTENSET_END_Pos) /*!< Bit mask of END field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Register: ADC_INTENCLR */
Nrf51_bitfields.h (nrf51822\include):#define ADC_INTENCLR_END_Pos (0UL) /*!< Position of END field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_INTENCLR_END_Msk (0x1UL << ADC_INTENCLR_END_Pos) /*!< Bit mask of END field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Register: ADC_BUSY */
Nrf51_bitfields.h (nrf51822\include):/* Description: ADC busy register. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : ADC busy register. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_BUSY_BUSY_Pos (0UL) /*!< Position of BUSY field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_BUSY_BUSY_Msk (0x1UL << ADC_BUSY_BUSY_Pos) /*!< Bit mask of BUSY field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_BUSY_BUSY_Ready (0UL) /*!< No ongoing ADC conversion is taking place. ADC is ready. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_BUSY_BUSY_Busy (1UL) /*!< An ADC conversion is taking place. ADC is busy. */
Nrf51_bitfields.h (nrf51822\include):/* Register: ADC_ENABLE */
Nrf51_bitfields.h (nrf51822\include):/* Description: ADC enable. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 1..0 : ADC enable. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_ENABLE_ENABLE_Msk (0x3UL << ADC_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_ENABLE_ENABLE_Disabled (0x00UL) /*!< ADC is disabled. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_ENABLE_ENABLE_Enabled (0x01UL) /*!< ADC is enabled. If an analog input pin is selected as source of the conversion, the selected pin is configured as an analog input. */
Nrf51_bitfields.h (nrf51822\include):/* Register: ADC_CONFIG */
Nrf51_bitfields.h (nrf51822\include):/* Description: ADC configuration register. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 17..16 : ADC external reference pin selection. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_EXTREFSEL_Pos (16UL) /*!< Position of EXTREFSEL field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_EXTREFSEL_Msk (0x3UL << ADC_CONFIG_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_EXTREFSEL_None (0UL) /*!< Analog external reference inputs disabled. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_EXTREFSEL_AnalogReference0 (1UL) /*!< Use analog reference 0 as reference. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_EXTREFSEL_AnalogReference1 (2UL) /*!< Use analog reference 1 as reference. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 15..8 : ADC analog pin selection. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_PSEL_Pos (8UL) /*!< Position of PSEL field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_PSEL_Msk (0xFFUL << ADC_CONFIG_PSEL_Pos) /*!< Bit mask of PSEL field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_PSEL_Disabled (0UL) /*!< Analog input pins disabled. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_PSEL_AnalogInput0 (1UL) /*!< Use analog input 0 as analog input. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_PSEL_AnalogInput1 (2UL) /*!< Use analog input 1 as analog input. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_PSEL_AnalogInput2 (4UL) /*!< Use analog input 2 as analog input. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_PSEL_AnalogInput3 (8UL) /*!< Use analog input 3 as analog input. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_PSEL_AnalogInput4 (16UL) /*!< Use analog input 4 as analog input. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_PSEL_AnalogInput5 (32UL) /*!< Use analog input 5 as analog input. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_PSEL_AnalogInput6 (64UL) /*!< Use analog input 6 as analog input. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_PSEL_AnalogInput7 (128UL) /*!< Use analog input 7 as analog input. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 6..5 : ADC reference selection. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_REFSEL_Pos (5UL) /*!< Position of REFSEL field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_REFSEL_Msk (0x3UL << ADC_CONFIG_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_REFSEL_VBG (0x00UL) /*!< Use internal 1.2V bandgap voltage as reference for conversion. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_REFSEL_External (0x01UL) /*!< Use external source configured by EXTREFSEL as reference for conversion. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_REFSEL_SupplyOneHalfPrescaling (0x02UL) /*!< Use supply voltage with 1/2 prescaling as reference for conversion. Only usable when supply voltage is between 1.7V and 2.6V. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_REFSEL_SupplyOneThirdPrescaling (0x03UL) /*!< Use supply voltage with 1/3 prescaling as reference for conversion. Only usable when supply voltage is between 2.5V and 3.6V. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 4..2 : ADC input selection. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_INPSEL_Pos (2UL) /*!< Position of INPSEL field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_INPSEL_Msk (0x7UL << ADC_CONFIG_INPSEL_Pos) /*!< Bit mask of INPSEL field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_INPSEL_AnalogInputNoPrescaling (0x00UL) /*!< Analog input specified by PSEL with no prescaling used as input for the conversion. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_INPSEL_AnalogInputTwoThirdsPrescaling (0x01UL) /*!< Analog input specified by PSEL with 2/3 prescaling used as input for the conversion. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling (0x02UL) /*!< Analog input specified by PSEL with 1/3 prescaling used as input for the conversion. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_INPSEL_SupplyTwoThirdsPrescaling (0x05UL) /*!< Supply voltage with 2/3 prescaling used as input for the conversion. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling (0x06UL) /*!< Supply voltage with 1/3 prescaling used as input for the conversion. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 1..0 : ADC resolution. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_RES_Pos (0UL) /*!< Position of RES field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_RES_Msk (0x3UL << ADC_CONFIG_RES_Pos) /*!< Bit mask of RES field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_RES_8bit (0x00UL) /*!< 8bit ADC resolution. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_RES_9bit (0x01UL) /*!< 9bit ADC resolution. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_CONFIG_RES_10bit (0x02UL) /*!< 10bit ADC resolution. */
Nrf51_bitfields.h (nrf51822\include):/* Register: ADC_RESULT */
Nrf51_bitfields.h (nrf51822\include):/* Description: Result of ADC conversion. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 9..0 : Result of ADC conversion. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_RESULT_RESULT_Msk (0x3FFUL << ADC_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: ADC_POWER */
Nrf51_bitfields.h (nrf51822\include):#define ADC_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_POWER_POWER_Msk (0x1UL << ADC_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
Nrf51_bitfields.h (nrf51822\include):#define ADC_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Register: AMLI_RAMPRI_RADIO */
Nrf51_bitfields.h (nrf51822\include):/* Description: Configurable priority configuration register for RADIO. */
Nrf51_bitfields.h (nrf51822\include):#define AMLI_RAMPRI_RADIO_RAM3_Pos (12UL) /*!< Position of RAM3 field. */
Nrf51_bitfields.h (nrf51822\include):#define AMLI_RAMPRI_RADIO_RAM3_Msk (0xFUL << AMLI_RAMPRI_RADIO_RAM3_Pos) /*!< Bit mask of RAM3 field. */
Nrf51_bitfields.h (nrf51822\include):#define AMLI_RAMPRI_RADIO_RAM2_Pos (8UL) /*!< Position of RAM2 field. */
Nrf51_bitfields.h (nrf51822\include):#define AMLI_RAMPRI_RADIO_RAM2_Msk (0xFUL << AMLI_RAMPRI_RADIO_RAM2_Pos) /*!< Bit mask of RAM2 field. */
Nrf51_bitfields.h (nrf51822\include):#define AMLI_RAMPRI_RADIO_RAM1_Pos (4UL) /*!< Position of RAM1 field. */
Nrf51_bitfields.h (nrf51822\include):#define AMLI_RAMPRI_RADIO_RAM1_Msk (0xFUL << AMLI_RAMPRI_RADIO_RAM1_Pos) /*!< Bit mask of RAM1 field. */
Nrf51_bitfields.h (nrf51822\include):#define AMLI_RAMPRI_RADIO_RAM0_Pos (0UL) /*!< Position of RAM0 field. */
Nrf51_bitfields.h (nrf51822\include):#define AMLI_RAMPRI_RADIO_RAM0_Msk (0xFUL << AMLI_RAMPRI_RADIO_RAM0_Pos) /*!< Bit mask of RAM0 field. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 1 : Short-cut between RADY event and STOP task. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_SHORTS_READY_STOP_Pos (1UL) /*!< Position of READY_STOP field. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_SHORTS_READY_STOP_Msk (0x1UL << COMP_SHORTS_READY_STOP_Pos) /*!< Bit mask of READY_STOP field. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_SHORTS_READY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_SHORTS_READY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : Short-cut between READY event and SAMPLE task. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_SHORTS_READY_SAMPLE_Pos (0UL) /*!< Position of READY_SAMPLE field. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_SHORTS_READY_SAMPLE_Msk (0x1UL << COMP_SHORTS_READY_SAMPLE_Pos) /*!< Bit mask of READY_SAMPLE field. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_SHORTS_READY_SAMPLE_Disabled (0UL) /*!< Shortcut disabled. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_SHORTS_READY_SAMPLE_Enabled (1UL) /*!< Shortcut enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : Enable interrupt on READY event. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_INTENSET_READY_Msk (0x1UL << COMP_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : Disable interrupt on READY event. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_INTENCLR_READY_Msk (0x1UL << COMP_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define COMP_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 31..16 : Firmware Identification Number pre-loaded into the flash. */
Nrf51_bitfields.h (nrf51822\include):/* Register: FICR_DEVICEADDRTYPE */
Nrf51_bitfields.h (nrf51822\include):/* Description: Device address type. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : Device address type. */
Nrf51_bitfields.h (nrf51822\include):#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos (0UL) /*!< Position of DEVICEADDRTYPE field. */
Nrf51_bitfields.h (nrf51822\include):#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Msk (0x1UL << FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos) /*!< Bit mask of DEVICEADDRTYPE field. */
Nrf51_bitfields.h (nrf51822\include):#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Public (0UL) /*!< Public address. */
Nrf51_bitfields.h (nrf51822\include):#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Random (1UL) /*!< Random address. */
Nrf51_bitfields.h (nrf51822\include):/* Description: Radio calibration override enable. */
Nrf51_bitfields.h (nrf51822\include):/* Description: Read GPIO port. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 1 : Short-cut between RADY event and STOP task. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_SHORTS_READY_STOP_Pos (1UL) /*!< Position of READY_STOP field. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_SHORTS_READY_STOP_Msk (0x1UL << LPCOMP_SHORTS_READY_STOP_Pos) /*!< Bit mask of READY_STOP field. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_SHORTS_READY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_SHORTS_READY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : Short-cut between READY event and SAMPLE task. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_SHORTS_READY_SAMPLE_Pos (0UL) /*!< Position of READY_SAMPLE field. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_SHORTS_READY_SAMPLE_Msk (0x1UL << LPCOMP_SHORTS_READY_SAMPLE_Pos) /*!< Bit mask of READY_SAMPLE field. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_SHORTS_READY_SAMPLE_Disabled (0UL) /*!< Shortcut disabled. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_SHORTS_READY_SAMPLE_Enabled (1UL) /*!< Shortcut enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : Enable interrupt on READY event. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_INTENSET_READY_Msk (0x1UL << LPCOMP_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : Disable interrupt on READY event. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_INTENCLR_READY_Msk (0x1UL << LPCOMP_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Register: LPCOMP_ANADETECT */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_ANADETECT_ANADETECT_Pos (0UL) /*!< Position of ANADETECT field. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_ANADETECT_ANADETECT_Msk (0x3UL << LPCOMP_ANADETECT_ANADETECT_Pos) /*!< Bit mask of ANADETECT field. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_ANADETECT_ANADETECT_Cross (0UL) /*!< Generate ANADETEC on crossing, both upwards and downwards crossing. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_ANADETECT_ANADETECT_Up (1UL) /*!< Generate ANADETEC on upwards crossing only. */
Nrf51_bitfields.h (nrf51822\include):#define LPCOMP_ANADETECT_ANADETECT_Down (2UL) /*!< Generate ANADETEC on downwards crossing only. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 7 : ADC region configuration. */
Nrf51_bitfields.h (nrf51822\include):#define MPU_PERR0_ADC_Pos (7UL) /*!< Position of ADC field. */
Nrf51_bitfields.h (nrf51822\include):#define MPU_PERR0_ADC_Msk (0x1UL << MPU_PERR0_ADC_Pos) /*!< Bit mask of ADC field. */
Nrf51_bitfields.h (nrf51822\include):#define MPU_PERR0_ADC_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
Nrf51_bitfields.h (nrf51822\include):#define MPU_PERR0_ADC_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 1 : RADIO region configuration. */
Nrf51_bitfields.h (nrf51822\include):#define MPU_PERR0_RADIO_Pos (1UL) /*!< Position of RADIO field. */
Nrf51_bitfields.h (nrf51822\include):#define MPU_PERR0_RADIO_Msk (0x1UL << MPU_PERR0_RADIO_Pos) /*!< Bit mask of RADIO field. */
Nrf51_bitfields.h (nrf51822\include):#define MPU_PERR0_RADIO_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
Nrf51_bitfields.h (nrf51822\include):#define MPU_PERR0_RADIO_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
Nrf51_bitfields.h (nrf51822\include):/* Description: Protection bit enable set register for low addresses. */
Nrf51_bitfields.h (nrf51822\include):/* Description: Protection bit enable set register for high addresses. */
Nrf51_bitfields.h (nrf51822\include):/* Register: NVMC_READY */
Nrf51_bitfields.h (nrf51822\include):/* Description: Ready flag. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : NVMC ready. */
Nrf51_bitfields.h (nrf51822\include):#define NVMC_READY_READY_Pos (0UL) /*!< Position of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define NVMC_READY_READY_Msk (0x1UL << NVMC_READY_READY_Pos) /*!< Bit mask of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define NVMC_READY_READY_Busy (0UL) /*!< NVMC is busy (on-going write or erase operation). */
Nrf51_bitfields.h (nrf51822\include):#define NVMC_READY_READY_Ready (1UL) /*!< NVMC is ready. */
Nrf51_bitfields.h (nrf51822\include):#define NVMC_CONFIG_WEN_Ren (0x00UL) /*!< Read only access. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 17 : Reset from wake-up from OFF mode detected by the use of ANADETECT signal from LPCOMP. */
Nrf51_bitfields.h (nrf51822\include):/* Register: PU_PATCHADDR */
Nrf51_bitfields.h (nrf51822\include):/* Description: Relative address of patch instructions. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 24..0 : Relative address of patch instructions. */
Nrf51_bitfields.h (nrf51822\include):#define PU_PATCHADDR_PATCHADDR_Pos (0UL) /*!< Position of PATCHADDR field. */
Nrf51_bitfields.h (nrf51822\include):#define PU_PATCHADDR_PATCHADDR_Msk (0x1FFFFFFUL << PU_PATCHADDR_PATCHADDR_Pos) /*!< Bit mask of PATCHADDR field. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : Short-cut between REPORTRDY event and READCLRACC task. */
Nrf51_bitfields.h (nrf51822\include):#define QDEC_SHORTS_REPORTRDY_READCLRACC_Pos (0UL) /*!< Position of REPORTRDY_READCLRACC field. */
Nrf51_bitfields.h (nrf51822\include):#define QDEC_SHORTS_REPORTRDY_READCLRACC_Msk (0x1UL << QDEC_SHORTS_REPORTRDY_READCLRACC_Pos) /*!< Bit mask of REPORTRDY_READCLRACC field. */
Nrf51_bitfields.h (nrf51822\include):#define QDEC_SHORTS_REPORTRDY_READCLRACC_Disabled (0UL) /*!< Shortcut disabled. */
Nrf51_bitfields.h (nrf51822\include):#define QDEC_SHORTS_REPORTRDY_READCLRACC_Enabled (1UL) /*!< Shortcut enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Register: QDEC_ACCDBLREAD */
Nrf51_bitfields.h (nrf51822\include):/* Description: Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC task. */
Nrf51_bitfields.h (nrf51822\include):#define QDEC_ACCDBLREAD_ACCDBLREAD_Pos (0UL) /*!< Position of ACCDBLREAD field. */
Nrf51_bitfields.h (nrf51822\include):#define QDEC_ACCDBLREAD_ACCDBLREAD_Msk (0xFUL << QDEC_ACCDBLREAD_ACCDBLREAD_Pos) /*!< Bit mask of ACCDBLREAD field. */
Nrf51_bitfields.h (nrf51822\include):/* Peripheral: RADIO */
Nrf51_bitfields.h (nrf51822\include):/* Description: The radio. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_SHORTS */
Nrf51_bitfields.h (nrf51822\include):/* Description: Shortcut for the radio. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_DISABLED_RSSISTOP_Pos (8UL) /*!< Position of DISABLED_RSSISTOP field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_DISABLED_RSSISTOP_Msk (0x1UL << RADIO_SHORTS_DISABLED_RSSISTOP_Pos) /*!< Bit mask of DISABLED_RSSISTOP field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_DISABLED_RSSISTOP_Disabled (0UL) /*!< Shortcut disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_DISABLED_RSSISTOP_Enabled (1UL) /*!< Shortcut enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 6 : Shortcut between ADDRESS event and BCSTART task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_ADDRESS_BCSTART_Pos (6UL) /*!< Position of ADDRESS_BCSTART field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_ADDRESS_BCSTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_BCSTART_Pos) /*!< Bit mask of ADDRESS_BCSTART field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_ADDRESS_BCSTART_Disabled (0UL) /*!< Shortcut disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_ADDRESS_BCSTART_Enabled (1UL) /*!< Shortcut enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_END_START_Pos (5UL) /*!< Position of END_START field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_END_START_Msk (0x1UL << RADIO_SHORTS_END_START_Pos) /*!< Bit mask of END_START field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_END_START_Disabled (0UL) /*!< Shortcut disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_END_START_Enabled (1UL) /*!< Shortcut enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 4 : Shortcut between ADDRESS event and RSSISTART task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_ADDRESS_RSSISTART_Pos (4UL) /*!< Position of ADDRESS_RSSISTART field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_ADDRESS_RSSISTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_RSSISTART_Pos) /*!< Bit mask of ADDRESS_RSSISTART field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_ADDRESS_RSSISTART_Disabled (0UL) /*!< Shortcut disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_ADDRESS_RSSISTART_Enabled (1UL) /*!< Shortcut enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_DISABLED_RXEN_Pos (3UL) /*!< Position of DISABLED_RXEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_DISABLED_RXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_RXEN_Pos) /*!< Bit mask of DISABLED_RXEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_DISABLED_RXEN_Disabled (0UL) /*!< Shortcut disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_DISABLED_RXEN_Enabled (1UL) /*!< Shortcut enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_DISABLED_TXEN_Pos (2UL) /*!< Position of DISABLED_TXEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_DISABLED_TXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_TXEN_Pos) /*!< Bit mask of DISABLED_TXEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_DISABLED_TXEN_Disabled (0UL) /*!< Shortcut disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_DISABLED_TXEN_Enabled (1UL) /*!< Shortcut enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_END_DISABLE_Pos (1UL) /*!< Position of END_DISABLE field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_END_DISABLE_Msk (0x1UL << RADIO_SHORTS_END_DISABLE_Pos) /*!< Bit mask of END_DISABLE field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_END_DISABLE_Disabled (0UL) /*!< Shortcut disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_END_DISABLE_Enabled (1UL) /*!< Shortcut enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : Shortcut between READY event and START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_READY_START_Pos (0UL) /*!< Position of READY_START field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_READY_START_Msk (0x1UL << RADIO_SHORTS_READY_START_Pos) /*!< Bit mask of READY_START field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_READY_START_Disabled (0UL) /*!< Shortcut disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_SHORTS_READY_START_Enabled (1UL) /*!< Shortcut enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_INTENSET */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_BCMATCH_Msk (0x1UL << RADIO_INTENSET_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_BCMATCH_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_BCMATCH_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_BCMATCH_Set (1UL) /*!< Enable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_RSSIEND_Msk (0x1UL << RADIO_INTENSET_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_RSSIEND_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_RSSIEND_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_RSSIEND_Set (1UL) /*!< Enable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_DEVMISS_Msk (0x1UL << RADIO_INTENSET_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_DEVMISS_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_DEVMISS_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_DEVMISS_Set (1UL) /*!< Enable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_DEVMATCH_Msk (0x1UL << RADIO_INTENSET_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_DEVMATCH_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_DEVMATCH_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_DEVMATCH_Set (1UL) /*!< Enable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_DISABLED_Msk (0x1UL << RADIO_INTENSET_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_DISABLED_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_DISABLED_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_DISABLED_Set (1UL) /*!< Enable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_END_Pos (3UL) /*!< Position of END field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_END_Msk (0x1UL << RADIO_INTENSET_END_Pos) /*!< Bit mask of END field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 2 : Enable interrupt on PAYLOAD event. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_PAYLOAD_Msk (0x1UL << RADIO_INTENSET_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_PAYLOAD_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_PAYLOAD_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_PAYLOAD_Set (1UL) /*!< Enable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 1 : Enable interrupt on ADDRESS event. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_ADDRESS_Msk (0x1UL << RADIO_INTENSET_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_ADDRESS_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_ADDRESS_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_ADDRESS_Set (1UL) /*!< Enable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : Enable interrupt on READY event. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_READY_Msk (0x1UL << RADIO_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_INTENCLR */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_BCMATCH_Msk (0x1UL << RADIO_INTENCLR_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_BCMATCH_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_BCMATCH_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_BCMATCH_Clear (1UL) /*!< Disable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_RSSIEND_Msk (0x1UL << RADIO_INTENCLR_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_RSSIEND_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_RSSIEND_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_RSSIEND_Clear (1UL) /*!< Disable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_DEVMISS_Msk (0x1UL << RADIO_INTENCLR_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_DEVMISS_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_DEVMISS_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_DEVMISS_Clear (1UL) /*!< Disable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_DEVMATCH_Msk (0x1UL << RADIO_INTENCLR_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_DEVMATCH_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_DEVMATCH_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_DEVMATCH_Clear (1UL) /*!< Disable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_DISABLED_Msk (0x1UL << RADIO_INTENCLR_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_DISABLED_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_DISABLED_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_DISABLED_Clear (1UL) /*!< Disable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_END_Pos (3UL) /*!< Position of END field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_END_Msk (0x1UL << RADIO_INTENCLR_END_Pos) /*!< Bit mask of END field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 2 : Disable interrupt on PAYLOAD event. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_PAYLOAD_Msk (0x1UL << RADIO_INTENCLR_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_PAYLOAD_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_PAYLOAD_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_PAYLOAD_Clear (1UL) /*!< Disable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 1 : Disable interrupt on ADDRESS event. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_ADDRESS_Msk (0x1UL << RADIO_INTENCLR_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_ADDRESS_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_ADDRESS_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_ADDRESS_Clear (1UL) /*!< Disable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : Disable interrupt on READY event. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_READY_Msk (0x1UL << RADIO_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_CRCSTATUS */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCSTATUS_CRCSTATUS_Pos (0UL) /*!< Position of CRCSTATUS field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCSTATUS_CRCSTATUS_Msk (0x1UL << RADIO_CRCSTATUS_CRCSTATUS_Pos) /*!< Bit mask of CRCSTATUS field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCSTATUS_CRCSTATUS_CRCError (0UL) /*!< Packet received with CRC error. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCSTATUS_CRCSTATUS_CRCOk (1UL) /*!< Packet received with CRC ok. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_RXMATCH */
Nrf51_bitfields.h (nrf51822\include):/* Description: Received address. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 2..0 : Logical address in which previous packet was received. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXMATCH_RXMATCH_Pos (0UL) /*!< Position of RXMATCH field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXMATCH_RXMATCH_Msk (0x7UL << RADIO_RXMATCH_RXMATCH_Pos) /*!< Bit mask of RXMATCH field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_RXCRC */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXCRC_RXCRC_Pos (0UL) /*!< Position of RXCRC field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXCRC_RXCRC_Msk (0xFFFFFFUL << RADIO_RXCRC_RXCRC_Pos) /*!< Bit mask of RXCRC field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_DAI */
Nrf51_bitfields.h (nrf51822\include):/* Description: Device address match index. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 2..0 : Index (n) of device address (see DAB[n] and DAP[n]) that got an address match. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DAI_DAI_Pos (0UL) /*!< Position of DAI field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DAI_DAI_Msk (0x7UL << RADIO_DAI_DAI_Pos) /*!< Bit mask of DAI field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_FREQUENCY */
Nrf51_bitfields.h (nrf51822\include):/* Bits 6..0 : Radio channel frequency offset in MHz: RF Frequency = 2400 + FREQUENCY (MHz). Decision point: TXEN or RXEN task.  */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_FREQUENCY_FREQUENCY_Msk (0x7FUL << RADIO_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_TXPOWER */
Nrf51_bitfields.h (nrf51822\include):/* Bits 7..0 : Radio output power. Decision point: TXEN task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TXPOWER_TXPOWER_Pos (0UL) /*!< Position of TXPOWER field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TXPOWER_TXPOWER_Msk (0xFFUL << RADIO_TXPOWER_TXPOWER_Pos) /*!< Bit mask of TXPOWER field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TXPOWER_TXPOWER_Pos4dBm (0x04UL) /*!< +4dBm. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TXPOWER_TXPOWER_0dBm (0x00UL) /*!< 0dBm. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TXPOWER_TXPOWER_Neg4dBm (0xFCUL) /*!< -4dBm. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TXPOWER_TXPOWER_Neg8dBm (0xF8UL) /*!< -8dBm. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TXPOWER_TXPOWER_Neg12dBm (0xF4UL) /*!< -12dBm. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TXPOWER_TXPOWER_Neg16dBm (0xF0UL) /*!< -16dBm. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TXPOWER_TXPOWER_Neg20dBm (0xECUL) /*!< -20dBm. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TXPOWER_TXPOWER_Neg30dBm (0xD8UL) /*!< -30dBm. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_MODE */
Nrf51_bitfields.h (nrf51822\include):/* Bits 1..0 : Radio data rate and modulation setting. Decision point: TXEN or RXEN task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_MODE_MODE_Msk (0x3UL << RADIO_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_MODE_MODE_Nrf_1Mbit (0x00UL) /*!< 1Mbit/s Nordic propietary radio mode. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_MODE_MODE_Nrf_2Mbit (0x01UL) /*!< 2Mbit/s Nordic propietary radio mode. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_MODE_MODE_Nrf_250Kbit (0x02UL) /*!< 250kbit/s Nordic propietary radio mode. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_MODE_MODE_Ble_1Mbit (0x03UL) /*!< 1Mbit/s Bluetooth Low Energy */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_PCNF0 */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF0_S1LEN_Pos (16UL) /*!< Position of S1LEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF0_S1LEN_Msk (0xFUL << RADIO_PCNF0_S1LEN_Pos) /*!< Bit mask of S1LEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF0_S0LEN_Pos (8UL) /*!< Position of S0LEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF0_S0LEN_Msk (0x1UL << RADIO_PCNF0_S0LEN_Pos) /*!< Bit mask of S0LEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF0_LFLEN_Pos (0UL) /*!< Position of LFLEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF0_LFLEN_Msk (0xFUL << RADIO_PCNF0_LFLEN_Pos) /*!< Bit mask of LFLEN field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_PCNF1 */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF1_WHITEEN_Pos (25UL) /*!< Position of WHITEEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF1_WHITEEN_Msk (0x1UL << RADIO_PCNF1_WHITEEN_Pos) /*!< Bit mask of WHITEEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF1_WHITEEN_Disabled (0UL) /*!< Whitening disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF1_WHITEEN_Enabled (1UL) /*!< Whitening enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF1_ENDIAN_Pos (24UL) /*!< Position of ENDIAN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF1_ENDIAN_Msk (0x1UL << RADIO_PCNF1_ENDIAN_Pos) /*!< Bit mask of ENDIAN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF1_ENDIAN_Little (0UL) /*!< Least significant bit on air first */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF1_ENDIAN_Big (1UL) /*!< Most significant bit on air first */
Nrf51_bitfields.h (nrf51822\include):/* Bits 18..16 : Base address length in number of bytes. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF1_BALEN_Pos (16UL) /*!< Position of BALEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF1_BALEN_Msk (0x7UL << RADIO_PCNF1_BALEN_Pos) /*!< Bit mask of BALEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF1_STATLEN_Pos (8UL) /*!< Position of STATLEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF1_STATLEN_Msk (0xFFUL << RADIO_PCNF1_STATLEN_Pos) /*!< Bit mask of STATLEN field. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 7..0 : Maximum length of packet payload in number of bytes. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF1_MAXLEN_Pos (0UL) /*!< Position of MAXLEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PCNF1_MAXLEN_Msk (0xFFUL << RADIO_PCNF1_MAXLEN_Pos) /*!< Bit mask of MAXLEN field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_PREFIX0 */
Nrf51_bitfields.h (nrf51822\include):/* Description: Prefixes bytes for logical addresses 0 to 3. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 31..24 : Address prefix 3. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX0_AP3_Pos (24UL) /*!< Position of AP3 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX0_AP3_Msk (0xFFUL << RADIO_PREFIX0_AP3_Pos) /*!< Bit mask of AP3 field. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 23..16 : Address prefix 2. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX0_AP2_Pos (16UL) /*!< Position of AP2 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX0_AP2_Msk (0xFFUL << RADIO_PREFIX0_AP2_Pos) /*!< Bit mask of AP2 field. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 15..8 : Address prefix 1. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX0_AP1_Pos (8UL) /*!< Position of AP1 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX0_AP1_Msk (0xFFUL << RADIO_PREFIX0_AP1_Pos) /*!< Bit mask of AP1 field. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 7..0 : Address prefix 0. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX0_AP0_Pos (0UL) /*!< Position of AP0 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX0_AP0_Msk (0xFFUL << RADIO_PREFIX0_AP0_Pos) /*!< Bit mask of AP0 field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_PREFIX1 */
Nrf51_bitfields.h (nrf51822\include):/* Description: Prefixes bytes for logical addresses 4 to 7. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 31..24 : Address prefix 7. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX1_AP7_Pos (24UL) /*!< Position of AP7 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX1_AP7_Msk (0xFFUL << RADIO_PREFIX1_AP7_Pos) /*!< Bit mask of AP7 field. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 23..16 : Address prefix 6. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX1_AP6_Pos (16UL) /*!< Position of AP6 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX1_AP6_Msk (0xFFUL << RADIO_PREFIX1_AP6_Pos) /*!< Bit mask of AP6 field. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 15..8 : Address prefix 5. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX1_AP5_Pos (8UL) /*!< Position of AP5 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX1_AP5_Msk (0xFFUL << RADIO_PREFIX1_AP5_Pos) /*!< Bit mask of AP5 field. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 7..0 : Address prefix 4. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX1_AP4_Pos (0UL) /*!< Position of AP4 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_PREFIX1_AP4_Msk (0xFFUL << RADIO_PREFIX1_AP4_Pos) /*!< Bit mask of AP4 field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_TXADDRESS */
Nrf51_bitfields.h (nrf51822\include):/* Description: Transmit address select. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 2..0 : Logical address to be used when transmitting a packet. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TXADDRESS_TXADDRESS_Pos (0UL) /*!< Position of TXADDRESS field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TXADDRESS_TXADDRESS_Msk (0x7UL << RADIO_TXADDRESS_TXADDRESS_Pos) /*!< Bit mask of TXADDRESS field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_RXADDRESSES */
Nrf51_bitfields.h (nrf51822\include):/* Description: Receive address select. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 7 : Enable reception on logical address 7. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR7_Pos (7UL) /*!< Position of ADDR7 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR7_Msk (0x1UL << RADIO_RXADDRESSES_ADDR7_Pos) /*!< Bit mask of ADDR7 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR7_Disabled (0UL) /*!< Reception disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR7_Enabled (1UL) /*!< Reception enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 6 : Enable reception on logical address 6. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR6_Pos (6UL) /*!< Position of ADDR6 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR6_Msk (0x1UL << RADIO_RXADDRESSES_ADDR6_Pos) /*!< Bit mask of ADDR6 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR6_Disabled (0UL) /*!< Reception disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR6_Enabled (1UL) /*!< Reception enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 5 : Enable reception on logical address 5. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR5_Pos (5UL) /*!< Position of ADDR5 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR5_Msk (0x1UL << RADIO_RXADDRESSES_ADDR5_Pos) /*!< Bit mask of ADDR5 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR5_Disabled (0UL) /*!< Reception disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR5_Enabled (1UL) /*!< Reception enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 4 : Enable reception on logical address 4. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR4_Pos (4UL) /*!< Position of ADDR4 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR4_Msk (0x1UL << RADIO_RXADDRESSES_ADDR4_Pos) /*!< Bit mask of ADDR4 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR4_Disabled (0UL) /*!< Reception disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR4_Enabled (1UL) /*!< Reception enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 3 : Enable reception on logical address 3. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR3_Pos (3UL) /*!< Position of ADDR3 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR3_Msk (0x1UL << RADIO_RXADDRESSES_ADDR3_Pos) /*!< Bit mask of ADDR3 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR3_Disabled (0UL) /*!< Reception disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR3_Enabled (1UL) /*!< Reception enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 2 : Enable reception on logical address 2. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR2_Pos (2UL) /*!< Position of ADDR2 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR2_Msk (0x1UL << RADIO_RXADDRESSES_ADDR2_Pos) /*!< Bit mask of ADDR2 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR2_Disabled (0UL) /*!< Reception disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR2_Enabled (1UL) /*!< Reception enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 1 : Enable reception on logical address 1. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR1_Pos (1UL) /*!< Position of ADDR1 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR1_Msk (0x1UL << RADIO_RXADDRESSES_ADDR1_Pos) /*!< Bit mask of ADDR1 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR1_Disabled (0UL) /*!< Reception disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR1_Enabled (1UL) /*!< Reception enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : Enable reception on logical address 0. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR0_Pos (0UL) /*!< Position of ADDR0 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR0_Msk (0x1UL << RADIO_RXADDRESSES_ADDR0_Pos) /*!< Bit mask of ADDR0 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR0_Disabled (0UL) /*!< Reception disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RXADDRESSES_ADDR0_Enabled (1UL) /*!< Reception enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_CRCCNF */
Nrf51_bitfields.h (nrf51822\include):/* Bit 8 : Leave packet address field out of the CRC calculation. Decision point: START task. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCCNF_SKIP_ADDR_Pos (8UL) /*!< Position of SKIP_ADDR field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCCNF_SKIP_ADDR_Msk (0x1UL << RADIO_CRCCNF_SKIP_ADDR_Pos) /*!< Bit mask of SKIP_ADDR field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCCNF_SKIP_ADDR_Include (0UL) /*!< Include packet address in CRC calculation. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCCNF_SKIP_ADDR_Skip (1UL) /*!< Packet address is skipped in CRC calculation. The CRC calculation will start at the first byte after the address. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCCNF_LEN_Pos (0UL) /*!< Position of LEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCCNF_LEN_Msk (0x3UL << RADIO_CRCCNF_LEN_Pos) /*!< Bit mask of LEN field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCCNF_LEN_Disabled (0UL) /*!< CRC calculation disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCCNF_LEN_One (1UL) /*!< One byte long CRC. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCCNF_LEN_Two (2UL) /*!< Two bytes long CRC. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCCNF_LEN_Three (3UL) /*!< Three bytes long CRC. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_CRCPOLY */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCPOLY_CRCPOLY_Pos (1UL) /*!< Position of CRCPOLY field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCPOLY_CRCPOLY_Msk (0x7FFFFFUL << RADIO_CRCPOLY_CRCPOLY_Pos) /*!< Bit mask of CRCPOLY field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_CRCINIT */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCINIT_CRCINIT_Pos (0UL) /*!< Position of CRCINIT field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_CRCINIT_CRCINIT_Msk (0xFFFFFFUL << RADIO_CRCINIT_CRCINIT_Pos) /*!< Bit mask of CRCINIT field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_TEST */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TEST_PLL_LOCK_Pos (1UL) /*!< Position of PLL_LOCK field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TEST_PLL_LOCK_Msk (0x1UL << RADIO_TEST_PLL_LOCK_Pos) /*!< Bit mask of PLL_LOCK field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TEST_PLL_LOCK_Disabled (0UL) /*!< PLL lock disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TEST_PLL_LOCK_Enabled (1UL) /*!< PLL lock enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TEST_CONST_CARRIER_Pos (0UL) /*!< Position of CONST_CARRIER field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TEST_CONST_CARRIER_Msk (0x1UL << RADIO_TEST_CONST_CARRIER_Pos) /*!< Bit mask of CONST_CARRIER field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TEST_CONST_CARRIER_Disabled (0UL) /*!< Constant carrier disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TEST_CONST_CARRIER_Enabled (1UL) /*!< Constant carrier enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_TIFS */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TIFS_TIFS_Pos (0UL) /*!< Position of TIFS field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_TIFS_TIFS_Msk (0xFFUL << RADIO_TIFS_TIFS_Pos) /*!< Bit mask of TIFS field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_RSSISAMPLE */
Nrf51_bitfields.h (nrf51822\include):/* Bits 6..0 : RSSI sample result. The result is read as a positive value so that ReceivedSignalStrength = -RSSISAMPLE dBm */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RSSISAMPLE_RSSISAMPLE_Pos (0UL) /*!< Position of RSSISAMPLE field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_RSSISAMPLE_RSSISAMPLE_Msk (0x7FUL << RADIO_RSSISAMPLE_RSSISAMPLE_Pos) /*!< Bit mask of RSSISAMPLE field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_STATE */
Nrf51_bitfields.h (nrf51822\include):/* Description: Current radio state. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 3..0 : Current radio state. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_STATE_STATE_Pos (0UL) /*!< Position of STATE field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_STATE_STATE_Msk (0xFUL << RADIO_STATE_STATE_Pos) /*!< Bit mask of STATE field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_STATE_STATE_Disabled (0x00UL) /*!< Radio is in the Disabled state. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_STATE_STATE_RxRu (0x01UL) /*!< Radio is in the Rx Ramp Up state. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_STATE_STATE_RxIdle (0x02UL) /*!< Radio is in the Rx Idle state. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_STATE_STATE_Rx (0x03UL) /*!< Radio is in the Rx state. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_STATE_STATE_RxDisable (0x04UL) /*!< Radio is in the Rx Disable state. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_STATE_STATE_TxRu (0x09UL) /*!< Radio is in the Tx Ramp Up state. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_STATE_STATE_TxIdle (0x0AUL) /*!< Radio is in the Tx Idle state. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_STATE_STATE_Tx (0x0BUL) /*!< Radio is in the Tx state. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_STATE_STATE_TxDisable (0x0CUL) /*!< Radio is in the Tx Disable state. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_DATAWHITEIV */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DATAWHITEIV_DATAWHITEIV_Pos (0UL) /*!< Position of DATAWHITEIV field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DATAWHITEIV_DATAWHITEIV_Msk (0x3FUL << RADIO_DATAWHITEIV_DATAWHITEIV_Pos) /*!< Bit mask of DATAWHITEIV field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_DAP */
Nrf51_bitfields.h (nrf51822\include):/* Description: Device address prefix. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 15..0 : Device address prefix. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DAP_DAP_Pos (0UL) /*!< Position of DAP field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DAP_DAP_Msk (0xFFFFUL << RADIO_DAP_DAP_Pos) /*!< Bit mask of DAP field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_DACNF */
Nrf51_bitfields.h (nrf51822\include):/* Description: Device address match configuration. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 15 : TxAdd for device address 7. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD7_Pos (15UL) /*!< Position of TXADD7 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD7_Msk (0x1UL << RADIO_DACNF_TXADD7_Pos) /*!< Bit mask of TXADD7 field. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 14 : TxAdd for device address 6. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD6_Pos (14UL) /*!< Position of TXADD6 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD6_Msk (0x1UL << RADIO_DACNF_TXADD6_Pos) /*!< Bit mask of TXADD6 field. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 13 : TxAdd for device address 5. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD5_Pos (13UL) /*!< Position of TXADD5 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD5_Msk (0x1UL << RADIO_DACNF_TXADD5_Pos) /*!< Bit mask of TXADD5 field. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 12 : TxAdd for device address 4. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD4_Pos (12UL) /*!< Position of TXADD4 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD4_Msk (0x1UL << RADIO_DACNF_TXADD4_Pos) /*!< Bit mask of TXADD4 field. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 11 : TxAdd for device address 3. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD3_Pos (11UL) /*!< Position of TXADD3 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD3_Msk (0x1UL << RADIO_DACNF_TXADD3_Pos) /*!< Bit mask of TXADD3 field. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 10 : TxAdd for device address 2. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD2_Pos (10UL) /*!< Position of TXADD2 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD2_Msk (0x1UL << RADIO_DACNF_TXADD2_Pos) /*!< Bit mask of TXADD2 field. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 9 : TxAdd for device address 1. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD1_Pos (9UL) /*!< Position of TXADD1 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD1_Msk (0x1UL << RADIO_DACNF_TXADD1_Pos) /*!< Bit mask of TXADD1 field. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 8 : TxAdd for device address 0. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD0_Pos (8UL) /*!< Position of TXADD0 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_TXADD0_Msk (0x1UL << RADIO_DACNF_TXADD0_Pos) /*!< Bit mask of TXADD0 field. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 7 : Enable or disable device address matching using device address 7. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA7_Pos (7UL) /*!< Position of ENA7 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA7_Msk (0x1UL << RADIO_DACNF_ENA7_Pos) /*!< Bit mask of ENA7 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA7_Disabled (0UL) /*!< Disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA7_Enabled (1UL) /*!< Enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 6 : Enable or disable device address matching using device address 6. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA6_Pos (6UL) /*!< Position of ENA6 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA6_Msk (0x1UL << RADIO_DACNF_ENA6_Pos) /*!< Bit mask of ENA6 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA6_Disabled (0UL) /*!< Disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA6_Enabled (1UL) /*!< Enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 5 : Enable or disable device address matching using device address 5. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA5_Pos (5UL) /*!< Position of ENA5 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA5_Msk (0x1UL << RADIO_DACNF_ENA5_Pos) /*!< Bit mask of ENA5 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA5_Disabled (0UL) /*!< Disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA5_Enabled (1UL) /*!< Enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 4 : Enable or disable device address matching using device address 4. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA4_Pos (4UL) /*!< Position of ENA4 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA4_Msk (0x1UL << RADIO_DACNF_ENA4_Pos) /*!< Bit mask of ENA4 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA4_Disabled (0UL) /*!< Disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA4_Enabled (1UL) /*!< Enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 3 : Enable or disable device address matching using device address 3. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA3_Pos (3UL) /*!< Position of ENA3 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA3_Msk (0x1UL << RADIO_DACNF_ENA3_Pos) /*!< Bit mask of ENA3 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA3_Disabled (0UL) /*!< Disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA3_Enabled (1UL) /*!< Enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 2 : Enable or disable device address matching using device address 2. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA2_Pos (2UL) /*!< Position of ENA2 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA2_Msk (0x1UL << RADIO_DACNF_ENA2_Pos) /*!< Bit mask of ENA2 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA2_Disabled (0UL) /*!< Disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA2_Enabled (1UL) /*!< Enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 1 : Enable or disable device address matching using device address 1. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA1_Pos (1UL) /*!< Position of ENA1 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA1_Msk (0x1UL << RADIO_DACNF_ENA1_Pos) /*!< Bit mask of ENA1 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA1_Disabled (0UL) /*!< Disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA1_Enabled (1UL) /*!< Enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : Enable or disable device address matching using device address 0. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA0_Pos (0UL) /*!< Position of ENA0 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA0_Msk (0x1UL << RADIO_DACNF_ENA0_Pos) /*!< Bit mask of ENA0 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA0_Disabled (0UL) /*!< Disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_DACNF_ENA0_Enabled (1UL) /*!< Enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_OVERRIDE0 */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_OVERRIDE0_OVERRIDE0_Pos (0UL) /*!< Position of OVERRIDE0 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_OVERRIDE0_OVERRIDE0_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE0_OVERRIDE0_Pos) /*!< Bit mask of OVERRIDE0 field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_OVERRIDE1 */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_OVERRIDE1_OVERRIDE1_Pos (0UL) /*!< Position of OVERRIDE1 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_OVERRIDE1_OVERRIDE1_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE1_OVERRIDE1_Pos) /*!< Bit mask of OVERRIDE1 field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_OVERRIDE2 */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_OVERRIDE2_OVERRIDE2_Pos (0UL) /*!< Position of OVERRIDE2 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_OVERRIDE2_OVERRIDE2_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE2_OVERRIDE2_Pos) /*!< Bit mask of OVERRIDE2 field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_OVERRIDE3 */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_OVERRIDE3_OVERRIDE3_Pos (0UL) /*!< Position of OVERRIDE3 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_OVERRIDE3_OVERRIDE3_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE3_OVERRIDE3_Pos) /*!< Bit mask of OVERRIDE3 field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_OVERRIDE4 */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_OVERRIDE4_ENABLE_Pos (31UL) /*!< Position of ENABLE field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_OVERRIDE4_ENABLE_Msk (0x1UL << RADIO_OVERRIDE4_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_OVERRIDE4_ENABLE_Disabled (0UL) /*!< Override trim values disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_OVERRIDE4_ENABLE_Enabled (1UL) /*!< Override trim values enabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_OVERRIDE4_OVERRIDE4_Pos (0UL) /*!< Position of OVERRIDE4 field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_OVERRIDE4_OVERRIDE4_Msk (0xFFFFFFFUL << RADIO_OVERRIDE4_OVERRIDE4_Pos) /*!< Bit mask of OVERRIDE4 field. */
Nrf51_bitfields.h (nrf51822\include):/* Register: RADIO_POWER */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_POWER_POWER_Msk (0x1UL << RADIO_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
Nrf51_bitfields.h (nrf51822\include):#define RADIO_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Description: Enable events routing to PPI. The reading of this register gives the value of EVTEN. */
Nrf51_bitfields.h (nrf51822\include):/* Description: Disable events routing to PPI. The reading of this register gives the value of EVTEN. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 2 : Enable interrupt on READY event. */
Nrf51_bitfields.h (nrf51822\include):#define SPI_INTENSET_READY_Pos (2UL) /*!< Position of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define SPI_INTENSET_READY_Msk (0x1UL << SPI_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define SPI_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define SPI_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define SPI_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 2 : Disable interrupt on READY event. */
Nrf51_bitfields.h (nrf51822\include):#define SPI_INTENCLR_READY_Pos (2UL) /*!< Position of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define SPI_INTENCLR_READY_Msk (0x1UL << SPI_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
Nrf51_bitfields.h (nrf51822\include):#define SPI_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define SPI_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define SPI_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):#define SPI_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of the clock. Shift serial data on trailing edge. */
Nrf51_bitfields.h (nrf51822\include):#define SPI_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of the clock. Shift serial data on leading edge. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 0 : TX buffer overread detected, and prevented. */
Nrf51_bitfields.h (nrf51822\include):#define SPIS_STATUS_OVERREAD_Pos (0UL) /*!< Position of OVERREAD field. */
Nrf51_bitfields.h (nrf51822\include):#define SPIS_STATUS_OVERREAD_Msk (0x1UL << SPIS_STATUS_OVERREAD_Pos) /*!< Bit mask of OVERREAD field. */
Nrf51_bitfields.h (nrf51822\include):#define SPIS_STATUS_OVERREAD_NotPresent (0UL) /*!< Error not present. */
Nrf51_bitfields.h (nrf51822\include):#define SPIS_STATUS_OVERREAD_Present (1UL) /*!< Error present. */
Nrf51_bitfields.h (nrf51822\include):#define SPIS_STATUS_OVERREAD_Clear (1UL) /*!< Clear on write. */
Nrf51_bitfields.h (nrf51822\include):#define SPIS_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of the clock. Shift serial data on trailing edge. */
Nrf51_bitfields.h (nrf51822\include):#define SPIS_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of the clock. Shift serial data on leading edge. */
Nrf51_bitfields.h (nrf51822\include):/* Description: Over-read character. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 7..0 : Over-read character. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 2 : Enable interrupt on READY event. */
Nrf51_bitfields.h (nrf51822\include):#define TWI_INTENSET_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
Nrf51_bitfields.h (nrf51822\include):#define TWI_INTENSET_RXDREADY_Msk (0x1UL << TWI_INTENSET_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
Nrf51_bitfields.h (nrf51822\include):#define TWI_INTENSET_RXDREADY_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define TWI_INTENSET_RXDREADY_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define TWI_INTENSET_RXDREADY_Set (1UL) /*!< Enable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 2 : Disable interrupt on RXDREADY event. */
Nrf51_bitfields.h (nrf51822\include):#define TWI_INTENCLR_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
Nrf51_bitfields.h (nrf51822\include):#define TWI_INTENCLR_RXDREADY_Msk (0x1UL << TWI_INTENCLR_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
Nrf51_bitfields.h (nrf51822\include):#define TWI_INTENCLR_RXDREADY_Disabled (0UL) /*!< Interrupt disabled. */
Nrf51_bitfields.h (nrf51822\include):#define TWI_INTENCLR_RXDREADY_Enabled (1UL) /*!< Interrupt enabled. */
Nrf51_bitfields.h (nrf51822\include):#define TWI_INTENCLR_RXDREADY_Clear (1UL) /*!< Disable interrupt on write. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 1 : NACK received after sending the address. */
Nrf51_bitfields.h (nrf51822\include):/* Register: TWI_ADDRESS */
Nrf51_bitfields.h (nrf51822\include):/* Description: Address used in the two-wire transfer. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 6..0 : Two-wire address. */
Nrf51_bitfields.h (nrf51822\include):#define TWI_ADDRESS_ADDRESS_Pos (0UL) /*!< Position of ADDRESS field. */
Nrf51_bitfields.h (nrf51822\include):#define TWI_ADDRESS_ADDRESS_Msk (0x7FUL << TWI_ADDRESS_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
Nrf51_bitfields.h (nrf51822\include):/* Bit 1 : A character with bad parity is received. Only checked if HW parity control is enabled. */
Nrf51_bitfields.h (nrf51822\include):/* Description: RXD register. On read action the buffer pointer is displaced. Once read the character is consummed. If read when no character available, the UART will stop working. */
Nrf51_bitfields.h (nrf51822\include):/* Description: Readback protection configuration. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 15..8 : Readback protect all code in the device. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 7..0 : Readback protect region 0. Will be ignored if pre-programmed factory code is present on the chip. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 15..0 : Identification number for the firmware loaded into the chip. */
Nrf51_bitfields.h (nrf51822\include):#define WDT_REQSTATUS_RR7_DisabledOrRequested (0UL) /*!< RR[7] register is not enabled or has already requested reload. */
Nrf51_bitfields.h (nrf51822\include):#define WDT_REQSTATUS_RR6_DisabledOrRequested (0UL) /*!< RR[6] register is not enabled or has already requested reload. */
Nrf51_bitfields.h (nrf51822\include):#define WDT_REQSTATUS_RR5_DisabledOrRequested (0UL) /*!< RR[5] register is not enabled or has already requested reload. */
Nrf51_bitfields.h (nrf51822\include):#define WDT_REQSTATUS_RR4_DisabledOrRequested (0UL) /*!< RR[4] register is not enabled or has already requested reload. */
Nrf51_bitfields.h (nrf51822\include):#define WDT_REQSTATUS_RR3_DisabledOrRequested (0UL) /*!< RR[3] register is not enabled or has already requested reload. */
Nrf51_bitfields.h (nrf51822\include):#define WDT_REQSTATUS_RR2_DisabledOrRequested (0UL) /*!< RR[2] register is not enabled or has already requested reload. */
Nrf51_bitfields.h (nrf51822\include):#define WDT_REQSTATUS_RR1_DisabledOrRequested (0UL) /*!< RR[1] register is not enabled or has already requested reload. */
Nrf51_bitfields.h (nrf51822\include):#define WDT_REQSTATUS_RR0_DisabledOrRequested (0UL) /*!< RR[0] register is not enabled or has already requested reload. */
Nrf51_bitfields.h (nrf51822\include):/* Description: Reload request enable. */
Nrf51_bitfields.h (nrf51822\include):/* Description: Reload requests registers. */
Nrf51_bitfields.h (nrf51822\include):/* Bits 31..0 : Reload register. */
Nrf51_bitfields.h (nrf51822\include):#define WDT_RR_RR_Reload (0x6E524635UL) /*!< Value to request a reload of the watchdog timer. */
Nrf51_deprecated.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf51_deprecated.h (nrf51822\include):/* This file is given to prevent your SW from not compiling with the updates made to nrf51.h and 
Nrf51_deprecated.h (nrf51822\include): * macros on purpose. Use the ones defined in nrf51.h and nrf51_bitfields.h instead.
Nrf51_deprecated.h (nrf51822\include):#define DEVICEADDR0       DEVICEADDR[0]                   /*!< Device address, bits 31..0.                                           */
Nrf51_deprecated.h (nrf51822\include):#define DEVICEADDR1       DEVICEADDR[1]                   /*!< Device address, bits 63..32.                                          */
Nrf51_deprecated.h (nrf51822\include):#define RADIO_TXPOWER_TXPOWER_Neg40dBm  RADIO_TXPOWER_TXPOWER_Neg30dBm  /*!< -30dBm. */
nRF6350.c (nrf51822\source\ext_sensors\nrf6350): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):#define DDRAM_ADR     0x80      //!< Write to DDRAM AC
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):#define LCD_ADDR      0x3E      //!< LCD display adr
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):#define JS_ADDR       0x3F      //!< Joystick adr
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  return twi_master_transfer(LCD_ADDR << 1, data_buffer, 2, TWI_ISSUE_STOP);
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  data_buffer[1] = (uint8_t)(DDRAM_ADR + LCD_UPPER_LINE);
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  if (!twi_master_transfer(LCD_ADDR << 1, data_buffer, 2, TWI_ISSUE_STOP))
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  if (!twi_master_transfer(LCD_ADDR << 1, empty_str, 18, TWI_ISSUE_STOP))
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  data_buffer[1] = DDRAM_ADR + LCD_LOWER_LINE;
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  if (!twi_master_transfer(LCD_ADDR << 1, data_buffer, 2, TWI_ISSUE_STOP))
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  if (!twi_master_transfer(LCD_ADDR << 1, empty_str, 18, TWI_ISSUE_STOP))
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  return twi_master_transfer(LCD_ADDR << 1, data_buffer, 2, TWI_ISSUE_STOP);
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  return twi_master_transfer(LCD_ADDR << 1, data_buffer, 2, TWI_ISSUE_STOP);
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  return twi_master_transfer(LCD_ADDR << 1, data_buffer, 2, TWI_ISSUE_STOP);
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  data_buffer[1] = DDRAM_ADR + (pos + line);
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  if (!twi_master_transfer(LCD_ADDR << 1, data_buffer, 2, TWI_ISSUE_STOP))
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  if (!twi_master_transfer(LCD_ADDR << 1, empty_str, 18 - pos, TWI_ISSUE_STOP))
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  data_buffer[1] = DDRAM_ADR + (pos + line);
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  if (!twi_master_transfer(LCD_ADDR << 1, data_buffer, 2, TWI_ISSUE_STOP))
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  return twi_master_transfer(LCD_ADDR << 1, data_buffer, i+1, TWI_ISSUE_STOP);
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  if (!twi_master_transfer(JS_ADDR << 1 | TWI_READ_BIT, data_buffer, 1, TWI_ISSUE_STOP))
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  if(!twi_master_transfer(JS_ADDR << 1 | TWI_READ_BIT, &js_data, 1, TWI_ISSUE_STOP))
nRF6350.c (nrf51822\source\ext_sensors\nrf6350): *          returns false on timeout instead of attempting to recover.
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  uint8_t address           = (LCD_ADDR << 1);
nRF6350.c (nrf51822\source\ext_sensors\nrf6350):  NRF_TWI1->ADDRESS = (address >> 1);
nRF6350.h (nrf51822\include\ext_sensors): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
nRF6350.h (nrf51822\include\ext_sensors): * @brief Function for adjusting the contrast of the LCD-display, select between
Nrf_assert.c (nrf51822\source\nrf_assert): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_assert.h (nrf51822\include): * All hardware is put into an idle non-emitting state (in particular the radio is highly
Nrf_assert.h (nrf51822\include): * important to switch off since the radio might be in a state that makes it send
Nrf_delay.c (nrf51822\source\nrf_delay): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_ecb.c (nrf51822\source\nrf_ecb):* WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_ecb.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_ecb.h (nrf51822\include): * @param key Pointer to key. 16 bytes will be read.
Nrf_error.h (nrf51822\include\ble\softdevice):/* Header guard */
Nrf_error.h (nrf51822\include\ble\softdevice):#define NRF_ERROR_INVALID_ADDR                (NRF_ERROR_BASE_NUM + 16) ///< Bad Memory Address
Nrf_error_sdm.h (nrf51822\include\ble\softdevice):  @addtogroup nrf_sdm_api
Nrf_error_sdm.h (nrf51822\include\ble\softdevice):/* Header guard */
Nrf_error_soc.h (nrf51822\include\ble\softdevice):  @addtogroup nrf_soc_api
Nrf_error_soc.h (nrf51822\include\ble\softdevice):/* Header guard */
Nrf_error_soc.h (nrf51822\include\ble\softdevice):#define NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN                 (NRF_ERROR_SOC_BASE_NUM + 0)  ///< Mutex already taken
Nrf_esb.h (nrf51822\include\esb): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_esb.h (nrf51822\include\esb): * @enum nrf_esb_base_address_length_t
Nrf_esb.h (nrf51822\include\esb): * @brief Enumerator used for selecting the base address length.
Nrf_esb.h (nrf51822\include\esb):    NRF_ESB_BASE_ADDRESS_LENGTH_2B,   ///< 2 byte address length
Nrf_esb.h (nrf51822\include\esb):    NRF_ESB_BASE_ADDRESS_LENGTH_3B,   ///< 3 byte address length
Nrf_esb.h (nrf51822\include\esb):    NRF_ESB_BASE_ADDRESS_LENGTH_4B    ///< 4 byte address length
Nrf_esb.h (nrf51822\include\esb):} nrf_esb_base_address_length_t;
Nrf_esb.h (nrf51822\include\esb): * @brief Enumerator used for selecting the radio data rate.
Nrf_esb.h (nrf51822\include\esb): * are being added to the internal notification queue while ESB is disabling,
Nrf_esb.h (nrf51822\include\esb): * In PRX mode this function is called after a payload in ACK is assumed
Nrf_esb.h (nrf51822\include\esb): * payload.
Nrf_esb.h (nrf51822\include\esb): * - Payload length = 0
Nrf_esb.h (nrf51822\include\esb): * always made after sending a packet. 
Nrf_esb.h (nrf51822\include\esb): * @brief RX data ready callback.
Nrf_esb.h (nrf51822\include\esb): * payload.
Nrf_esb.h (nrf51822\include\esb): * received from a PRX containing a payload. 
Nrf_esb.h (nrf51822\include\esb): * - Payload length = 0
Nrf_esb.h (nrf51822\include\esb):void nrf_esb_rx_data_ready(uint32_t rx_pipe, int32_t rssi);
Nrf_esb.h (nrf51822\include\esb): * There is no further CPU use by ESB, the radio is disabled and the timer is 
Nrf_esb.h (nrf51822\include\esb): * @brief Add a packet to the tail of the TX FIFO. 
Nrf_esb.h (nrf51822\include\esb): * In PRX mode, the payload will be piggybacked to onto an ACK. 
Nrf_esb.h (nrf51822\include\esb): * @param payload        Pointer to the payload. 
Nrf_esb.h (nrf51822\include\esb): * @param payload_length The number of bytes of the payload to transmit. 
Nrf_esb.h (nrf51822\include\esb): * @param pipe           The pipe for which to add the payload. This value must be < NRF_ESB_CONST_PIPE_COUNT.
Nrf_esb.h (nrf51822\include\esb): * @retval true  If the packet was successfully added to the TX FIFO.
Nrf_esb.h (nrf51822\include\esb): * @retval false If pipe was invalid, payload pointer was NULL, payload length
Nrf_esb.h (nrf51822\include\esb):bool nrf_esb_add_packet_to_tx_fifo(uint32_t pipe, uint8_t * payload, uint32_t payload_length, nrf_esb_packet_t packet_type);
Nrf_esb.h (nrf51822\include\esb): * @brief Fetch a packet from the head of the RX FIFO. 
Nrf_esb.h (nrf51822\include\esb): * @param payload        Pointer to copy the payload to. 
Nrf_esb.h (nrf51822\include\esb): * @param payload_length Pointer to copy the payload length to. The 
Nrf_esb.h (nrf51822\include\esb): * payload length is given in bytes (0 to NRF_ESB_CONST_MAX_PAYLOAD_LENGTH).
Nrf_esb.h (nrf51822\include\esb): * @param pipe           Pipe for which to add the payload. This value must be < NRF_ESB_CONST_PIPE_COUNT.
Nrf_esb.h (nrf51822\include\esb): * @retval false If there was no packet in the FIFO or the payload pointer
Nrf_esb.h (nrf51822\include\esb):bool nrf_esb_fetch_packet_from_rx_fifo(uint32_t pipe, uint8_t * payload, uint32_t* payload_length);
Nrf_esb.h (nrf51822\include\esb): * nrf_esb_tx_data_sent callback was made.
Nrf_esb.h (nrf51822\include\esb): * @brief Set the base address length.
Nrf_esb.h (nrf51822\include\esb): * @param length The base address length.
Nrf_esb.h (nrf51822\include\esb): * @retval true  If the address length was set.
Nrf_esb.h (nrf51822\include\esb):bool nrf_esb_set_base_address_length(nrf_esb_base_address_length_t length);
Nrf_esb.h (nrf51822\include\esb): * @brief Get function counterpart to nrf_esb_set_base_address_length().
Nrf_esb.h (nrf51822\include\esb): * @return The current base_address length. 
Nrf_esb.h (nrf51822\include\esb):nrf_esb_base_address_length_t nrf_esb_get_base_address_length(void);
Nrf_esb.h (nrf51822\include\esb): * @brief Set the base address for pipe 0.
Nrf_esb.h (nrf51822\include\esb): * The full on-air address for each pipe is composed of a multi-byte base address
Nrf_esb.h (nrf51822\include\esb): * and a prefix address byte. 
Nrf_esb.h (nrf51822\include\esb): * the base address should not be an alternating sequence of 0s and 1s i.e. 
Nrf_esb.h (nrf51822\include\esb): * @param base_address is the 4 byte base address. The parameter is
Nrf_esb.h (nrf51822\include\esb): * set by nrf_esb_set_base_address_length().
Nrf_esb.h (nrf51822\include\esb): * @retval true if base_address_0 was set.
Nrf_esb.h (nrf51822\include\esb):bool nrf_esb_set_base_address_0(uint32_t base_address);
Nrf_esb.h (nrf51822\include\esb): * @brief Get function counterpart to nrf_esb_set_base_address_0().
Nrf_esb.h (nrf51822\include\esb): * @return Base address 0.
Nrf_esb.h (nrf51822\include\esb):uint32_t nrf_esb_get_base_address_0(void);
Nrf_esb.h (nrf51822\include\esb): * @brief Set the base address for pipes 1-7.
Nrf_esb.h (nrf51822\include\esb): * Pipes 1 through 7 share base_address_1. @sa nrf_esb_set_base_address_0.
Nrf_esb.h (nrf51822\include\esb): * @param base_address is the 4 byte base address. The parameter is
Nrf_esb.h (nrf51822\include\esb): * set by nrf_esb_set_base_address_length().
Nrf_esb.h (nrf51822\include\esb): * @retval true If base_address_1 was set.
Nrf_esb.h (nrf51822\include\esb):bool nrf_esb_set_base_address_1(uint32_t base_address);
Nrf_esb.h (nrf51822\include\esb): * @brief Get function counterpart to nrf_esb_set_base_address_1().
Nrf_esb.h (nrf51822\include\esb): * @return Base address 1.
Nrf_esb.h (nrf51822\include\esb):uint32_t nrf_esb_get_base_address_1(void);
Nrf_esb.h (nrf51822\include\esb): * @brief Set the address prefix byte for a specific pipe.
Nrf_esb.h (nrf51822\include\esb): * @param pipe The pipe that the address should apply to. This value must be < NRF_ESB_CONST_PIPE_COUNT.
Nrf_esb.h (nrf51822\include\esb): * @param address The address prefix byte.
Nrf_esb.h (nrf51822\include\esb): * @retval true If the address prefix byte was set.
Nrf_esb.h (nrf51822\include\esb):bool nrf_esb_set_address_prefix_byte(uint32_t pipe, uint8_t address);
Nrf_esb.h (nrf51822\include\esb): * @brief Get function counterpart to nrf_esb_set_address_prefix_byte().
Nrf_esb.h (nrf51822\include\esb): * @param pipe the pipe for which to get the address. This value must be < NRF_ESB_CONST_PIPE_COUNT.
Nrf_esb.h (nrf51822\include\esb): * @param out_address is the pointer in which to return the address byte.
Nrf_esb.h (nrf51822\include\esb): *               or the out_address pointer was NULL.
Nrf_esb.h (nrf51822\include\esb):bool nrf_esb_get_address_prefix_byte(uint32_t pipe, uint8_t* out_address);
Nrf_esb.h (nrf51822\include\esb): * radio data rate and the payload size(s).(@sa nrf_esb_set_datarate()). 
Nrf_esb.h (nrf51822\include\esb): * As a rule of thumb, when using 32 byte payloads in each direction (forward and ACK):
Nrf_esb.h (nrf51822\include\esb): * @brief Set the Radio Frequency (RF) channel.
Nrf_esb.h (nrf51822\include\esb): * @brief Set the radio TX output power.
Nrf_esb.h (nrf51822\include\esb): * @brief Set the radio datarate.
Nrf_esb.h (nrf51822\include\esb): * the XOSC will only be running when needed, that is when the radio
Nrf_esb.h (nrf51822\include\esb): * It is required that the XOSC is started in order for the radio to be
Nrf_esb.h (nrf51822\include\esb): * parameter in the nrf_esb_add_packet_to_tx_fifo() function to have any effect,
Nrf_esb_constants.h (nrf51822\include\esb): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_esb_constants.h (nrf51822\include\esb): * @addtogroup esb_02_api
Nrf_esb_constants.h (nrf51822\include\esb):#define NRF_ESB_HIGH_IRQ_PRIORITY 0        ///< Interrupt priority the ESB timer and the radio
Nrf_esb_constants.h (nrf51822\include\esb):// In addition, ESB uses the radio peripheral and radio interrupts.
Nrf_esb_constants.h (nrf51822\include\esb):#define NRF_ESB_CONST_MAX_PAYLOAD_LENGTH 32     ///< Maximum allowed payload length in bytes. 
Nrf_esb_constants.h (nrf51822\include\esb):#define NRF_ESB_CONST_MAX_PAYLOAD_LENGTH 32     ///< Maximum allowed payload length in bytes. 
Nrf_esb_constants.h (nrf51822\include\esb):Corresponds to Legacy nRFgo SDK ESB addresses:
Nrf_esb_constants.h (nrf51822\include\esb):Address pipe 0  {0xE7, 0xE7, 0xE7, 0xE7, 0xE7}
Nrf_esb_constants.h (nrf51822\include\esb):Address pipe 1  {0xC2, 0xC2, 0xC2, 0xC2, 0xC2}
Nrf_esb_constants.h (nrf51822\include\esb):Address pipe 2  {0xC3, 0xC2, 0xC2, 0xC2, 0xC2}
Nrf_esb_constants.h (nrf51822\include\esb):Address pipe 3  {0xC4, 0xC2, 0xC2, 0xC2, 0xC2}
Nrf_esb_constants.h (nrf51822\include\esb):#define NRF_ESB_DEFAULT_BASE_ADDRESS_0 0xE7E7E7E7                  ///< Default base address 0.
Nrf_esb_constants.h (nrf51822\include\esb):#define NRF_ESB_DEFAULT_BASE_ADDRESS_1 0xC2C2C2C2                  ///< Default base address 1.
Nrf_esb_constants.h (nrf51822\include\esb):#define NRF_ESB_DEFAULT_PREFIX_BYTE_0 0xE7                         ///< Default prefix address pipe 0.    
Nrf_esb_constants.h (nrf51822\include\esb):#define NRF_ESB_DEFAULT_PREFIX_BYTE_1 0xC2                         ///< Default prefix address pipe 1.
Nrf_esb_constants.h (nrf51822\include\esb):#define NRF_ESB_DEFAULT_PREFIX_BYTE_2 0xC3                         ///< Default prefix address pipe 2.
Nrf_esb_constants.h (nrf51822\include\esb):#define NRF_ESB_DEFAULT_PREFIX_BYTE_3 0xC4                         ///< Default prefix address pipe 3.
Nrf_esb_constants.h (nrf51822\include\esb):#define NRF_ESB_DEFAULT_PREFIX_BYTE_4 0xC5                         ///< Default prefix address pipe 4.
Nrf_esb_constants.h (nrf51822\include\esb):#define NRF_ESB_DEFAULT_PREFIX_BYTE_5 0xC6                         ///< Default prefix address pipe 5.
Nrf_esb_constants.h (nrf51822\include\esb):#define NRF_ESB_DEFAULT_PREFIX_BYTE_6 0xC7                         ///< Default prefix address pipe 6.
Nrf_esb_constants.h (nrf51822\include\esb):#define NRF_ESB_DEFAULT_PREFIX_BYTE_7 0xC8                         ///< Default prefix address pipe 7.
Nrf_esb_constants.h (nrf51822\include\esb):#define NRF_ESB_DEFAULT_BASE_ADDRESS_LENGTH NRF_ESB_BASE_ADDRESS_LENGTH_4B  ///< Default on-air base address length.
Nrf_gpio.h (nrf51822\include): * @brief GPIO pin abstraction and port abstraction for reading and writing byte-wise to GPIO ports.
Nrf_gpio.h (nrf51822\include): *        Sense capability on the pin is disabled, and input is connected to buffer so that the GPIO->IN register is readable
Nrf_gpio.h (nrf51822\include): * @note  Sense capability on the pin is disabled, and input is connected to buffer so that the GPIO->IN register is readable
Nrf_gpio.h (nrf51822\include): * @brief Function for reading the input level of a GPIO pin.
Nrf_gpio.h (nrf51822\include): * read.
Nrf_gpio.h (nrf51822\include):static __INLINE uint32_t nrf_gpio_pin_read(uint32_t pin_number)
Nrf_gpio.h (nrf51822\include): * address.
Nrf_gpio.h (nrf51822\include): * @param word_address is the address of the word to be written.
Nrf_gpio.h (nrf51822\include): * at address "word_address"
Nrf_gpio.h (nrf51822\include):static __INLINE void nrf_gpio_word_byte_write(volatile uint32_t * word_address, uint8_t byte_no, uint8_t value)
Nrf_gpio.h (nrf51822\include):    *((volatile uint8_t*)(word_address) + byte_no) = value;
Nrf_gpio.h (nrf51822\include): * @brief Generic function for reading a single byte of a 32 bit word at a given
Nrf_gpio.h (nrf51822\include): * address.
Nrf_gpio.h (nrf51822\include): * @param word_address is the address of the word to be read.
Nrf_gpio.h (nrf51822\include): * @param byte_no is the the byte number (0-3) of the word to be read.
Nrf_gpio.h (nrf51822\include): * @return byte "byte_no" of word at address "word_address".
Nrf_gpio.h (nrf51822\include):static __INLINE uint8_t nrf_gpio_word_byte_read(const volatile uint32_t* word_address, uint8_t byte_no)
Nrf_gpio.h (nrf51822\include):    return (*((const volatile uint8_t*)(word_address) + byte_no));
Nrf_gpio.h (nrf51822\include): * @brief Function for reading a GPIO port.
Nrf_gpio.h (nrf51822\include): * @param port is the port to read.
Nrf_gpio.h (nrf51822\include):static __INLINE uint8_t nrf_gpio_port_read(nrf_gpio_port_select_t port)
Nrf_gpio.h (nrf51822\include):    return nrf_gpio_word_byte_read(&NRF_GPIO->IN, port);
Nrf_gpiote.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_gpiote.h (nrf51822\include):        on the GPIO if the GPIO in question is already assigned to GPIOTE and the pin is in the 
Nrf_gpiote.h (nrf51822\include):        on the GPIO if the GPIO in question is already assigned to GPIOTE and the pin is in the 
Nrf_gzll.h (nrf51822\include\gzll): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_gzll.h (nrf51822\include\gzll): * @brief Enumerator used for selecting the radio datarate.
Nrf_gzll.h (nrf51822\include\gzll):  ///< A call to a configuration 'set' function was made while Gazell was 
Nrf_gzll.h (nrf51822\include\gzll):  NRF_GZLL_ERROR_CODE_INVALID_PAYLOAD_LENGTH              =  6,
Nrf_gzll.h (nrf51822\include\gzll):  ///< An invalid payload length was given as an input to a function.
Nrf_gzll.h (nrf51822\include\gzll):  NRF_GZLL_ERROR_CODE_ATTEMPTED_TO_ADD_TO_FULL_FIFO     =  9,
Nrf_gzll.h (nrf51822\include\gzll):  bool payload_received_in_ack;   
Nrf_gzll.h (nrf51822\include\gzll):  ///<  A payload was received in the ACK.
Nrf_gzll.h (nrf51822\include\gzll):  ///<  A payload was received in the ACK.
Nrf_gzll.h (nrf51822\include\gzll): * being added to the internal notification queue while Gazell is disabling,
Nrf_gzll.h (nrf51822\include\gzll): * This callback is made when the Device receives an ACK (acknowledgement) 
Nrf_gzll.h (nrf51822\include\gzll): * @sa nrf_gzll_ack_payload_received.
Nrf_gzll.h (nrf51822\include\gzll): * @param tx_info struct used to indicate whether a payload was received in the
Nrf_gzll.h (nrf51822\include\gzll): * This callback is made when a packet does not receive an ACK after
Nrf_gzll.h (nrf51822\include\gzll): * @param tx_info struct used to indicate whether a payload was received 
Nrf_gzll.h (nrf51822\include\gzll): * This callback is made when a Host receives a data packet from a Device. 
Nrf_gzll.h (nrf51822\include\gzll): * @param rx_info struct used to indicate whether a payload was removed from the
Nrf_gzll.h (nrf51822\include\gzll):void nrf_gzll_host_rx_data_ready(uint32_t pipe, nrf_gzll_host_rx_info_t rx_info);
Nrf_gzll.h (nrf51822\include\gzll): * There is no further CPU use by Gazell, the radio is disabled and the timer is 
Nrf_gzll.h (nrf51822\include\gzll): * @brief Add a packet to the tail of the TX FIFO. 
Nrf_gzll.h (nrf51822\include\gzll): * In Device mode, the packet will be added. 
Nrf_gzll.h (nrf51822\include\gzll): * In Host mode, the payload will be piggybacked onto an ACK. 
Nrf_gzll.h (nrf51822\include\gzll): * @param pipe    Pipe to which to add the payload. This value must be < NRF_GZLL_CONST_PIPE_COUNT.
Nrf_gzll.h (nrf51822\include\gzll): * @param payload Pointer to the payload. 
Nrf_gzll.h (nrf51822\include\gzll): * @param length  Number of bytes of the payload to transmit 
Nrf_gzll.h (nrf51822\include\gzll): *                (0 to NRF_GZLL_CONST_MAX_PAYLOAD_LENGTH).
Nrf_gzll.h (nrf51822\include\gzll): * @retval true  if the packet was successfully added to the TX FIFO.
Nrf_gzll.h (nrf51822\include\gzll):bool nrf_gzll_add_packet_to_tx_fifo(uint32_t pipe, uint8_t * payload, uint32_t length);
Nrf_gzll.h (nrf51822\include\gzll): * @brief Fetch a packet from the head of the RX FIFO. 
Nrf_gzll.h (nrf51822\include\gzll): * @param pipe    Pipe from which to fetch the payload. This value must be < NRF_GZLL_CONST_PIPE_COUNT.
Nrf_gzll.h (nrf51822\include\gzll): * @param payload Pointer to copy the payload to. 
Nrf_gzll.h (nrf51822\include\gzll): *                in the received payload length. 
Nrf_gzll.h (nrf51822\include\gzll):bool nrf_gzll_fetch_packet_from_rx_fifo(uint32_t pipe, uint8_t * payload, uint32_t* length);
Nrf_gzll.h (nrf51822\include\gzll): * @brief Check if adding a packet to a pipe's TX FIFO should be successful.
Nrf_gzll.h (nrf51822\include\gzll):bool nrf_gzll_ok_to_add_packet_to_tx_fifo(uint32_t pipe);
Nrf_gzll.h (nrf51822\include\gzll): * @brief Set the base address for pipe 0.
Nrf_gzll.h (nrf51822\include\gzll): * The full on-air address for each pipe is composed of a multi-byte base address
Nrf_gzll.h (nrf51822\include\gzll): * the base address should not be an alternating sequence of 0s and 1s i.e. 
Nrf_gzll.h (nrf51822\include\gzll): * @param base_address The 4 byte base address. All bytes are used.
Nrf_gzll.h (nrf51822\include\gzll):bool nrf_gzll_set_base_address_0(uint32_t base_address);
Nrf_gzll.h (nrf51822\include\gzll): * @brief Get function counterpart to nrf_gzll_set_base_address_0().
Nrf_gzll.h (nrf51822\include\gzll): * @return Base address 0.
Nrf_gzll.h (nrf51822\include\gzll):uint32_t nrf_gzll_get_base_address_0(void);
Nrf_gzll.h (nrf51822\include\gzll): * @brief Set the base address for pipes 1-7.
Nrf_gzll.h (nrf51822\include\gzll): * Pipes 1 through 7 share base_address_1. @sa nrf_gzll_set_base_address_0.
Nrf_gzll.h (nrf51822\include\gzll): * @param base_address The 4 byte base address.
Nrf_gzll.h (nrf51822\include\gzll):bool nrf_gzll_set_base_address_1(uint32_t base_address);
Nrf_gzll.h (nrf51822\include\gzll): * @brief Get function counterpart to nrf_gzll_set_base_address_1().
Nrf_gzll.h (nrf51822\include\gzll): * @return Base address 1.
Nrf_gzll.h (nrf51822\include\gzll):uint32_t nrf_gzll_get_base_address_1(void);
Nrf_gzll.h (nrf51822\include\gzll): * @brief Set the address prefix byte for a specific pipe.
Nrf_gzll.h (nrf51822\include\gzll): * @param pipe                The pipe that the address should apply to.
Nrf_gzll.h (nrf51822\include\gzll): * @param address_prefix_byte The address prefix byte.
Nrf_gzll.h (nrf51822\include\gzll):bool nrf_gzll_set_address_prefix_byte(uint32_t pipe, uint8_t address_prefix_byte);
Nrf_gzll.h (nrf51822\include\gzll): * @brief Get function counterpart to nrf_gzll_set_address_prefix_byte().
Nrf_gzll.h (nrf51822\include\gzll): * @param pipe                    The pipe for which to get the address.
Nrf_gzll.h (nrf51822\include\gzll): * @param out_address_prefix_byte The pointer in which to return the 
Nrf_gzll.h (nrf51822\include\gzll): *                                address prefix byte.
Nrf_gzll.h (nrf51822\include\gzll): *               out_address was a NULL pointer.
Nrf_gzll.h (nrf51822\include\gzll):bool nrf_gzll_get_address_prefix_byte(uint32_t pipe, uint8_t* out_address_prefix_byte);
Nrf_gzll.h (nrf51822\include\gzll): * radio data rate (@sa nrf_gzll_set_datarate()).
Nrf_gzll.h (nrf51822\include\gzll): * transmission should overlap to adjacent timeslots on the Host. 
Nrf_gzll.h (nrf51822\include\gzll): * @brief Set the table of Radio Frequency (RF) channels.
Nrf_gzll.h (nrf51822\include\gzll): * @brief Get the table of Radio Frequency (RF) channels.
Nrf_gzll.h (nrf51822\include\gzll): *                      The value already at size must be at least the size
Nrf_gzll.h (nrf51822\include\gzll): * @brief Set the radio TX power.
Nrf_gzll.h (nrf51822\include\gzll): * @brief Set the radio datarate.
Nrf_gzll.h (nrf51822\include\gzll): * the XOSC will only be running when needed, that is when the radio
Nrf_gzll.h (nrf51822\include\gzll): * It is required that the XOSC is started in order for the radio to be
Nrf_gzll.h (nrf51822\include\gzll): * @brief Clear the internal timeslot tick count variable that is read
Nrf_gzll_constants.h (nrf51822\include\gzll): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_gzll_constants.h (nrf51822\include\gzll): * @addtogroup gzll_02_api
Nrf_gzll_constants.h (nrf51822\include\gzll):#define NRF_GZLL_HIGH_IRQ_PRIORITY 0        ///< Interrupt priority the Gazell timer and the radio
Nrf_gzll_constants.h (nrf51822\include\gzll):// In addition, Gazell uses the radio peripheral and radio interrupts.
Nrf_gzll_constants.h (nrf51822\include\gzll):#define NRF_GZLL_CONST_MAX_PAYLOAD_LENGTH 32        ///< Maximum allowed payload length in bytes. 
Nrf_gzll_constants.h (nrf51822\include\gzll):#define NRF_GZLL_CONST_MAX_PAYLOAD_LENGTH 32        ///< Maximum allowed payload length in bytes. 
Nrf_gzll_constants.h (nrf51822\include\gzll):/** @name Default radio configuration */
Nrf_gzll_constants.h (nrf51822\include\gzll):/** @name Default Address configuration */
Nrf_gzll_constants.h (nrf51822\include\gzll):#define GZLL_DEFAULT_ADDRESS_PIPE0 {0x01, 0x04, 0x07, 0x0A, 0x0D} // {1, 4, 7, 10, 13}          
Nrf_gzll_constants.h (nrf51822\include\gzll):#define GZLL_DEFAULT_ADDRESS_PIPE1 {0x02, 0x05, 0x08, 0x0B, 0x0E} // {2, 5, 8, 11, 14}      
Nrf_gzll_constants.h (nrf51822\include\gzll):#define GZLL_DEFAULT_ADDRESS_PIPE2 3                       
Nrf_gzll_constants.h (nrf51822\include\gzll):#define GZLL_DEFAULT_ADDRESS_PIPE3 4                        
Nrf_gzll_constants.h (nrf51822\include\gzll):#define GZLL_DEFAULT_ADDRESS_PIPE4 5                        
Nrf_gzll_constants.h (nrf51822\include\gzll):#define GZLL_DEFAULT_ADDRESS_PIPE5 6
Nrf_gzll_constants.h (nrf51822\include\gzll):#define NRF_GZLL_DEFAULT_FULL_ADDRESS_PIPE0 {0x01, 0x04, 0x07, 0x0A, 0x0D} ///< Corresponding legacy Gazell pipe 0 address.
Nrf_gzll_constants.h (nrf51822\include\gzll):#define NRF_GZLL_DEFAULT_BASE_ADDRESS_0 0x0D0A0704  ///< Default base address 0.
Nrf_gzll_constants.h (nrf51822\include\gzll):#define NRF_GZLL_DEFAULT_BASE_ADDRESS_1 0x0E0B0805  ///< Default base address 1.
Nrf_gzll_constants.h (nrf51822\include\gzll):#define NRF_GZLL_DEFAULT_PREFIX_BYTE_0 1            ///< Default prefix address pipe 0.    
Nrf_gzll_constants.h (nrf51822\include\gzll):#define NRF_GZLL_DEFAULT_PREFIX_BYTE_1 2            ///< Default prefix address pipe 1.
Nrf_gzll_constants.h (nrf51822\include\gzll):#define NRF_GZLL_DEFAULT_PREFIX_BYTE_2 3            ///< Default prefix address pipe 2.
Nrf_gzll_constants.h (nrf51822\include\gzll):#define NRF_GZLL_DEFAULT_PREFIX_BYTE_3 4            ///< Default prefix address pipe 3.
Nrf_gzll_constants.h (nrf51822\include\gzll):#define NRF_GZLL_DEFAULT_PREFIX_BYTE_4 5            ///< Default prefix address pipe 4.
Nrf_gzll_constants.h (nrf51822\include\gzll):#define NRF_GZLL_DEFAULT_PREFIX_BYTE_5 6            ///< Default prefix address pipe 5.
Nrf_gzll_constants.h (nrf51822\include\gzll):#define NRF_GZLL_DEFAULT_PREFIX_BYTE_6 7            ///< Default prefix address pipe 6.
Nrf_gzll_constants.h (nrf51822\include\gzll):#define NRF_GZLL_DEFAULT_PREFIX_BYTE_7 8            ///< Default prefix address pipe 7.
Nrf_gzll_constants.h (nrf51822\include\gzll):#define NRF_GZLL_DEFAULT_BASE_ADDRESS_LENGTH NRF_GZLL_BASE_ADDRESS_LENGTH_4B  ///< Default on-air base address length.
Nrf_gzp.c (nrf51822\source\gzp): * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_gzp.c (nrf51822\source\gzp): * Constant holding base address part of the pairing address. 
Nrf_gzp.c (nrf51822\source\gzp):static const uint8_t pairing_base_address[4] = { GZP_ADDRESS }; 
Nrf_gzp.c (nrf51822\source\gzp): * Constant holding prefix byte of the pairing address.
Nrf_gzp.c (nrf51822\source\gzp):static const uint8_t pairing_address_prefix_byte = 0;            
Nrf_gzp.c (nrf51822\source\gzp):bool gzp_update_radio_params(const uint8_t* system_address)
Nrf_gzp.c (nrf51822\source\gzp):    uint32_t pairing_base_address_32, system_address_32;
Nrf_gzp.c (nrf51822\source\gzp):    // Configure "global" pairing address
Nrf_gzp.c (nrf51822\source\gzp):    pairing_base_address_32 = (pairing_base_address[0])       + 
Nrf_gzp.c (nrf51822\source\gzp):    ((uint32_t)pairing_base_address[1] <<  8) +
Nrf_gzp.c (nrf51822\source\gzp):    ((uint32_t)pairing_base_address[2] << 16) +
Nrf_gzp.c (nrf51822\source\gzp):    ((uint32_t)pairing_base_address[3] << 24) ;
Nrf_gzp.c (nrf51822\source\gzp):    if(system_address != NULL)
Nrf_gzp.c (nrf51822\source\gzp):        system_address_32 = (system_address[0])       + 
Nrf_gzp.c (nrf51822\source\gzp):        ((uint32_t)system_address[1] <<  8) +
Nrf_gzp.c (nrf51822\source\gzp):        ((uint32_t)system_address[2] << 16) +
Nrf_gzp.c (nrf51822\source\gzp):        ((uint32_t)system_address[3] << 24) ;
Nrf_gzp.c (nrf51822\source\gzp):    update_ok = update_ok && nrf_gzll_set_base_address_0(pairing_base_address_32);
Nrf_gzp.c (nrf51822\source\gzp):    update_ok = update_ok && nrf_gzll_set_address_prefix_byte(GZP_PAIRING_PIPE, pairing_address_prefix_byte);
Nrf_gzp.c (nrf51822\source\gzp):    update_ok = update_ok && nrf_gzll_set_base_address_1(system_address_32);
Nrf_gzp.c (nrf51822\source\gzp):    // Configure address for pipe 1 - 5. Address byte set to equal pipe number.
Nrf_gzp.c (nrf51822\source\gzp):        update_ok = update_ok && nrf_gzll_set_address_prefix_byte(i,i);
Nrf_gzp.c (nrf51822\source\gzp):    gzp_generate_channels(&channels[0], system_address, channel_table_size);
Nrf_gzp.c (nrf51822\source\gzp):void gzp_generate_channels(uint8_t* ch_dst, const uint8_t* system_address, uint8_t channel_tab_size)
Nrf_gzp.c (nrf51822\source\gzp):    if(system_address != NULL)
Nrf_gzp.c (nrf51822\source\gzp):            ch_dst[i] = (binsize * i) + (system_address[i % 4] % binsize);  
Nrf_gzp.c (nrf51822\source\gzp):void gzp_xor_cipher(uint8_t* dst, const uint8_t* src, const uint8_t* pad, uint8_t length)
Nrf_gzp.c (nrf51822\source\gzp):        *dst = *src ^ *pad;
Nrf_gzp.c (nrf51822\source\gzp):        pad++;
Nrf_gzp.c (nrf51822\source\gzp):void gzp_add_validation_id(uint8_t* dst)
Nrf_gzp.c (nrf51822\source\gzp):    static uint8_t dummy_packet[NRF_GZLL_CONST_MAX_PAYLOAD_LENGTH];
Nrf_gzp.c (nrf51822\source\gzp):        length = NRF_GZLL_CONST_MAX_PAYLOAD_LENGTH;
Nrf_gzp.h (nrf51822\include\gzp):* WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_SYSTEM_ADDRESS_WIDTH   4     ///< Must equal Gazell base address length.
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_CMD_HOST_ADDRESS_REQ_PAYLOAD_LENGTH 1   ///< "Host address request" packet, payload length
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_CMD_HOST_ADDRESS_FETCH_PAYLOAD_LENGTH 1 ///< "Host address fetch" packet, payload length
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_CMD_HOST_ID_REQ_PAYLOAD_LENGTH (GZP_CMD_HOST_ID_REQ_SESSION_TOKEN + GZP_SESSION_TOKEN_LENGTH)  ///< "Host ID request" payload length
Nrf_gzp.h (nrf51822\include\gzp):#if (GZP_CMD_HOST_ID_REQ_PAYLOAD_LENGTH > 17)
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_CMD_HOST_ID_FETCH_PAYLOAD_LENGTH (GZP_CMD_HOST_ID_FETCH_VALIDATION_ID + GZP_VALIDATION_ID_LENGTH) ///< "Host ID fetch" payload length
Nrf_gzp.h (nrf51822\include\gzp):#if (GZP_CMD_HOST_ID_FETCH_PAYLOAD_LENGTH > 17)
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_CMD_KEY_UPDATE_PREPARE_PAYLOAD_LENGTH 1   ///< "Key update prepare" payload length
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_CMD_KEY_UPDATE_PAYLOAD_LENGTH (GZP_CMD_KEY_UPDATE_NEW_KEY + GZP_DYN_KEY_LENGTH)       ///< "Key update" packet, payload length
Nrf_gzp.h (nrf51822\include\gzp):#if (GZP_CMD_KEY_UPDATE_PAYLOAD_LENGTH > 17)
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_CMD_ENCRYPTED_USER_DATA_PAYLOAD ((GZP_CMD_ENCRYPTED_USER_DATA_VALIDATION_ID + GZP_VALIDATION_ID_LENGTH)) ///< "Encrypted user data" packet, user data position
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_ENCRYPTED_USER_DATA_PACKET_OVERHEAD ( GZP_CMD_ENCRYPTED_USER_DATA_VALIDATION_ID + GZP_VALIDATION_ID_LENGTH)        ///< "Encrypted user data" packet, packet overhead length
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_ENCRYPTED_USER_DATA_MAX_LENGTH (17 - GZP_ENCRYPTED_USER_DATA_PACKET_OVERHEAD) ///< "Encrypted user data" packet, max payload length
Nrf_gzp.h (nrf51822\include\gzp):#if(GZP_MAX_FW_PAYLOAD_LENGTH < 17)
Nrf_gzp.h (nrf51822\include\gzp):  #error GZP_MAX_FW_PAYLOAD_LENGTH must be greater or equal to 17.
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_CMD_FETCH_RESP_PAYLOAD_LENGTH 1    ///< General "fetch response" packet, payload_length
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_CMD_HOST_ADDRESS_RESP_ADDRESS 1      ///< "Host address fetch" response packet, address position
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_CMD_HOST_ADDRESS_RESP_PAYLOAD_LENGTH (GZP_CMD_HOST_ADDRESS_RESP_ADDRESS + GZP_SYSTEM_ADDRESS_WIDTH) ///<  ///< "Host address fetch" response packet, payload length
Nrf_gzp.h (nrf51822\include\gzp):#if(GZP_MAX_ACK_PAYLOAD_LENGTH < GZP_CMD_HOST_ADDRESS_RESP_PAYLOAD_LENGTH)
Nrf_gzp.h (nrf51822\include\gzp):  #error GZP_MAX_ACK_PAYLOAD_LENGTH must be greater or equal to GZP_CMD_HOST_ADDRESS_RESP_PAYLOAD_LENGTH.
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_CMD_HOST_ID_FETCH_RESP_PAYLOAD_LENGTH (GZP_CMD_HOST_ID_FETCH_RESP_HOST_ID + GZP_HOST_ID_LENGTH)   ///< "Host ID fetch" response packet, payload length
Nrf_gzp.h (nrf51822\include\gzp):#if(GZP_MAX_ACK_PAYLOAD_LENGTH < GZP_CMD_HOST_ID_FETCH_RESP_PAYLOAD_LENGTH)
Nrf_gzp.h (nrf51822\include\gzp):  #error GZP_MAX_ACK_PAYLOAD_LENGTH must be greater or equal to GZP_CMD_HOST_ID_FETCH_RESP_PAYLOAD_LENGTH.
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_CMD_KEY_UPDATE_PREPARE_RESP_PAYLOAD_LENGTH (GZP_CMD_KEY_UPDATE_PREPARE_RESP_SESSION_TOKEN + GZP_SESSION_TOKEN_LENGTH) ///< "Key update prepare" response packet, payload length position
Nrf_gzp.h (nrf51822\include\gzp):#if(GZP_MAX_ACK_PAYLOAD_LENGTH < GZP_CMD_KEY_UPDATE_PREPARE_RESP_PAYLOAD_LENGTH)
Nrf_gzp.h (nrf51822\include\gzp):  #error GZP_MAX_ACK_PAYLOAD_LENGTH must be greater or equal to GZP_CMD_KEY_UPDATE_PREPARE_RESP_PAYLOAD_LENGTH.
Nrf_gzp.h (nrf51822\include\gzp):#define GZP_CMD_ENCRYPTED_USER_DATA_RESP_PAYLOAD_LENGTH (GZP_CMD_ENCRYPTED_USER_DATA_RESP_VALIDATION_ID + GZP_VALIDATION_ID_LENGTH) ///< "Encrypted user data" response packet, payload length position
Nrf_gzp.h (nrf51822\include\gzp):#if(GZP_MAX_ACK_PAYLOAD_LENGTH < GZP_CMD_ENCRYPTED_USER_DATA_RESP_PAYLOAD_LENGTH)
Nrf_gzp.h (nrf51822\include\gzp):  #error GZP_MAX_ACK_PAYLOAD_LENGTH must be greater or equal to GZP_CMD_ENCRYPTED_USER_DATA_RESP_PAYLOAD_LENGTH.
Nrf_gzp.h (nrf51822\include\gzp): * @brief Enumerator used in the first payload byte of each packet to 
Nrf_gzp.h (nrf51822\include\gzp):  GZP_CMD_HOST_ADDRESS_REQ = 0,     ///< Host address request
Nrf_gzp.h (nrf51822\include\gzp):  GZP_CMD_HOST_ADDRESS_FETCH,       ///< Host address fetch
Nrf_gzp.h (nrf51822\include\gzp):  GZP_CMD_HOST_ADDRESS_RESP,        ///< Host address response
Nrf_gzp.h (nrf51822\include\gzp): * Add the pre-defined validation ID to dst_id.
Nrf_gzp.h (nrf51822\include\gzp): * GZP_VALIDATION_ID_LENGTH bytes will be added.
Nrf_gzp.h (nrf51822\include\gzp): * @param dst_id Pointer to add the GZP validation ID to.
Nrf_gzp.h (nrf51822\include\gzp):void gzp_add_validation_id(uint8_t *dst_id);
Nrf_gzp.h (nrf51822\include\gzp): * Update the channel table and the system address.
Nrf_gzp.h (nrf51822\include\gzp): * system address. The channel table still includes GZP_CHANNEL_MAX and 
Nrf_gzp.h (nrf51822\include\gzp): * The system address is applied to base address 1 and therefore applies
Nrf_gzp.h (nrf51822\include\gzp): * @param system_address Pointer to the system_address to set.
Nrf_gzp.h (nrf51822\include\gzp): * @retval true  If theradio parameters were updated successfully.
Nrf_gzp.h (nrf51822\include\gzp): * @retval false If there was an error updated the radio parameters.
Nrf_gzp.h (nrf51822\include\gzp):bool gzp_update_radio_params(const uint8_t *system_address);
Nrf_gzp.h (nrf51822\include\gzp): * Generate a set of channels from a 4 byte address.
Nrf_gzp.h (nrf51822\include\gzp): * @param address Four byte address to generate the channel set from. 
Nrf_gzp.h (nrf51822\include\gzp):void gzp_generate_channels(uint8_t *ch_dst, const uint8_t * address, uint8_t channel_set_size);
Nrf_gzp.h (nrf51822\include\gzp): * @param pad 
Nrf_gzp.h (nrf51822\include\gzp):void gzp_xor_cipher(uint8_t* dst, const uint8_t* src, const uint8_t* pad, uint8_t length);
Nrf_gzp.h (nrf51822\include\gzp):* @retval -1 The device has a system address but no Host ID.
Nrf_gzp.h (nrf51822\include\gzp):* @retval >=0 The device has a system address and HostID at this index value in the database.
Nrf_gzp.h (nrf51822\include\gzp):  Function for sending a "system address" request to a Host.
Nrf_gzp.h (nrf51822\include\gzp):  When calling this function the Device will attempt acquiring the "system address" from 
Nrf_gzp.h (nrf51822\include\gzp):  a "system address" will be sent in return to the Device.
Nrf_gzp.h (nrf51822\include\gzp):  The new "system address" will apply immediately in the Device, and the new "system address"
Nrf_gzp.h (nrf51822\include\gzp):  Note. Using OTP devices limits the number of times a new "system address" can
Nrf_gzp.h (nrf51822\include\gzp):  @retval true if new "system address" was received from a Host.
Nrf_gzp.h (nrf51822\include\gzp):  @retval false if no "system address" was received from a Host.
Nrf_gzp.h (nrf51822\include\gzp):bool gzp_address_req_send(void);
Nrf_gzp.h (nrf51822\include\gzp):  The request will be sent using the "system address" previously received using
Nrf_gzp.h (nrf51822\include\gzp):  gzp_address_req_send().
Nrf_gzp.h (nrf51822\include\gzp):  "system address" by using gzp_address_req_send() and the "Host ID" by using
Nrf_gzp.h (nrf51822\include\gzp):  be monitoring for "system address" and "Host ID" requests from Devices.
Nrf_gzp.h (nrf51822\include\gzp):  A "system address request" received from a Device will always be granted. 
Nrf_gzp.h (nrf51822\include\gzp): * Address exchanged check.
Nrf_gzp.h (nrf51822\include\gzp): * @retval true  If a "system address" was delivered to a requesting Device during the 
Nrf_gzp.h (nrf51822\include\gzp):bool gzp_address_exchanged(void);
Nrf_gzp.h (nrf51822\include\gzp):  Function for reading encrypted user data.
Nrf_gzp.h (nrf51822\include\gzp):  Note that the read user data will be automatically decrypted. Only data
Nrf_gzp.h (nrf51822\include\gzp):bool gzp_crypt_user_data_read(uint8_t* dst, uint8_t* length);
Nrf_gzp_device.c (nrf51822\source\gzp): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_gzp_device.c (nrf51822\source\gzp):#define GZP_PARAMS_DB_ELEMENT_SYSTEM_ADDRESS 0 ///< System address position.
Nrf_gzp_device.c (nrf51822\source\gzp):#define GZP_PARAMS_DB_ELEMENT_HOST_ID (GZP_PARAMS_DB_ELEMENT_SYSTEM_ADDRESS + GZP_SYSTEM_ADDRESS_WIDTH) ///< Host ID position
Nrf_gzp_device.c (nrf51822\source\gzp):#define GZP_PARAMS_DB_ELEMENT_SIZE (GZP_SYSTEM_ADDRESS_WIDTH + GZP_HOST_ID_LENGTH)///< Total size
Nrf_gzp_device.c (nrf51822\source\gzp)://lint -esym(40, GZP_PARAMS_STORAGE_ADR) "Undeclare identifier"
Nrf_gzp_device.c (nrf51822\source\gzp):#define GZP_PARAMS_DB_ADR GZP_PARAMS_STORAGE_ADR                                    ///<
Nrf_gzp_device.c (nrf51822\source\gzp):#define GZP_INDEX_DB_ADR (GZP_PARAMS_STORAGE_ADR + GZP_PARAMS_DB_SIZE)             ///<
Nrf_gzp_device.c (nrf51822\source\gzp):static uint8_t gzp_system_address[GZP_SYSTEM_ADDRESS_WIDTH]; ///<
Nrf_gzp_device.c (nrf51822\source\gzp): * Function for adding an element to "parameters data base" in non volatile (NV) memory. An element is
Nrf_gzp_device.c (nrf51822\source\gzp): * GZP_PARAMS_ELEMENT_SYSTEM_ADDRESS bytes long, holding the "system address" and  "host ID".
Nrf_gzp_device.c (nrf51822\source\gzp):static void gzp_params_db_add(const uint8_t *src_element, uint8_t index);
Nrf_gzp_device.c (nrf51822\source\gzp): * Function for reading an element from "parameters data base" in non volatile (NV) memory. An element is
Nrf_gzp_device.c (nrf51822\source\gzp): * GZP_PARAMS_ELEMENT_SYSTEM_ADDRESS bytes long, holding the "system address" and  "host ID".
Nrf_gzp_device.c (nrf51822\source\gzp): * @param dst_element is a pointer where the read element should be stored.
Nrf_gzp_device.c (nrf51822\source\gzp): * selecting the location that should be read.
Nrf_gzp_device.c (nrf51822\source\gzp):static void gzp_params_db_read(uint8_t* dst_element, uint8_t index);
Nrf_gzp_device.c (nrf51822\source\gzp):static void gzp_index_db_add(uint8_t index);
Nrf_gzp_device.c (nrf51822\source\gzp): * Function for reading the index previously written to the "index data base" in NV memory.
Nrf_gzp_device.c (nrf51822\source\gzp):static uint8_t gzp_index_db_read(void);
Nrf_gzp_device.c (nrf51822\source\gzp): * Function for storing the current "system address" and "host ID" in NV memory.
Nrf_gzp_device.c (nrf51822\source\gzp): * @param store_all selects whether only "system address" or both "system address" and
Nrf_gzp_device.c (nrf51822\source\gzp): * @arg false selects that only "system address" should be stored.
Nrf_gzp_device.c (nrf51822\source\gzp): * Restore the "system address" and "host ID" from NV memory.
Nrf_gzp_device.c (nrf51822\source\gzp): * Delay function. Will add a delay equal to GZLL_RX_PERIOD * rx_periods [us].
Nrf_gzp_device.c (nrf51822\source\gzp): * Delay function. Will add a delay equal to GZLL_RX_PERIOD * rx_periods [us] using the
Nrf_gzp_device.c (nrf51822\source\gzp):static const uint32_t database[GZP_DEVICE_PARAMS_STORAGE_SIZE/4] __attribute__((at(GZP_PARAMS_DB_ADR)))
Nrf_gzp_device.c (nrf51822\source\gzp):    // Update radio parameters from gzp_system_address
Nrf_gzp_device.c (nrf51822\source\gzp):    (void)gzp_update_radio_params(gzp_system_address);
Nrf_gzp_device.c (nrf51822\source\gzp):bool gzp_address_req_send()
Nrf_gzp_device.c (nrf51822\source\gzp):    uint8_t address_req[GZP_CMD_HOST_ADDRESS_REQ_PAYLOAD_LENGTH];
Nrf_gzp_device.c (nrf51822\source\gzp):    uint8_t rx_payload[NRF_GZLL_CONST_MAX_PAYLOAD_LENGTH];
Nrf_gzp_device.c (nrf51822\source\gzp):    uint32_t rx_payload_length =  NRF_GZLL_CONST_MAX_PAYLOAD_LENGTH;
Nrf_gzp_device.c (nrf51822\source\gzp):    address_req[0] = (uint8_t)GZP_CMD_HOST_ADDRESS_REQ;
Nrf_gzp_device.c (nrf51822\source\gzp):    // Send a number of packets in order to broadcast that devices not within
Nrf_gzp_device.c (nrf51822\source\gzp):        success = gzp_tx_packet(address_req, GZP_CMD_HOST_ADDRESS_REQ_PAYLOAD_LENGTH, GZP_PAIRING_PIPE); 
Nrf_gzp_device.c (nrf51822\source\gzp):    address_req[0] = (uint8_t)GZP_CMD_HOST_ADDRESS_FETCH;
Nrf_gzp_device.c (nrf51822\source\gzp):    success =  gzp_tx_packet(address_req, GZP_CMD_HOST_ADDRESS_REQ_PAYLOAD_LENGTH, GZP_PAIRING_PIPE);
Nrf_gzp_device.c (nrf51822\source\gzp):    if(success  && latest_tx_info.payload_received_in_ack)
Nrf_gzp_device.c (nrf51822\source\gzp):            rx_payload_length = NRF_GZLL_CONST_MAX_PAYLOAD_LENGTH;  //dummy placeholder
Nrf_gzp_device.c (nrf51822\source\gzp):            if(nrf_gzll_fetch_packet_from_rx_fifo(GZP_PAIRING_PIPE, rx_payload, &rx_payload_length))
Nrf_gzp_device.c (nrf51822\source\gzp):                if(rx_payload[0] == (uint8_t)GZP_CMD_HOST_ADDRESS_RESP)
Nrf_gzp_device.c (nrf51822\source\gzp):                    memcpy(gzp_system_address, &rx_payload[GZP_CMD_HOST_ADDRESS_RESP_ADDRESS], GZP_SYSTEM_ADDRESS_WIDTH);
Nrf_gzp_device.c (nrf51822\source\gzp):                    gzll_update_ok &= gzp_update_radio_params(&rx_payload[GZP_CMD_HOST_ADDRESS_RESP_ADDRESS]);
Nrf_gzp_device.c (nrf51822\source\gzp):                    (void)gzp_params_store(false); // "False" indicates that only "system address" part of DB element will be stored
Nrf_gzp_device.c (nrf51822\source\gzp):    uint8_t tx_packet[GZP_CMD_HOST_ID_REQ_PAYLOAD_LENGTH];
Nrf_gzp_device.c (nrf51822\source\gzp):    uint8_t rx_packet[GZP_MAX_ACK_PAYLOAD_LENGTH];
Nrf_gzp_device.c (nrf51822\source\gzp):        if(gzp_tx_packet(tx_packet, GZP_CMD_HOST_ID_REQ_PAYLOAD_LENGTH, GZP_DATA_PIPE))
Nrf_gzp_device.c (nrf51822\source\gzp):        gzp_add_validation_id(&tx_packet[GZP_CMD_HOST_ID_FETCH_VALIDATION_ID]);
Nrf_gzp_device.c (nrf51822\source\gzp):        gzp_crypt(&tx_packet[1], &tx_packet[1], GZP_CMD_HOST_ID_FETCH_PAYLOAD_LENGTH - 1);
Nrf_gzp_device.c (nrf51822\source\gzp):        trans_result = gzp_tx_rx_transaction(tx_packet, GZP_CMD_HOST_ID_FETCH_PAYLOAD_LENGTH, rx_packet, NULL, GZP_DATA_PIPE);
Nrf_gzp_device.c (nrf51822\source\gzp):                gzp_crypt(&rx_packet[1], &rx_packet[1], GZP_CMD_HOST_ID_FETCH_RESP_PAYLOAD_LENGTH - 1);
Nrf_gzp_device.c (nrf51822\source\gzp):    if(nrf_gzll_add_packet_to_tx_fifo(pipe,(uint8_t *)tx_packet, length))
Nrf_gzp_device.c (nrf51822\source\gzp):    uint8_t fetch_packet[GZP_CMD_FETCH_RESP_PAYLOAD_LENGTH];
Nrf_gzp_device.c (nrf51822\source\gzp):    uint32_t local_rx_length = GZP_MAX_ACK_PAYLOAD_LENGTH;
Nrf_gzp_device.c (nrf51822\source\gzp):        tx_packet_success = gzp_tx_packet(fetch_packet, GZP_CMD_FETCH_RESP_PAYLOAD_LENGTH, pipe);
Nrf_gzp_device.c (nrf51822\source\gzp):                local_rx_length = NRF_GZLL_CONST_MAX_PAYLOAD_LENGTH;
Nrf_gzp_device.c (nrf51822\source\gzp):    uint8_t tx_packet[GZP_MAX_FW_PAYLOAD_LENGTH];
Nrf_gzp_device.c (nrf51822\source\gzp):    uint8_t rx_packet[GZP_MAX_ACK_PAYLOAD_LENGTH];
Nrf_gzp_device.c (nrf51822\source\gzp):    tx_packet_length = length + (uint8_t)GZP_ENCRYPTED_USER_DATA_PACKET_OVERHEAD;
Nrf_gzp_device.c (nrf51822\source\gzp):    gzp_add_validation_id(&tx_packet[GZP_CMD_ENCRYPTED_USER_DATA_VALIDATION_ID]);
Nrf_gzp_device.c (nrf51822\source\gzp):    memcpy(&tx_packet[GZP_CMD_ENCRYPTED_USER_DATA_PAYLOAD], (uint8_t*)src, length);
Nrf_gzp_device.c (nrf51822\source\gzp):                //print_string("GZP_CRYPT_TX_TRANS: Validation ID bad\r\n");
Nrf_gzp_device.c (nrf51822\source\gzp):            //print_string("GZP_CRYPT_TX_TRANS: Bad CMD. \r\n");
Nrf_gzp_device.c (nrf51822\source\gzp):    uint8_t tx_packet[GZP_CMD_KEY_UPDATE_PAYLOAD_LENGTH], rx_packet[GZP_MAX_ACK_PAYLOAD_LENGTH];
Nrf_gzp_device.c (nrf51822\source\gzp):    if(gzp_tx_rx_transaction(tx_packet, GZP_CMD_KEY_UPDATE_PREPARE_PAYLOAD_LENGTH, rx_packet, NULL, GZP_DATA_PIPE) == GZP_TX_RX_SUCCESS)
Nrf_gzp_device.c (nrf51822\source\gzp):            gzp_add_validation_id(&tx_packet[GZP_CMD_KEY_UPDATE_VALIDATION_ID]);
Nrf_gzp_device.c (nrf51822\source\gzp):            gzp_crypt(&tx_packet[1], &tx_packet[1], GZP_CMD_KEY_UPDATE_PAYLOAD_LENGTH - 1);
Nrf_gzp_device.c (nrf51822\source\gzp):            if(gzp_tx_packet(tx_packet, GZP_CMD_KEY_UPDATE_PAYLOAD_LENGTH, GZP_DATA_PIPE))
Nrf_gzp_device.c (nrf51822\source\gzp):static void gzp_params_db_add(const uint8_t* src_element, uint8_t index)
Nrf_gzp_device.c (nrf51822\source\gzp):    nrf_nvmc_write_bytes((GZP_PARAMS_DB_ADR + (index * GZP_PARAMS_DB_ELEMENT_SIZE)), src_element, (uint32_t)GZP_PARAMS_DB_ELEMENT_SIZE);
Nrf_gzp_device.c (nrf51822\source\gzp):static void gzp_params_db_read(uint8_t* dst_element, uint8_t index)
Nrf_gzp_device.c (nrf51822\source\gzp):    memcpy(dst_element,(uint8_t*)(GZP_PARAMS_DB_ADR + (index * GZP_PARAMS_DB_ELEMENT_SIZE)), GZP_PARAMS_DB_ELEMENT_SIZE);
Nrf_gzp_device.c (nrf51822\source\gzp):static void gzp_index_db_add(uint8_t val)
Nrf_gzp_device.c (nrf51822\source\gzp):    uint32_t  addr;
Nrf_gzp_device.c (nrf51822\source\gzp):        temp_val = *(uint8_t*)(GZP_INDEX_DB_ADR + i);
Nrf_gzp_device.c (nrf51822\source\gzp):    addr = (GZP_INDEX_DB_ADR + i);
Nrf_gzp_device.c (nrf51822\source\gzp):    nrf_nvmc_write_byte(addr, temp_val);
Nrf_gzp_device.c (nrf51822\source\gzp):static uint8_t gzp_index_db_read()
Nrf_gzp_device.c (nrf51822\source\gzp):        retval = *(uint8_t*)(GZP_INDEX_DB_ADR + i);
Nrf_gzp_device.c (nrf51822\source\gzp):        db_byte = *(uint8_t*)(GZP_INDEX_DB_ADR + i);
Nrf_gzp_device.c (nrf51822\source\gzp):          gzp_params_db_read(temp_element, db_byte);
Nrf_gzp_device.c (nrf51822\source\gzp):    return ((*(uint8_t*)(GZP_INDEX_DB_ADR + (GZP_INDEX_DB_SIZE - 1)) != 0xff));
Nrf_gzp_device.c (nrf51822\source\gzp):    return ((GZP_INDEX_DB_SIZE == 0) || ((*(uint8_t*)(GZP_INDEX_DB_ADR)) == 0xff));
Nrf_gzp_device.c (nrf51822\source\gzp):        // Search for: Current system address and host ID exists
Nrf_gzp_device.c (nrf51822\source\gzp):            gzp_params_db_read(temp_element, i);
Nrf_gzp_device.c (nrf51822\source\gzp):            if(((memcmp(&temp_element[GZP_PARAMS_DB_ELEMENT_SYSTEM_ADDRESS], gzp_system_address, GZP_SYSTEM_ADDRESS_WIDTH)) == 0) && ((memcmp(&temp_element[GZP_PARAMS_DB_ELEMENT_HOST_ID], gzp_host_id, GZP_HOST_ID_LENGTH)) == 0))
Nrf_gzp_device.c (nrf51822\source\gzp):                break; // System address + host_id allready exists in database
Nrf_gzp_device.c (nrf51822\source\gzp):        // Search for: Current system address and cleared host ID
Nrf_gzp_device.c (nrf51822\source\gzp):                gzp_params_db_read(temp_element, i);
Nrf_gzp_device.c (nrf51822\source\gzp):                if(((memcmp(&temp_element[GZP_PARAMS_DB_ELEMENT_SYSTEM_ADDRESS], gzp_system_address, GZP_SYSTEM_ADDRESS_WIDTH)) == 0) && \
Nrf_gzp_device.c (nrf51822\source\gzp):        // Search for: Cleared system address and cleared host ID
Nrf_gzp_device.c (nrf51822\source\gzp):                gzp_params_db_read(temp_element, i);
Nrf_gzp_device.c (nrf51822\source\gzp):                    memcpy(&temp_element[GZP_PARAMS_DB_ELEMENT_SYSTEM_ADDRESS], gzp_system_address, GZP_SYSTEM_ADDRESS_WIDTH);
Nrf_gzp_device.c (nrf51822\source\gzp):        // Search for: System address + any host ID
Nrf_gzp_device.c (nrf51822\source\gzp):            gzp_params_db_read(temp_element, i);
Nrf_gzp_device.c (nrf51822\source\gzp):            if((memcmp(&temp_element[GZP_PARAMS_DB_ELEMENT_SYSTEM_ADDRESS], gzp_system_address, GZP_SYSTEM_ADDRESS_WIDTH)) == 0)
Nrf_gzp_device.c (nrf51822\source\gzp):        // Search for: System address cleared
Nrf_gzp_device.c (nrf51822\source\gzp):                gzp_params_db_read(temp_element, i);
Nrf_gzp_device.c (nrf51822\source\gzp):                if(gzp_array_is_set(&temp_element[GZP_PARAMS_DB_ELEMENT_SYSTEM_ADDRESS], GZP_SYSTEM_ADDRESS_WIDTH))
Nrf_gzp_device.c (nrf51822\source\gzp):                    memcpy(&temp_element[GZP_PARAMS_DB_ELEMENT_SYSTEM_ADDRESS], gzp_system_address, GZP_SYSTEM_ADDRESS_WIDTH);
Nrf_gzp_device.c (nrf51822\source\gzp):        gzp_params_db_add(temp_element, new_db_index);
Nrf_gzp_device.c (nrf51822\source\gzp):        if(!gzp_index_db_full() && (new_db_index != gzp_index_db_read()) && (new_db_index != GZP_PARAMS_DB_MAX_ENTRIES))
Nrf_gzp_device.c (nrf51822\source\gzp):            gzp_index_db_add(new_db_index);
Nrf_gzp_device.c (nrf51822\source\gzp):        i = gzp_index_db_read();
Nrf_gzp_device.c (nrf51822\source\gzp):            gzp_params_db_read(temp_element, i);
Nrf_gzp_device.c (nrf51822\source\gzp):            memcpy(gzp_system_address, &temp_element[GZP_PARAMS_DB_ELEMENT_SYSTEM_ADDRESS], GZP_SYSTEM_ADDRESS_WIDTH);
Nrf_gzp_device.c (nrf51822\source\gzp):void nrf_gzll_host_rx_data_ready(uint32_t pipe, nrf_gzll_host_rx_info_t rx_info)
Nrf_gzp_host.c (nrf51822\source\gzp): * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_gzp_host.c (nrf51822\source\gzp)://lint -esym(40, GZP_PARAMS_STORAGE_ADR) "Undeclared identifier"
Nrf_gzp_host.c (nrf51822\source\gzp): * Function for reading value of internal session counter.
Nrf_gzp_host.c (nrf51822\source\gzp): * Function processing received "system address request" from Device.
Nrf_gzp_host.c (nrf51822\source\gzp): * @param gzp_req  Pointer to RX payload containing system address request.
Nrf_gzp_host.c (nrf51822\source\gzp):static void gzp_process_address_req(uint8_t* gzp_req);
Nrf_gzp_host.c (nrf51822\source\gzp): * @param rx_payload Pointer to rx_payload contaning Host ID request.
Nrf_gzp_host.c (nrf51822\source\gzp):static void gzp_process_id_req(uint8_t* rx_payload);
Nrf_gzp_host.c (nrf51822\source\gzp): * @param rx_payload Pointer to rx_payload contaning Host ID fetch request.
Nrf_gzp_host.c (nrf51822\source\gzp):static void gzp_process_id_fetch(uint8_t* rx_payload);
Nrf_gzp_host.c (nrf51822\source\gzp): * @param rx_payload Pointer to rx_payload containing Key Update request.
Nrf_gzp_host.c (nrf51822\source\gzp):static void gzp_process_key_update(uint8_t* rx_payload);
Nrf_gzp_host.c (nrf51822\source\gzp): * @param rx_payload Pointer to rx_payload containing the encrypted user data.
Nrf_gzp_host.c (nrf51822\source\gzp):static void gzp_process_encrypted_user_data(uint8_t* rx_payload, uint8_t length);
Nrf_gzp_host.c (nrf51822\source\gzp): * Function to preload the payload for the next ACK.
Nrf_gzp_host.c (nrf51822\source\gzp): * @param src       Pointer to source payload.
Nrf_gzp_host.c (nrf51822\source\gzp): * @param length    Length of source payload.
Nrf_gzp_host.c (nrf51822\source\gzp): * @param pipe      Pipe for the ACK payload.
Nrf_gzp_host.c (nrf51822\source\gzp):static void gzp_preload_ack(uint8_t* src, uint8_t length, uint8_t pipe);
Nrf_gzp_host.c (nrf51822\source\gzp): * Function for reading the Chip ID from non-volatile memory.
Nrf_gzp_host.c (nrf51822\source\gzp): * The chip ID is used for the system address. 
Nrf_gzp_host.c (nrf51822\source\gzp): * address in nRF24LU ICs.
Nrf_gzp_host.c (nrf51822\source\gzp): * @param     dst  Address to copy Host ID to.
Nrf_gzp_host.c (nrf51822\source\gzp):void gzp_host_chip_id_read(uint8_t *dst, uint8_t n);
Nrf_gzp_host.c (nrf51822\source\gzp): * @param src   Address of the Host ID to copy from.
Nrf_gzp_host.c (nrf51822\source\gzp):static bool gzp_address_exchanged_f;      ///< True if Host has exchanged a system address with a device and thus pairing has begun.
Nrf_gzp_host.c (nrf51822\source\gzp):static nrf_gzll_host_rx_info_t prev_gzp_rx_info = {0, 0};                ///< RSSI and status of ACK payload transmission of previous Gazell packet.
Nrf_gzp_host.c (nrf51822\source\gzp):  uint8_t system_address[GZP_SYSTEM_ADDRESS_WIDTH];
Nrf_gzp_host.c (nrf51822\source\gzp):  // Read "chip id", of which 4 bytes (GZP_SYSTEM_ADDRESS_WIDTH)
Nrf_gzp_host.c (nrf51822\source\gzp):  // are used as system address
Nrf_gzp_host.c (nrf51822\source\gzp):  gzp_host_chip_id_read(system_address, GZP_SYSTEM_ADDRESS_WIDTH);
Nrf_gzp_host.c (nrf51822\source\gzp):  // Set up radio parameters (addresses and channel subset) from system_address
Nrf_gzp_host.c (nrf51822\source\gzp):  (void)gzp_update_radio_params(system_address);
Nrf_gzp_host.c (nrf51822\source\gzp):  gzp_address_exchanged_f = false;
Nrf_gzp_host.c (nrf51822\source\gzp):  uint32_t payload_length = NRF_GZLL_CONST_MAX_PAYLOAD_LENGTH;
Nrf_gzp_host.c (nrf51822\source\gzp):  uint8_t rx_payload[NRF_GZLL_CONST_MAX_PAYLOAD_LENGTH];
Nrf_gzp_host.c (nrf51822\source\gzp):  gzp_address_exchanged_f = false;
Nrf_gzp_host.c (nrf51822\source\gzp):    gzp_packet_received = nrf_gzll_fetch_packet_from_rx_fifo(GZP_PAIRING_PIPE, rx_payload, &payload_length);
Nrf_gzp_host.c (nrf51822\source\gzp):      gzp_packet_received = nrf_gzll_fetch_packet_from_rx_fifo(GZP_DATA_PIPE, rx_payload, &payload_length);    
Nrf_gzp_host.c (nrf51822\source\gzp):    //lint -save -esym(644,rx_payload) //may not have been initialized
Nrf_gzp_host.c (nrf51822\source\gzp):    switch(rx_payload[0])
Nrf_gzp_host.c (nrf51822\source\gzp):      case GZP_CMD_HOST_ADDRESS_REQ:
Nrf_gzp_host.c (nrf51822\source\gzp):        gzp_process_address_req(rx_payload);
Nrf_gzp_host.c (nrf51822\source\gzp):        gzp_process_id_req(rx_payload);
Nrf_gzp_host.c (nrf51822\source\gzp):        gzp_process_id_fetch(rx_payload);
Nrf_gzp_host.c (nrf51822\source\gzp):        gzp_process_key_update(rx_payload);
Nrf_gzp_host.c (nrf51822\source\gzp):        gzp_process_encrypted_user_data(rx_payload, payload_length);
Nrf_gzp_host.c (nrf51822\source\gzp):static void gzp_process_address_req(uint8_t* gzp_req)
Nrf_gzp_host.c (nrf51822\source\gzp):  uint8_t pairing_resp[GZP_CMD_HOST_ADDRESS_RESP_PAYLOAD_LENGTH];
Nrf_gzp_host.c (nrf51822\source\gzp):  uint32_t rx_payload_length = NRF_GZLL_CONST_MAX_PAYLOAD_LENGTH;
Nrf_gzp_host.c (nrf51822\source\gzp):  gzp_address_exchanged_f = false;
Nrf_gzp_host.c (nrf51822\source\gzp):    pairing_resp[0] = (uint8_t)GZP_CMD_HOST_ADDRESS_RESP;
Nrf_gzp_host.c (nrf51822\source\gzp):    gzp_host_chip_id_read(&pairing_resp[GZP_CMD_HOST_ADDRESS_RESP_ADDRESS], GZP_SYSTEM_ADDRESS_WIDTH);
Nrf_gzp_host.c (nrf51822\source\gzp):    (void)nrf_gzll_add_packet_to_tx_fifo(0, &pairing_resp[0], GZP_CMD_HOST_ADDRESS_RESP_PAYLOAD_LENGTH);
Nrf_gzp_host.c (nrf51822\source\gzp):        (void)nrf_gzll_fetch_packet_from_rx_fifo(GZP_PAIRING_PIPE, &gzp_req[0], &rx_payload_length);
Nrf_gzp_host.c (nrf51822\source\gzp):        if(gzp_req[0] == (uint8_t)GZP_CMD_HOST_ADDRESS_FETCH)
Nrf_gzp_host.c (nrf51822\source\gzp):          gzp_address_exchanged_f = true;
Nrf_gzp_host.c (nrf51822\source\gzp):static void gzp_preload_ack(uint8_t* src, uint8_t length, uint8_t pipe)
Nrf_gzp_host.c (nrf51822\source\gzp):  (void)nrf_gzll_add_packet_to_tx_fifo(pipe, src, length);
Nrf_gzp_host.c (nrf51822\source\gzp):bool gzp_address_exchanged()
Nrf_gzp_host.c (nrf51822\source\gzp):  return gzp_address_exchanged_f;
Nrf_gzp_host.c (nrf51822\source\gzp):bool gzp_crypt_user_data_read(uint8_t* dst, uint8_t* length)
Nrf_gzp_host.c (nrf51822\source\gzp):  if(*((uint8_t*)GZP_PARAMS_STORAGE_ADR) == 0xff)
Nrf_gzp_host.c (nrf51822\source\gzp):    nrf_nvmc_write_bytes(GZP_PARAMS_STORAGE_ADR + 1, src, GZP_HOST_ID_LENGTH);
Nrf_gzp_host.c (nrf51822\source\gzp):    nrf_nvmc_write_byte(GZP_PARAMS_STORAGE_ADR, 0x00);
Nrf_gzp_host.c (nrf51822\source\gzp):  memcpy(dst, (uint8_t*)GZP_PARAMS_STORAGE_ADR + 1, GZP_HOST_ID_LENGTH);
Nrf_gzp_host.c (nrf51822\source\gzp):static void gzp_process_id_req(uint8_t* rx_payload)
Nrf_gzp_host.c (nrf51822\source\gzp):      gzp_crypt_set_session_token(&rx_payload[GZP_CMD_HOST_ID_REQ_SESSION_TOKEN]);
Nrf_gzp_host.c (nrf51822\source\gzp):    // Added:
Nrf_gzp_host.c (nrf51822\source\gzp):        gzp_xor_cipher(temp_host_id, temp_host_id, &rx_payload[GZP_CMD_HOST_ID_REQ_SESSION_TOKEN], GZP_SESSION_TOKEN_LENGTH);
Nrf_gzp_host.c (nrf51822\source\gzp):        gzp_xor_cipher(temp_host_id, temp_host_id, &rx_payload[GZP_CMD_HOST_ID_REQ_SESSION_TOKEN], GZP_HOST_ID_LENGTH);
Nrf_gzp_host.c (nrf51822\source\gzp):static void gzp_process_id_fetch(uint8_t* rx_payload)
Nrf_gzp_host.c (nrf51822\source\gzp):  uint8_t tx_payload[GZP_CMD_HOST_ID_FETCH_RESP_PAYLOAD_LENGTH];
Nrf_gzp_host.c (nrf51822\source\gzp):    gzp_crypt(&rx_payload[1], &rx_payload[1], GZP_CMD_HOST_ID_FETCH_PAYLOAD_LENGTH - 1);
Nrf_gzp_host.c (nrf51822\source\gzp):    if(gzp_validate_id(&rx_payload[GZP_CMD_HOST_ID_FETCH_VALIDATION_ID]))
Nrf_gzp_host.c (nrf51822\source\gzp):          tx_payload[GZP_CMD_HOST_ID_FETCH_RESP_STATUS] = (uint8_t)GZP_ID_RESP_GRANTED;
Nrf_gzp_host.c (nrf51822\source\gzp):          gzp_get_host_id(&tx_payload[GZP_CMD_HOST_ID_FETCH_RESP_HOST_ID]);
Nrf_gzp_host.c (nrf51822\source\gzp):          tx_payload[GZP_CMD_HOST_ID_FETCH_RESP_STATUS] = (uint8_t)GZP_ID_RESP_REJECTED;
Nrf_gzp_host.c (nrf51822\source\gzp):          tx_payload[GZP_CMD_HOST_ID_FETCH_RESP_STATUS] = (uint8_t)GZP_ID_RESP_PENDING;
Nrf_gzp_host.c (nrf51822\source\gzp):      tx_payload[0] = (uint8_t)GZP_CMD_HOST_ID_FETCH_RESP;
Nrf_gzp_host.c (nrf51822\source\gzp):      gzp_add_validation_id(&tx_payload[GZP_CMD_HOST_ID_FETCH_RESP_VALIDATION_ID]);
Nrf_gzp_host.c (nrf51822\source\gzp):      gzp_crypt(&tx_payload[1], &tx_payload[1], GZP_CMD_HOST_ID_FETCH_RESP_PAYLOAD_LENGTH - 1);
Nrf_gzp_host.c (nrf51822\source\gzp):      gzp_preload_ack(tx_payload, GZP_CMD_HOST_ID_FETCH_RESP_PAYLOAD_LENGTH, GZP_DATA_PIPE);
Nrf_gzp_host.c (nrf51822\source\gzp):  uint8_t tx_payload[GZP_CMD_KEY_UPDATE_PREPARE_RESP_PAYLOAD_LENGTH];
Nrf_gzp_host.c (nrf51822\source\gzp):  tx_payload[0] = (uint8_t)GZP_CMD_KEY_UPDATE_PREPARE_RESP;
Nrf_gzp_host.c (nrf51822\source\gzp):  gzp_get_session_counter(&tx_payload[GZP_CMD_KEY_UPDATE_PREPARE_RESP_SESSION_TOKEN]);
Nrf_gzp_host.c (nrf51822\source\gzp):    gzp_crypt_set_session_token(&tx_payload[GZP_CMD_KEY_UPDATE_PREPARE_RESP_SESSION_TOKEN]);
Nrf_gzp_host.c (nrf51822\source\gzp):  gzp_preload_ack(tx_payload, GZP_CMD_KEY_UPDATE_PREPARE_RESP_PAYLOAD_LENGTH, GZP_DATA_PIPE);
Nrf_gzp_host.c (nrf51822\source\gzp):static void gzp_process_key_update(uint8_t* rx_payload)
Nrf_gzp_host.c (nrf51822\source\gzp):  gzp_crypt(&rx_payload[1], &rx_payload[1], GZP_CMD_KEY_UPDATE_PAYLOAD_LENGTH - 1);
Nrf_gzp_host.c (nrf51822\source\gzp):  if(gzp_validate_id(&rx_payload[GZP_CMD_KEY_UPDATE_VALIDATION_ID]))
Nrf_gzp_host.c (nrf51822\source\gzp):    gzp_crypt_set_dyn_key(&rx_payload[GZP_CMD_KEY_UPDATE_NEW_KEY]);
Nrf_gzp_host.c (nrf51822\source\gzp):static void gzp_process_encrypted_user_data(uint8_t* rx_payload, uint8_t length)
Nrf_gzp_host.c (nrf51822\source\gzp):  uint8_t tx_payload[GZP_CMD_ENCRYPTED_USER_DATA_RESP_PAYLOAD_LENGTH];
Nrf_gzp_host.c (nrf51822\source\gzp):  gzp_crypt(&rx_payload[1], &rx_payload[1], length - 1);
Nrf_gzp_host.c (nrf51822\source\gzp):  if(gzp_validate_id(&rx_payload[GZP_CMD_ENCRYPTED_USER_DATA_VALIDATION_ID]))
Nrf_gzp_host.c (nrf51822\source\gzp):    gzp_encrypted_user_data_length = length - GZP_ENCRYPTED_USER_DATA_PACKET_OVERHEAD;
Nrf_gzp_host.c (nrf51822\source\gzp):    memcpy((void*)gzp_encrypted_user_data, &rx_payload[GZP_CMD_ENCRYPTED_USER_DATA_PAYLOAD], gzp_encrypted_user_data_length);
Nrf_gzp_host.c (nrf51822\source\gzp):  tx_payload[0] = (uint8_t)GZP_CMD_ENCRYPTED_USER_DATA_RESP;
Nrf_gzp_host.c (nrf51822\source\gzp):  gzp_add_validation_id(&tx_payload[GZP_CMD_ENCRYPTED_USER_DATA_RESP_VALIDATION_ID]);
Nrf_gzp_host.c (nrf51822\source\gzp):  gzp_crypt(&tx_payload[GZP_CMD_ENCRYPTED_USER_DATA_RESP_VALIDATION_ID], &tx_payload[GZP_CMD_ENCRYPTED_USER_DATA_RESP_VALIDATION_ID], GZP_VALIDATION_ID_LENGTH);
Nrf_gzp_host.c (nrf51822\source\gzp):  gzp_get_session_counter(&tx_payload[GZP_CMD_ENCRYPTED_USER_DATA_RESP_SESSION_TOKEN]);
Nrf_gzp_host.c (nrf51822\source\gzp):    gzp_crypt_set_session_token(&tx_payload[GZP_CMD_ENCRYPTED_USER_DATA_RESP_SESSION_TOKEN]);
Nrf_gzp_host.c (nrf51822\source\gzp):  gzp_preload_ack(tx_payload, GZP_CMD_ENCRYPTED_USER_DATA_RESP_PAYLOAD_LENGTH, GZP_DATA_PIPE);
Nrf_gzp_host.c (nrf51822\source\gzp):// Function added during LE1 -> nRF51 port
Nrf_gzp_host.c (nrf51822\source\gzp):void nrf_gzll_host_rx_data_ready(uint32_t pipe, nrf_gzll_host_rx_info_t rx_info)
Nrf_gzp_host_nrf51.c (nrf51822\source\gzp): * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_gzp_host_nrf51.c (nrf51822\source\gzp):void gzp_host_chip_id_read(uint8_t *dst, uint8_t n)
Nrf_gzp_host_nrf51.c (nrf51822\source\gzp):  if( *((uint8_t*)(GZP_PARAMS_STORAGE_ADR + GZP_HOST_ID_LENGTH + 1)) == 0xff)
Nrf_gzp_host_nrf51.c (nrf51822\source\gzp):    nrf_nvmc_write_byte((GZP_PARAMS_STORAGE_ADR + GZP_HOST_ID_LENGTH + 1) , 0x00);
Nrf_gzp_host_nrf51.c (nrf51822\source\gzp):      nrf_nvmc_write_byte((GZP_PARAMS_STORAGE_ADR + GZP_HOST_ID_LENGTH + 2 + i) , random_number);
Nrf_gzp_host_nrf51.c (nrf51822\source\gzp):    *(dst++) = *((uint8_t*)(GZP_PARAMS_STORAGE_ADR + GZP_HOST_ID_LENGTH + 2 + i));
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):* WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):void nrf_nvmc_page_erase(uint32_t address)
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  NRF_NVMC->ERASEPAGE = address;
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):void nrf_nvmc_write_byte(uint32_t address, uint8_t value)
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  uint32_t byte_shift = address & (uint32_t)0x03;
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  uint32_t address32 = address & ~byte_shift; // Address to the word this byte is in.
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  uint32_t value32 = (*(uint32_t*)address32 & ~((uint32_t)0xFF << (byte_shift << (uint32_t)3)));
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  *(uint32_t*)address32 = value32;
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  while(NRF_NVMC->READY == NVMC_READY_READY_Busy)
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):void nrf_nvmc_write_word(uint32_t address, uint32_t value)
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  while (NRF_NVMC->READY == NVMC_READY_READY_Busy){
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  *(uint32_t*)address = value;
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  while (NRF_NVMC->READY == NVMC_READY_READY_Busy){
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):void nrf_nvmc_write_bytes(uint32_t address, const uint8_t * src, uint32_t num_bytes)
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):     nrf_nvmc_write_byte(address+i,src[i]);
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):void nrf_nvmc_write_words(uint32_t address, const uint32_t * src, uint32_t num_words)
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):    ((uint32_t*)address)[i] = src[i];
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):    while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
Nrf_nvmc.c (nrf51822\source\nrf_nvmc):  while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
Nrf_nvmc.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_nvmc.h (nrf51822\include): * address in the page.
Nrf_nvmc.h (nrf51822\include): * @param address Start address of the page. 
Nrf_nvmc.h (nrf51822\include):void nrf_nvmc_page_erase(uint32_t address);
Nrf_nvmc.h (nrf51822\include): * The function reads the word containing the byte, and then
Nrf_nvmc.h (nrf51822\include): * @param address Address to write to.
Nrf_nvmc.h (nrf51822\include):void nrf_nvmc_write_byte(uint32_t address , uint8_t value);
Nrf_nvmc.h (nrf51822\include): * @param address Address to write to.
Nrf_nvmc.h (nrf51822\include):void nrf_nvmc_write_word(uint32_t address, uint32_t value);
Nrf_nvmc.h (nrf51822\include): * @param address   Address to write to.
Nrf_nvmc.h (nrf51822\include):void nrf_nvmc_write_bytes(uint32_t  address, const uint8_t * src, uint32_t num_bytes);
Nrf_nvmc.h (nrf51822\include): * @param address   Address to write to.
Nrf_nvmc.h (nrf51822\include):void nrf_nvmc_write_words(uint32_t address, const uint32_t * src, uint32_t num_words);
Nrf_sdm.h (nrf51822\include\ble\softdevice):/* Header guard */
Nrf_sdm.h (nrf51822\include\ble\softdevice):/** @addtogroup NRF_SDM_DEFINES Defines
Nrf_sdm.h (nrf51822\include\ble\softdevice):/** @addtogroup NRF_SDM_ENUMS Enumerations
Nrf_sdm.h (nrf51822\include\ble\softdevice):/** @addtogroup NRF_SDM_TYPES Types
Nrf_sdm.h (nrf51822\include\ble\softdevice):/** @addtogroup NRF_SDM_FUNCTIONS Functions
Nrf_sdm.h (nrf51822\include\ble\softdevice): * @note Some care must be taken if a low frequency clock source is already running when calling this function:
Nrf_sdm.h (nrf51822\include\ble\softdevice): *       - SoC library and protocol stack APIs are made available
Nrf_sdm.h (nrf51822\include\ble\softdevice): *       - nrf_nvic_ functions must be used instead of CMSIS NVIC_ functions for reliable usage of the softdevice.
Nrf_sdm.h (nrf51822\include\ble\softdevice): * @retval ::NRF_ERROR_SDM_INCORRECT_INTERRUPT_CONFIGURATION SoftDeviceinterrupt is already enabled, or an enabled interrupt has an illegal priority level
Nrf_sdm.h (nrf51822\include\ble\softdevice): * @post SoC library and protocol stack APIs are made unavailable.
Nrf_sdm.h (nrf51822\include\ble\softdevice): * This function is only intended to be called when a bootloader is enabled is used.
Nrf_sdm.h (nrf51822\include\ble\softdevice): * The bootloader should call this right before it starts the application. 
Nrf_soc.h (nrf51822\include\ble\softdevice):/** @addtogroup NRF_SOC_DEFINES Defines
Nrf_soc.h (nrf51822\include\ble\softdevice):/**@brief Guranteed time for application to process radio inactive notification. */
Nrf_soc.h (nrf51822\include\ble\softdevice):#define NRF_RADIO_NOTIFICATION_INACTIVE_GUARANTEED_TIME_US   (62)
Nrf_soc.h (nrf51822\include\ble\softdevice):#define RADIO_NOTIFICATION_IRQn       (SWI1_IRQn)       /**< The radio notification IRQ number. */
Nrf_soc.h (nrf51822\include\ble\softdevice):#define RADIO_NOTIFICATION_IRQHandler (SWI1_IRQHandler) /**< The radio notification IRQ handler. */
Nrf_soc.h (nrf51822\include\ble\softdevice):/** @addtogroup NRF_SOC_TYPES Types
Nrf_soc.h (nrf51822\include\ble\softdevice):  SD_RADIO_NOTIFICATION_CFG_SET,
Nrf_soc.h (nrf51822\include\ble\softdevice):/**@brief Possible values of ::nrf_radio_notification_distance_t. */
Nrf_soc.h (nrf51822\include\ble\softdevice):enum NRF_RADIO_NOTIFICATION_DISTANCES
Nrf_soc.h (nrf51822\include\ble\softdevice):  NRF_RADIO_NOTIFICATION_DISTANCE_NONE = 0, /**< The event does not have a notification. */
Nrf_soc.h (nrf51822\include\ble\softdevice):  NRF_RADIO_NOTIFICATION_DISTANCE_800US,    /**< The distance from the active notification to start of radio activity. */
Nrf_soc.h (nrf51822\include\ble\softdevice):  NRF_RADIO_NOTIFICATION_DISTANCE_1740US,   /**< The distance from the active notification to start of radio activity. */
Nrf_soc.h (nrf51822\include\ble\softdevice):  NRF_RADIO_NOTIFICATION_DISTANCE_2680US,   /**< The distance from the active notification to start of radio activity. */
Nrf_soc.h (nrf51822\include\ble\softdevice):  NRF_RADIO_NOTIFICATION_DISTANCE_3620US,   /**< The distance from the active notification to start of radio activity. */
Nrf_soc.h (nrf51822\include\ble\softdevice):  NRF_RADIO_NOTIFICATION_DISTANCE_4560US,   /**< The distance from the active notification to start of radio activity. */
Nrf_soc.h (nrf51822\include\ble\softdevice):  NRF_RADIO_NOTIFICATION_DISTANCE_5500US    /**< The distance from the active notification to start of radio activity. */
Nrf_soc.h (nrf51822\include\ble\softdevice):/**@brief Possible values of ::nrf_radio_notification_type_t. */
Nrf_soc.h (nrf51822\include\ble\softdevice):enum NRF_RADIO_NOTIFICATION_TYPES
Nrf_soc.h (nrf51822\include\ble\softdevice):  NRF_RADIO_NOTIFICATION_TYPE_NONE = 0,        /**< The event does not have a radio notification signal. */
Nrf_soc.h (nrf51822\include\ble\softdevice):  NRF_RADIO_NOTIFICATION_TYPE_INT_ON_ACTIVE,   /**< Using interrupt for notification when the radio will be enabled. */
Nrf_soc.h (nrf51822\include\ble\softdevice):  NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE, /**< Using interrupt for notification when the radio has been disabled. */
Nrf_soc.h (nrf51822\include\ble\softdevice):  NRF_RADIO_NOTIFICATION_TYPE_INT_ON_BOTH,     /**< Using interrupt for notification both when the radio will be enabled and disabled. */
Nrf_soc.h (nrf51822\include\ble\softdevice):/** @addtogroup NRF_SOC_TYPES Types
Nrf_soc.h (nrf51822\include\ble\softdevice):/**@brief Radio notification distances. */
Nrf_soc.h (nrf51822\include\ble\softdevice):typedef uint8_t nrf_radio_notification_distance_t;
Nrf_soc.h (nrf51822\include\ble\softdevice):/**@brief Radio notification types. */
Nrf_soc.h (nrf51822\include\ble\softdevice):typedef uint8_t nrf_radio_notification_type_t;
Nrf_soc.h (nrf51822\include\ble\softdevice):/** @addtogroup NRF_SOC_FUNCTIONS Functions
Nrf_soc.h (nrf51822\include\ble\softdevice): * @retval ::NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN The mutex could not be acquired.
Nrf_soc.h (nrf51822\include\ble\softdevice): * The DCDC mode switch will be blocked when occuring in close proximity to radio transmissions. When
Nrf_soc.h (nrf51822\include\ble\softdevice): * the radio transmission is done, the last mode will be used.
Nrf_soc.h (nrf51822\include\ble\softdevice): * this function will wait in thread mode, then the execution will return in the application's
Nrf_soc.h (nrf51822\include\ble\softdevice): * main thread. When an interrupt is disabled and gets pended it will return to the application's 
Nrf_soc.h (nrf51822\include\ble\softdevice): * thread main. The application must ensure that the pended flag is cleared using 
Nrf_soc.h (nrf51822\include\ble\softdevice):/**@brief Configures the Radio Notification signal.
Nrf_soc.h (nrf51822\include\ble\softdevice): *      - In the period between the ACTIVE signal and the start of the Radio Event, the SoftDevice
Nrf_soc.h (nrf51822\include\ble\softdevice): *        will interrupt the application to do Radio Event preparation.
Nrf_soc.h (nrf51822\include\ble\softdevice): *      - Using the Radio Notification feature may limit the bandwidth, as the SoftDevice may have
Nrf_soc.h (nrf51822\include\ble\softdevice): *        to shorten the connection events to have time for the Radio Notification signals.
Nrf_soc.h (nrf51822\include\ble\softdevice): *                       @ref NRF_RADIO_NOTIFICATION_TYPE_NONE shall be used to turn off radio
Nrf_soc.h (nrf51822\include\ble\softdevice): *                       notification. Using @ref NRF_RADIO_NOTIFICATION_DISTANCE_NONE is
Nrf_soc.h (nrf51822\include\ble\softdevice): *                       @ref NRF_RADIO_NOTIFICATION_TYPE_NONE.
Nrf_soc.h (nrf51822\include\ble\softdevice): * @param[in]  distance  Distance between the notification signal and start of radio activity.
Nrf_soc.h (nrf51822\include\ble\softdevice): *                       This parameter is ignored when @ref NRF_RADIO_NOTIFICATION_TYPE_NONE or 
Nrf_soc.h (nrf51822\include\ble\softdevice): *                       @ref NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE is used.
Nrf_soc.h (nrf51822\include\ble\softdevice):SVCALL(SD_RADIO_NOTIFICATION_CFG_SET, uint32_t, sd_radio_notification_cfg_set(nrf_radio_notification_type_t type, nrf_radio_notification_distance_t distance));
Nrf_temp.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Nrf_temp.h (nrf51822\include):* @brief Temperature module init and read functions.
Nrf_temp.h (nrf51822\include):    /**@note Workaround for PAN_028 rev2.0A anomaly 31 - TEMP: Temperature offset value has to be manually loaded to the TEMP module */
Nrf_temp.h (nrf51822\include): * @brief Function for reading temperature measurement.
Nrf_temp.h (nrf51822\include): * The function reads the 10 bit 2's complement value and transforms it to a 32 bit 2's complement value.
Nrf_temp.h (nrf51822\include):static __INLINE int32_t nrf_temp_read(void)
Sdio.c (nrf51822\source\ext_sensors\sdio): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Sdio.c (nrf51822\source\ext_sensors\sdio):#define SDIO_DATA_READ() ((NRF_GPIO->IN >> SDIO_CONFIG_DATA_PIN_NUMBER) & 0x1UL) /*!< Reads current state of SDA */
Sdio.c (nrf51822\source\ext_sensors\sdio):#define SDIO_CLOCK_READ() ((NRF_GPIO->IN >> SDIO_CONFIG_CLOCK_PIN_NUMBER) & 0x1UL) /*!< Reads current state of SCL */
Sdio.c (nrf51822\source\ext_sensors\sdio):        if (SDIO_DATA_READ())
Sdio.c (nrf51822\source\ext_sensors\sdio):uint8_t sdio_read_byte(uint8_t address)
Sdio.c (nrf51822\source\ext_sensors\sdio):        if (address & (1U << i))
Sdio.c (nrf51822\source\ext_sensors\sdio):        data_byte |= (uint8_t)(SDIO_DATA_READ() << i);
Sdio.c (nrf51822\source\ext_sensors\sdio):void sdio_read_burst(uint8_t *target_buffer, uint8_t target_buffer_size)
Sdio.c (nrf51822\source\ext_sensors\sdio):    uint_fast8_t address = 0x63;
Sdio.c (nrf51822\source\ext_sensors\sdio):        if (address & (1U << bit_index))
Sdio.c (nrf51822\source\ext_sensors\sdio):            target_buffer[target_buffer_index] |= (uint8_t)(SDIO_DATA_READ() << bit_index);
Sdio.c (nrf51822\source\ext_sensors\sdio):void sdio_write_byte(uint8_t address, uint8_t data_byte)
Sdio.c (nrf51822\source\ext_sensors\sdio):    // Add write indication bit
Sdio.c (nrf51822\source\ext_sensors\sdio):    address |= 0x80;
Sdio.c (nrf51822\source\ext_sensors\sdio):        if (address & (1U << i))
Sdio.h (nrf51822\include\ext_sensors): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Sdio.h (nrf51822\include\ext_sensors):* @brief 2-wire serial interface driver (compatible with ADNS2080 mouse sensor driver)
Sdio.h (nrf51822\include\ext_sensors): * @brief Function for reading a byte over 2-wire serial interface.
Sdio.h (nrf51822\include\ext_sensors): * @param address Register address to read from
Sdio.h (nrf51822\include\ext_sensors): * @return Byte read
Sdio.h (nrf51822\include\ext_sensors):uint8_t sdio_read_byte(uint8_t address);
Sdio.h (nrf51822\include\ext_sensors): * @brief Function for reading several bytes over 2-wire serial interface using burst mode.
Sdio.h (nrf51822\include\ext_sensors): * @param target_buffer Buffer location to store read bytes to
Sdio.h (nrf51822\include\ext_sensors):void sdio_read_burst(uint8_t *target_buffer, uint8_t target_buffer_size);
Sdio.h (nrf51822\include\ext_sensors): * @param address Register address to write to
Sdio.h (nrf51822\include\ext_sensors):void sdio_write_byte(uint8_t address, uint8_t data_byte);
Simple_uart.c (nrf51822\source\simple_uart): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Simple_uart.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Simple_uart.h (nrf51822\include):/** @brief Function for reading a character from UART.
Simple_uart.h (nrf51822\include):/** @brief Function for reading a character from UART with timeout on how long to wait for the byte to be received.
Spi_master.c (nrf51822\source\spi_master): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Spi_master.c (nrf51822\source\spi_master):    NRF_SPI_Type *spi_base_address = (SPI0 == module_number)? NRF_SPI0 : (NRF_SPI_Type *)NRF_SPI1;
Spi_master.c (nrf51822\source\spi_master):        spi_base_address->PSELSCK  = SPI_PSELSCK0;
Spi_master.c (nrf51822\source\spi_master):        spi_base_address->PSELMOSI = SPI_PSELMOSI0;
Spi_master.c (nrf51822\source\spi_master):        spi_base_address->PSELMISO = SPI_PSELMISO0;
Spi_master.c (nrf51822\source\spi_master):        spi_base_address->PSELSCK  = SPI_PSELSCK1;
Spi_master.c (nrf51822\source\spi_master):        spi_base_address->PSELMOSI = SPI_PSELMOSI1;
Spi_master.c (nrf51822\source\spi_master):        spi_base_address->PSELMISO = SPI_PSELMISO1;
Spi_master.c (nrf51822\source\spi_master):    spi_base_address->FREQUENCY = (uint32_t) SPI_OPERATING_FREQUENCY;
Spi_master.c (nrf51822\source\spi_master):            config_mode = (SPI_CONFIG_CPHA_Leading << SPI_CONFIG_CPHA_Pos) | (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos);
Spi_master.c (nrf51822\source\spi_master):            config_mode = (SPI_CONFIG_CPHA_Leading << SPI_CONFIG_CPHA_Pos) | (SPI_CONFIG_CPOL_ActiveLow << SPI_CONFIG_CPOL_Pos);
Spi_master.c (nrf51822\source\spi_master):        spi_base_address->CONFIG = (config_mode | (SPI_CONFIG_ORDER_LsbFirst << SPI_CONFIG_ORDER_Pos));
Spi_master.c (nrf51822\source\spi_master):        spi_base_address->CONFIG = (config_mode | (SPI_CONFIG_ORDER_MsbFirst << SPI_CONFIG_ORDER_Pos));
Spi_master.c (nrf51822\source\spi_master):    spi_base_address->EVENTS_READY = 0U;
Spi_master.c (nrf51822\source\spi_master):    spi_base_address->ENABLE = (SPI_ENABLE_ENABLE_Enabled << SPI_ENABLE_ENABLE_Pos);
Spi_master.c (nrf51822\source\spi_master):    return (uint32_t *)spi_base_address;
Spi_master.c (nrf51822\source\spi_master):bool spi_master_tx_rx(uint32_t *spi_base_address, uint16_t transfer_size, const uint8_t *tx_data, uint8_t *rx_data)
Spi_master.c (nrf51822\source\spi_master):    NRF_SPI_Type *spi_base = (NRF_SPI_Type *)spi_base_address;
Spi_master.c (nrf51822\source\spi_master):    if( (uint32_t *)NRF_SPI0 == spi_base_address)
Spi_master.c (nrf51822\source\spi_master):        while ((spi_base->EVENTS_READY == 0U) && (counter < TIMEOUT_COUNTER))
Spi_master.c (nrf51822\source\spi_master):        {   /* clear the event to be ready to receive next messages */
Spi_master.c (nrf51822\source\spi_master):            spi_base->EVENTS_READY = 0U;
Spi_master.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Spi_master.h (nrf51822\include): * @retval pointer to direct physical address of the requested SPI module if init was successful
Spi_master.h (nrf51822\include): * @param spi_base_address  register base address of the selected SPI master module
Spi_master.h (nrf51822\include):bool spi_master_tx_rx(uint32_t *spi_base_address, uint16_t transfer_size, const uint8_t *tx_data, uint8_t *rx_data);
Spi_master_config.h (source\src): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Spi_master_config.h (source\src):#define DEBUG_EVENT_READY_PIN0    10    /*!< when DEBUG is enabled, this GPIO pin is toggled everytime READY_EVENT is set for SPI0, no toggling means something has gone wrong */
Spi_master_config.h (source\src):#define DEBUG_EVENT_READY_PIN1    11    /*!< when DEBUG is enabled, this GPIO pin is toggled everytime READY_EVENT is set for SPI1, no toggling means something has gone wrong */
Step_counter.h (source\inc):#define PACKET_HEADER_SIZE              sizeof(uint32_t)                                        /**< Size of the data packet header. */
Step_counter.h (source\inc):#define CODE_REGION_1_START             0x00014000                                              /**< This field should correspond to the size of Code Region 0, (Which is identical to Start of Code Region 1), found in UICR.CLEN0 register. This value is used for compile safety, as the linker will fail if application expands into bootloader. Runtime, the bootloader will use the value found in UICR.CLEN0. */
Step_counter.h (source\inc):#define BOOTLOADER_REGION_START         0x00038000                                              /**< This field should correspond to start address of the bootloader, found in UICR.RESERVED, 0x10001014, register. This value is used for sanity check, so the bootloader will fail immediately if this value differs from runtime value. The value is used to determine max application size for updating. */
Step_counter.h (source\inc):#define BOOTLOADER_SETTINGS_ADDRESS     0x0003EC00                                              /**< The field specifies the page location of the bootloader settings address. */
Step_counter.h (source\inc):#define APP_IMAGE_MAX_SIZE              BOOTLOADER_REGION_START - CODE_REGION_1_START           /**< Maximum size of data image we current support for update. */
Step_counter.h (source\inc):#define CODE_PAGE_SIZE                  1024                                                    /**< Size of a flash codepage. Used for size of the reserved flash space in the bootloader region. Will be runtime checked against NRF_UICR->CODEPAGESIZE to ensure the region is correct. */
Step_counter.h (source\inc):#define EMPTY_FLASH_MASK                0xFFFFFFFF                                              /**< Bit mask that defines an empty address in flash. */
Step_counter.h (source\inc):typedef struct SportsHead
Step_counter.h (source\inc):SportsHead_t;
Step_counter.h (source\inc):typedef struct SleepHead
Step_counter.h (source\inc):SleepHead_t;
Step_counter.h (source\inc):static uint8_t readQuarterData(void);
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):#include "synaptics_touchpad.h"
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):static uint8_t m_device_address; //!< Device address in bits [7:1]
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):bool touchpad_init(uint8_t device_address)
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):  m_device_address = (uint8_t)(device_address << 1);
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):  transfer_succeeded &= touchpad_write_register(TOUCHPAD_RESET, reset_command);
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):  transfer_succeeded &= touchpad_write_register(TOUCHPAD_PAGESELECT, page_to_select);
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):  // Read and verify product ID
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):  transfer_succeeded &= touchpad_product_id_verify();
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):bool touchpad_product_id_verify(void) 
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):  transfer_succeeded &= touchpad_product_id_read(product_id, PRODUCT_ID_BYTES);
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):bool touchpad_reset(void)
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):  uint8_t w2_data[2] = {TOUCHPAD_COMMAND, 0x01};
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):  return twi_master_transfer(m_device_address, w2_data, 2, TWI_ISSUE_STOP);
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):bool touchpad_interrupt_status_read(uint8_t *interrupt_status) 
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):  return touchpad_read_register(TOUCHPAD_INT_STATUS, interrupt_status);
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):bool touchpad_set_sleep_mode(TouchpadSleepMode_t mode)
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):  return touchpad_write_register(TOUCHPAD_CONTROL, (uint8_t)mode);
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):bool touchpad_read_register(uint8_t register_address, uint8_t *value)
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):  transfer_succeeded &= twi_master_transfer(m_device_address, &register_address, 1, TWI_DONT_ISSUE_STOP);
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):    transfer_succeeded &= twi_master_transfer(m_device_address | TWI_READ_BIT, value, 1, TWI_ISSUE_STOP);
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):bool touchpad_write_register(uint8_t register_address, const uint8_t value)
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):	w2_data[0] = register_address;
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):  return twi_master_transfer(m_device_address, w2_data, 2, TWI_ISSUE_STOP);
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):bool touchpad_product_id_read(uint8_t *product_id, uint8_t product_id_bytes)
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):	w2_data[0] = TOUCHPAD_PRODUCT_ID;
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):  transfer_succeeded &= twi_master_transfer(m_device_address, w2_data, 1, TWI_DONT_ISSUE_STOP);
Synaptics_touchpad.c (nrf51822\source\ext_sensors\synaptics_touchpad):    transfer_succeeded &= twi_master_transfer(m_device_address | TWI_READ_BIT, product_id, product_id_bytes, TWI_ISSUE_STOP);
Synaptics_touchpad.h (nrf51822\include\ext_sensors): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Synaptics_touchpad.h (nrf51822\include\ext_sensors):#ifndef SYNAPTICS_TOUCHPAD_H
Synaptics_touchpad.h (nrf51822\include\ext_sensors):#define SYNAPTICS_TOUCHPAD_H
Synaptics_touchpad.h (nrf51822\include\ext_sensors):* @brief Synaptics Touchpad driver.
Synaptics_touchpad.h (nrf51822\include\ext_sensors):* @defgroup nrf_drivers_synaptics_touchpad Synaptics Touchpad driver.
Synaptics_touchpad.h (nrf51822\include\ext_sensors):* @brief Synaptics Touchpad driver.
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  Touchpad register addresses. 
Synaptics_touchpad.h (nrf51822\include\ext_sensors):#define TOUCHPAD_INT_STATUS    0x14    //!< Interrupt status register
Synaptics_touchpad.h (nrf51822\include\ext_sensors):#define TOUCHPAD_BUTTON_STATUS 0x41    //!< Button status register
Synaptics_touchpad.h (nrf51822\include\ext_sensors):#define TOUCHPAD_FINGER0_REL   0x30    //!< First register in finger delta block
Synaptics_touchpad.h (nrf51822\include\ext_sensors):#define TOUCHPAD_GESTURE_FLAGS 0x3A    //!< Gesture flags 0
Synaptics_touchpad.h (nrf51822\include\ext_sensors):#define TOUCHPAD_SCROLL        0x3F    //!< Scroll zone X / horizontal multifinger scroll
Synaptics_touchpad.h (nrf51822\include\ext_sensors):#define TOUCHPAD_CONTROL       0x42    //!< Device control register
Synaptics_touchpad.h (nrf51822\include\ext_sensors):#define TOUCHPAD_COMMAND       0x8F    //!< Device command register
Synaptics_touchpad.h (nrf51822\include\ext_sensors):#define TOUCHPAD_RESET 0x54 //!< Address of reset
Synaptics_touchpad.h (nrf51822\include\ext_sensors):#define TOUCHPAD_PAGESELECT 0xFF //!< Address of page select (can be found in every page at the same address)
Synaptics_touchpad.h (nrf51822\include\ext_sensors):#define TOUCHPAD_PRODUCT_ID 0xA2 //!< Address of product ID string
Synaptics_touchpad.h (nrf51822\include\ext_sensors):} TouchpadSleepMode_t;
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @brief Function for Touchpad initialization.
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @param device_address TWI address of the device in bits [6:0]
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @retval true Touchpad was successfully identified and initialized
Synaptics_touchpad.h (nrf51822\include\ext_sensors):bool touchpad_init(uint8_t device_address);
Synaptics_touchpad.h (nrf51822\include\ext_sensors):bool touchpad_reset(void);
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @brief Function for reading the interrupt status register of the device. This clears all interrupts.
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @param interrupt_status Address to store interrupt status to.
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @retval true Register contents read successfully to interrupt_status
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @retval false Reading failed
Synaptics_touchpad.h (nrf51822\include\ext_sensors):bool touchpad_interrupt_status_read(uint8_t *interrupt_status);
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @note In low power mode the touchpad do not generate interrupts from touch sensing.
Synaptics_touchpad.h (nrf51822\include\ext_sensors):bool touchpad_set_sleep_mode(TouchpadSleepMode_t mode);
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @brief Function for reading a touchpad register contents over TWI.  
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @param[in] register_address Register address
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @param[out] value Pointer to a data buffer where read data will be stored
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @retval true Register read succeeded
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @retval false Register read failed
Synaptics_touchpad.h (nrf51822\include\ext_sensors):bool touchpad_read_register(uint8_t register_address, uint8_t *value);
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @brief Function for writing a touchpad register contents over TWI.
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @param[in]  register_address Register address
Synaptics_touchpad.h (nrf51822\include\ext_sensors):bool touchpad_write_register(uint8_t register_address, uint8_t value);
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @brief Function for writing touchpad register contents over TWI.
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @param[out] product_id Pointer to a address to store product ID. Memory must be allocated for product_id_bytes number of bytes.
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @param[in]  product_id_bytes Number of bytes to read
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @retval true Product ID read succeeded
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @retval false Product ID read failed
Synaptics_touchpad.h (nrf51822\include\ext_sensors):bool touchpad_product_id_read(uint8_t *product_id, uint8_t product_id_bytes);
Synaptics_touchpad.h (nrf51822\include\ext_sensors):  @brief Function for reading and verifying touchpad's product ID.
Synaptics_touchpad.h (nrf51822\include\ext_sensors):bool touchpad_product_id_verify(void);
Synaptics_touchpad.h (nrf51822\include\ext_sensors):#endif /* __TOUCHPAD_H__ */
System_nrf51.c (nrf51822\source\templates): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
System_nrf51.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Twi_hw_master.c (nrf51822\source\twi_master): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Twi_hw_master.c (nrf51822\source\twi_master):/* Max cycles approximately to wait on RXDREADY and TXDREADY event, 
Twi_hw_master.c (nrf51822\source\twi_master): * This is optimized way instead of using timers, this is not power aware. */
Twi_hw_master.c (nrf51822\source\twi_master):          // https://www.nordicsemi.com/eng/Products/Bluetooth-R-low-energy/nRF51822/#Downloads
Twi_hw_master.c (nrf51822\source\twi_master):/** @brief Function for read by twi_master. 
Twi_hw_master.c (nrf51822\source\twi_master):static bool twi_master_read(uint8_t *data, uint8_t data_length, bool issue_stop_condition)
Twi_hw_master.c (nrf51822\source\twi_master):    uint32_t timeout = MAX_TIMEOUT_LOOPS;   /* max loops to wait for RXDREADY event*/
Twi_hw_master.c (nrf51822\source\twi_master):    NRF_TWI1->EVENTS_RXDREADY = 0;
Twi_hw_master.c (nrf51822\source\twi_master):    /** @snippet [TWI HW master read] */                
Twi_hw_master.c (nrf51822\source\twi_master):        while(NRF_TWI1->EVENTS_RXDREADY == 0 && NRF_TWI1->EVENTS_ERROR == 0 && (--timeout))
Twi_hw_master.c (nrf51822\source\twi_master):        NRF_TWI1->EVENTS_RXDREADY = 0;
Twi_hw_master.c (nrf51822\source\twi_master):          // https://www.nordicsemi.com/eng/Products/Bluetooth-R-low-energy/nRF51822/#Downloads
Twi_hw_master.c (nrf51822\source\twi_master):        // https://www.nordicsemi.com/eng/Products/Bluetooth-R-low-energy/nRF51822/#Downloads
Twi_hw_master.c (nrf51822\source\twi_master):    /** @snippet [TWI HW master read] */                    
Twi_hw_master.c (nrf51822\source\twi_master):    if ((TWI_SDA_READ() == 1) && (TWI_SCL_READ() == 1))
Twi_hw_master.c (nrf51822\source\twi_master):            if (TWI_SDA_READ() == 1)
Twi_hw_master.c (nrf51822\source\twi_master):    NRF_TWI1->EVENTS_RXDREADY = 0;
Twi_hw_master.c (nrf51822\source\twi_master):bool twi_master_transfer(uint8_t   address, 
Twi_hw_master.c (nrf51822\source\twi_master):        NRF_TWI1->ADDRESS = (address >> 1);
Twi_hw_master.c (nrf51822\source\twi_master):        if ((address & TWI_READ_BIT))
Twi_hw_master.c (nrf51822\source\twi_master):            transfer_succeeded = twi_master_read(data, data_length, issue_stop_condition);
Twi_master.h (nrf51822\include): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Twi_master.h (nrf51822\include):* - Only 7-bit addressing
Twi_master.h (nrf51822\include):#define TWI_READ_BIT                 (0x01)        //!< If this bit is set in the address field, transfer direction is from slave to master.
Twi_master.h (nrf51822\include):#define TWI_SDA_READ() ((NRF_GPIO->IN >> TWI_MASTER_CONFIG_DATA_PIN_NUMBER) & 0x1UL)                     /*!< Reads current state of SDA */
Twi_master.h (nrf51822\include):#define TWI_SCL_READ() ((NRF_GPIO->IN >> TWI_MASTER_CONFIG_CLOCK_PIN_NUMBER) & 0x1UL)                    /*!< Reads current state of SCL */
Twi_master.h (nrf51822\include): * Bit 0 (@ref TWI_READ_BIT) in the address parameter controls transfer direction;
Twi_master.h (nrf51822\include): * - If 1, master reads data_length number of bytes from the slave
Twi_master.h (nrf51822\include): * @note Make sure at least data_length number of bytes is allocated in data if TWI_READ_BIT is set.
Twi_master.h (nrf51822\include): * @param address Data transfer direction (LSB) / Slave address (7 MSBs).
Twi_master.h (nrf51822\include):bool twi_master_transfer(uint8_t address, uint8_t *data, uint8_t data_length, bool issue_stop_condition);
Twi_sw_master.c (nrf51822\source\twi_master): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Twi_sw_master.c (nrf51822\source\twi_master):#ifndef TWI_MASTER_TIMEOUT_COUNTER_LOAD_VALUE
Twi_sw_master.c (nrf51822\source\twi_master):#define TWI_MASTER_TIMEOUT_COUNTER_LOAD_VALUE (0UL) //!< Unit is number of empty loops. Timeout for SMBus devices is 35 ms. Set to zero to disable slave timeout altogether.
Twi_sw_master.c (nrf51822\source\twi_master):bool twi_master_transfer(uint8_t address, uint8_t *data, uint8_t data_length, bool issue_stop_condition)
Twi_sw_master.c (nrf51822\source\twi_master):    transfer_succeeded &= twi_master_clock_byte(address);
Twi_sw_master.c (nrf51822\source\twi_master):    if (address & TWI_READ_BIT)
Twi_sw_master.c (nrf51822\source\twi_master):    if (TWI_SDA_READ() == 1 && TWI_SCL_READ() == 1)
Twi_sw_master.c (nrf51822\source\twi_master):    else if (TWI_SCL_READ() == 1)
Twi_sw_master.c (nrf51822\source\twi_master):            if (TWI_SDA_READ() == 1)
Twi_sw_master.c (nrf51822\source\twi_master):    if (TWI_SCL_READ() == 1 && TWI_SDA_READ() == 1)
Twi_sw_master.c (nrf51822\source\twi_master):    else if (TWI_SCL_READ() == 1 && TWI_SDA_READ() == 0)
Twi_sw_master.c (nrf51822\source\twi_master):    else if (TWI_SCL_READ() == 0 && TWI_SDA_READ() == 0)
Twi_sw_master.c (nrf51822\source\twi_master):    else if (TWI_SCL_READ() == 0 && TWI_SDA_READ() == 1)
Twi_sw_master.c (nrf51822\source\twi_master):    if (TWI_SCL_READ() == 1 && TWI_SDA_READ() == 1)
Twi_sw_master.c (nrf51822\source\twi_master):    else if (TWI_SCL_READ() == 1 && TWI_SDA_READ() == 0)
Twi_sw_master.c (nrf51822\source\twi_master):    else if (TWI_SCL_READ() == 0 && TWI_SDA_READ() == 0)
Twi_sw_master.c (nrf51822\source\twi_master):    else if (TWI_SCL_READ() == 0 && TWI_SDA_READ() == 1)
Twi_sw_master.c (nrf51822\source\twi_master): * @brief Function for clocking one data byte out and reads slave acknowledgment.
Twi_sw_master.c (nrf51822\source\twi_master):    // Give some time for the slave to load the ACK bit on the line
Twi_sw_master.c (nrf51822\source\twi_master):    // Read ACK/NACK. NACK == 1, ACK == 0
Twi_sw_master.c (nrf51822\source\twi_master):    transfer_succeeded &= !(TWI_SDA_READ());
Twi_sw_master.c (nrf51822\source\twi_master): * @retval true Byte read succesfully
Twi_sw_master.c (nrf51822\source\twi_master):    uint_fast8_t byte_read = 0;
Twi_sw_master.c (nrf51822\source\twi_master):        if (TWI_SDA_READ())
Twi_sw_master.c (nrf51822\source\twi_master):            byte_read |= i;
Twi_sw_master.c (nrf51822\source\twi_master):    *databyte = (uint8_t)byte_read;
Twi_sw_master.c (nrf51822\source\twi_master): * @note If TWI_MASTER_TIMEOUT_COUNTER_LOAD_VALUE is set to zero, timeout functionality is not compiled in.
Twi_sw_master.c (nrf51822\source\twi_master):#if TWI_MASTER_TIMEOUT_COUNTER_LOAD_VALUE != 0
Twi_sw_master.c (nrf51822\source\twi_master):    uint32_t volatile timeout_counter = TWI_MASTER_TIMEOUT_COUNTER_LOAD_VALUE;
Twi_sw_master.c (nrf51822\source\twi_master):    while (TWI_SCL_READ() == 0)
Twi_sw_master.c (nrf51822\source\twi_master):#if TWI_MASTER_TIMEOUT_COUNTER_LOAD_VALUE != 0
Uicr_config.h (nrf51822\source\templates\arm): * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
Uicr_config.h (nrf51822\source\templates\arm): * the desired value in the desired address, uncomment the variable with the proper address
Uicr_config.h (nrf51822\source\templates\arm): * stored into when downloading a hex file. Do not use these defined variables to store data 
Uicr_config.h (nrf51822\source\templates\arm): * Note that the hex file generated when this file is included will fail to download when using
Uicr_config.h (nrf51822\source\templates\arm): * the standard download algorithm provided by Nordic. See example project "uicr_config_example" 
Uicr_config.h (nrf51822\source\templates\arm): * in any of the board example folders for an example of the recommended download method as well
Uicr_config.h (nrf51822\source\templates\arm): * Please note as well that if you are using a SoftDevice the UICR_CLENR0 address will
Uicr_config.h (nrf51822\source\templates\arm): * already be in use. Do not uncomment that line.
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_CLENR0    __attribute__((at(0x10001000))) __attribute__((used)) = 0xFFFFFFFF;   // WARNING: This address might be used by the SoftDevice. Use with care.
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0x80 __attribute__((at(0x10001080))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0x84 __attribute__((at(0x10001084))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0x88 __attribute__((at(0x10001088))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0x8C __attribute__((at(0x1000108C))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0x90 __attribute__((at(0x10001090))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0x94 __attribute__((at(0x10001094))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0x98 __attribute__((at(0x10001098))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0x9C __attribute__((at(0x1000109C))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xA0 __attribute__((at(0x100010A0))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xA4 __attribute__((at(0x100010A4))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xA8 __attribute__((at(0x100010A8))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xAC __attribute__((at(0x100010AC))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xB0 __attribute__((at(0x100010B0))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xB4 __attribute__((at(0x100010B4))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xB8 __attribute__((at(0x100010B8))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xBC __attribute__((at(0x100010BC))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xC0 __attribute__((at(0x100010C0))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xC4 __attribute__((at(0x100010C4))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xC8 __attribute__((at(0x100010C8))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xCC __attribute__((at(0x100010CC))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xD0 __attribute__((at(0x100010D0))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xD4 __attribute__((at(0x100010D4))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xD8 __attribute__((at(0x100010D8))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xDC __attribute__((at(0x100010DC))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xE0 __attribute__((at(0x100010E0))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xE4 __attribute__((at(0x100010E4))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xE8 __attribute__((at(0x100010E8))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xEC __attribute__((at(0x100010EC))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xF0 __attribute__((at(0x100010F0))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xF4 __attribute__((at(0x100010F4))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xF8 __attribute__((at(0x100010F8))) __attribute__((used)) = 0xFFFFFFFF;
Uicr_config.h (nrf51822\source\templates\arm):// const uint32_t UICR_ADDR_0xFC __attribute__((at(0x100010FC))) __attribute__((used)) = 0xFFFFFFFF;
---- random_device_address_encode Matches (1 in 1 files) ----
Ble_advdata.c (nrf51822\source\ble):uint32_t random_device_address_encode(uint8_t *             p_encoded_data,
---- random_device_address_encode Matches (1 in 1 files) ----
Ble_advdata.c (nrf51822\source\ble):uint32_t random_device_address_encode(uint8_t *             p_encoded_data,
